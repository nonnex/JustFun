/*
* FileName = SoftBodyComputeShader.cpp
* FilePath = SoftBodyDemo/Plugins/SoftBodyPhysics/Source/SoftBodyPhysics/Private
*/

#include "SoftBodyComputeShader.h"
#include "RHIStaticStates.h" // Access to RHI static states
#include "ShaderParameterUtils.h" // Shader parameter binding utilities
#include "Shader.h" // FComputeShaderRHIRef and TShaderMapRef
#include "RenderCore.h" // GMaxRHIFeatureLevel
#include "RHICommandList.h" // FRHICommandListImmediate

// Register the global compute shader with UE’s shader system
// Virtual path to .usf, "CSMain" entry point, SF_Compute for compute shader
IMPLEMENT_GLOBAL_SHADER(FSoftBodyComputeShader, "/Plugins/SoftBodyPhysics/Private/SoftBodyPhysics.usf", "CSMain", SF_Compute);

/**
 * @brief Dispatches the compute shader to simulate soft body physics on the GPU.
 * @details Binds parameters using UE 5.5.3’s batched API, dispatches with 64 threads per group,
 *          and unbinds UAVs to avoid resource hazards. Fully aligned with latest RHI.
 * @param RHICmdList Immediate command list for GPU execution.
 * @param SimPositions Buffer for vertex positions.
 * @param SimPositionsUAV UAV for writing positions.
 * @param SimVelocities Buffer for vertex velocities.
 * @param SimVelocitiesUAV UAV for writing velocities.
 * @param Springs Buffer with spring data.
 * @param SpringsSRV SRV for reading springs.
 * @param BoneOffsets Buffer with bone offsets.
 * @param BoneOffsetsSRV SRV for reading offsets.
 * @param VertexOffsets Buffer for mesh offsets.
 * @param VertexOffsetsUAV UAV for writing offsets.
 * @param ShaderParams Uniform buffer with simulation parameters.
 * @param BoneTransforms Uniform buffer with bone matrices.
 * @param NumThreadsX Number of vertices to simulate.
 */
void FSoftBodyComputeShader::Dispatch(
    FRHICommandListImmediate& RHICmdList,
    FRHIBuffer* SimPositions, FRHIUnorderedAccessView* SimPositionsUAV,
    FRHIBuffer* SimVelocities, FRHIUnorderedAccessView* SimVelocitiesUAV,
    FRHIBuffer* Springs, FRHIShaderResourceView* SpringsSRV,
    FRHIBuffer* BoneOffsets, FRHIShaderResourceView* BoneOffsetsSRV,
    FRHIBuffer* VertexOffsets, FRHIUnorderedAccessView* VertexOffsetsUAV,
    TUniformBufferRef<FSoftBodyShaderParams> ShaderParams,
    TUniformBufferRef<FBoneTransformData> BoneTransforms,
    uint32 NumThreadsX
)
{
    // Robust input validation to prevent crashes or undefined behavior
    checkf(RHICmdList.IsImmediate(), TEXT("Dispatch requires an immediate command list."));
    checkf(SimPositions && SimPositionsUAV, TEXT("SimPositions buffer and UAV must be valid."));
    checkf(SimVelocities && SimVelocitiesUAV, TEXT("SimVelocities buffer and UAV must be valid."));
    checkf(Springs && SpringsSRV, TEXT("Springs buffer and SRV must be valid."));
    checkf(BoneOffsets && BoneOffsetsSRV, TEXT("BoneOffsets buffer and SRV must be valid."));
    checkf(VertexOffsets && VertexOffsetsUAV, TEXT("VertexOffsets buffer and UAV must be valid."));
    checkf(NumThreadsX > 0, TEXT("NumThreadsX must be positive for dispatch."));

    // Fetch the compute shader from the global shader map
    TShaderMapRef<FSoftBodyComputeShader> ComputeShader(GetGlobalShaderMap(GMaxRHIFeatureLevel));
    FComputeShaderRHIRef ShaderRHI = ComputeShader.GetComputeShader();
    checkf(ShaderRHI.IsValid(), TEXT("Invalid compute shader RHI—ensure shader compiled for platform."));

    // Set the compute shader using UE 5.5.3’s correct method
    RHICmdList.SetComputeShader(ShaderRHI);

    // Batch shader parameters for efficient binding (UE 5.5.3 requirement)
    FRHIBatchedShaderParameters BatchedParams(RHICmdList);

    // Bind UAVs for output buffers (now compatible with FShaderResourceParameter)
    SetUAVParameter(BatchedParams, SimPositionsParam, SimPositionsUAV);
    SetUAVParameter(BatchedParams, SimVelocitiesParam, SimVelocitiesUAV);
    SetUAVParameter(BatchedParams, VertexOffsetsParam, VertexOffsetsUAV);

    // Bind SRVs for input buffers
    SetSRVParameter(BatchedParams, SpringsParam, SpringsSRV);
    SetSRVParameter(BatchedParams, BoneOffsetsParam, BoneOffsetsSRV);

    // Bind uniform buffers for constants
    SetUniformBufferParameter(BatchedParams, ShaderParamsParam, ShaderParams);
    SetUniformBufferParameter(BatchedParams, BoneTransformsParam, BoneTransforms);

    // Apply all batched parameters to the command list
    RHICmdList.SetBatchedShaderParameters(ShaderRHI, BatchedParams);

    // Compute thread groups (64 threads per group, matching .usf)
    const uint32 GroupCountX = FMath::DivideAndRoundUp(NumThreadsX, 64u);
    checkf(GroupCountX > 0, TEXT("GroupCountX must be positive after calculation."));

    // Dispatch the compute shader
    RHICmdList.DispatchComputeShader(GroupCountX, 1, 1);

    // Unbind UAVs to release resources and prevent hazards
    FRHIBatchedShaderParameters UnbindParams(RHICmdList);
    SetUAVParameter(UnbindParams, SimPositionsParam, nullptr);
    SetUAVParameter(UnbindParams, SimVelocitiesParam, nullptr);
    SetUAVParameter(UnbindParams, VertexOffsetsParam, nullptr);
    RHICmdList.SetBatchedShaderParameters(ShaderRHI, UnbindParams);
}/* <NEW_LINE> */
/*
* FileName = <FileName>
* FilePath = <UnrealProjectName>/Plugins/<PluginName>/Source/<PluginName>/Private
*/

#include "SoftBodyPhysics.h"
#include "Modules/ModuleManager.h"
#include "Interfaces/IPluginManager.h"
#include "Misc/Paths.h"

DEFINE_LOG_CATEGORY(LogSoftBodyPhysics);

#define LOCTEXT_NAMESPACE "FSoftBodyPhysicsModule"

void FSoftBodyPhysicsModule::StartupModule()
{
    TSharedPtr<IPlugin> Plugin = IPluginManager::Get().FindPlugin(TEXT("SoftBodyPhysics"));
    if (!Plugin.IsValid())
    {
        UE_LOG(LogSoftBodyPhysics, Error, TEXT("Failed to find SoftBodyPhysics plugin"));
        return;
    }

    UE_LOG(LogSoftBodyPhysics, Log, TEXT("SoftBodyPhysics module started successfully. Shader integration pending."));
}

void FSoftBodyPhysicsModule::ShutdownModule()
{
    UE_LOG(LogSoftBodyPhysics, Log, TEXT("SoftBodyPhysics module shut down"));
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FSoftBodyPhysicsModule, SoftBodyPhysics)/*
* FileName = SoftBodyPhysicsComponent.cpp
* FilePath = SoftBodyDemo/Plugins/SoftBodyPhysics/Source/SoftBodyPhysics/Private
*/

#include "SoftBodyPhysicsComponent.h"
#include "Components/SkeletalMeshComponent.h"
#include "Rendering/SkeletalMeshRenderData.h"
#include "RHICommandList.h" // FRHICommandListImmediate
#include "RHIUtilities.h" // RHICreate* utilities
#include "RenderCore.h" // GMaxRHIFeatureLevel
#include "ShaderParameterUtils.h" // Shader parameter binding
#include "SoftBodyComputeShader.h" // Compute shader dispatch
#include "RHI.h" // GDynamicRHI, GRHICommandList
#include "DynamicRHI.h" // GDynamicRHI access
#include "Logging/LogMacros.h" // UE_LOG and log categories

// Define the log category
DEFINE_LOG_CATEGORY(LogSoftBodyPhysics);

/**
 * @brief Constructs the soft body physics component with default settings.
 * @details Sets up ticking and initializes simulation parameters safely.
 */
USoftBodyPhysicsComponent::USoftBodyPhysicsComponent()
{
    PrimaryComponentTick.bCanEverTick = true; // Enable frame updates
    SimVertexCount = 150;    // Default simulated vertices
    Stiffness = 10.0f;       // Spring stiffness
    Damping = 0.3f;          // Velocity damping
    MuscleStrength = 0.5f;   // Muscle force strength
    MaxVelocity = 1000.0f;   // Velocity cap
    bEnableDetailedLogging = false; // Logging off by default

    // Null-initialize RHI resources
    SimPositionsBuffer = nullptr;
    SimVelocitiesBuffer = nullptr;
    SpringsBuffer = nullptr;
    BoneOffsetsBuffer = nullptr;
    VertexOffsetsBuffer = nullptr;
}

/**
 * @brief Initializes the component at game start.
 * @details Locates the skeletal mesh and sets up the simulation.
 */
void USoftBodyPhysicsComponent::BeginPlay()
{
    Super::BeginPlay();
    USkeletalMeshComponent* Mesh = GetOwner()->FindComponentByClass<USkeletalMeshComponent>();
    if (!Mesh)
    {
        UE_LOG(LogSoftBodyPhysics, Error, TEXT("BeginPlay: No SkeletalMeshComponent found."));
        return;
    }
    InitializeSoftBody(Mesh);
}

/**
 * @brief Updates the simulation each frame.
 * @param DeltaTime Time since last frame.
 * @param TickType Tick event type.
 * @param ThisTickFunction Tick function context.
 * @details Updates parameters, dispatches shader, and flags mesh for render.
 */
void USoftBodyPhysicsComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
    USkeletalMeshComponent* Mesh = GetOwner()->FindComponentByClass<USkeletalMeshComponent>();
    if (!Mesh)
    {
        return; // Skip if mesh is missing (logged in BeginPlay)
    }

    FRHICommandListImmediate& RHICmdList = GRHICommandList.GetImmediateCommandList();
    UpdateShaderParams(Mesh, DeltaTime);
    DispatchComputeShader(RHICmdList);
    Mesh->MarkRenderStateDirty(); // Update rendering
}

/**
 * @brief Sets up the soft body simulation for a skeletal mesh.
 * @param TargetMesh The skeletal mesh to simulate.
 * @details Subsamples vertices, creates springs, maps bones, and sets up GPU buffers.
 */
void USoftBodyPhysicsComponent::InitializeSoftBody(USkeletalMeshComponent* TargetMesh)
{
    if (!TargetMesh || !TargetMesh->GetSkeletalMeshRenderData())
    {
        UE_LOG(LogSoftBodyPhysics, Error, TEXT("InitializeSoftBody: Invalid mesh or render data."));
        return;
    }

    FSkeletalMeshLODRenderData& LODData = TargetMesh->GetSkeletalMeshRenderData()->LODRenderData[0];
    FPositionVertexBuffer& VertexBuffer = LODData.StaticVertexBuffers.PositionVertexBuffer;
    int32 TotalVertices = VertexBuffer.GetNumVertices();
    checkf(TotalVertices > 0, TEXT("Mesh has no vertices—cannot initialize."));

    // Clear and resize arrays
    SimPositions.Empty(SimVertexCount);
    SimVelocities.Empty(SimVertexCount);
    SimVertexIndices.Empty(SimVertexCount);
    Springs.Empty(SimVertexCount);
    VertexOffsets.Empty(TotalVertices);
    VertexOffsets.AddZeroed(TotalVertices);
    VertexToBoneMap.Empty();
    BoneOffsets.Empty();

    // Subsample vertices
    int32 Step = FMath::Max(TotalVertices / FMath::Max(SimVertexCount, 1), 1);
    for (int32 i = 0; i < SimVertexCount && i * Step < TotalVertices; i++)
    {
        int32 VertexIdx = i * Step;
        FVector3f Pos3f = VertexBuffer.VertexPosition(VertexIdx);
        FVector Pos(Pos3f.X, Pos3f.Y, Pos3f.Z);
        SimPositions.Add(Pos);
        SimVertexIndices.Add(VertexIdx);
        SimVelocities.Add(FVector::ZeroVector);
    }
    SimVertexCount = SimPositions.Num();

    // Map vertices to bones
    for (int32 i = 0; i < SimVertexCount; i++)
    {
        int32 VertexIdx = SimVertexIndices[i];
        int32 BoneIdx = LODData.SkinWeightVertexBuffer.GetBoneIndex(VertexIdx, 0);
        if (BoneIdx != INDEX_NONE)
        {
            FTransform BoneTransform = TargetMesh->GetBoneTransform(BoneIdx);
            FVector BonePosLocal = TargetMesh->GetComponentTransform().InverseTransformPosition(BoneTransform.GetTranslation());
            BoneOffsets.Add(i, BonePosLocal);
            VertexToBoneMap.Add(i, BoneIdx);
        }
    }

    // Generate springs
    Springs.SetNum(SimVertexCount);
    for (int32 i = 0; i < SimVertexCount; i++)
    {
        for (int32 j = i + 1; j < SimVertexCount; j++)
        {
            float Distance = FVector::Dist(SimPositions[i], SimPositions[j]);
            if (Distance > 1.0f && Distance < 30.0f)
            {
                Springs[i].Add(j);
                Springs[j].Add(i);
            }
        }
    }

    // Initialize GPU buffers
    SetupRHIBuffers(TargetMesh);
    ShaderParamsBuffer = TUniformBufferRef<FSoftBodyShaderParams>::CreateUniformBufferImmediate(FSoftBodyShaderParams(), UniformBuffer_SingleFrame);
    BoneTransformsBuffer = TUniformBufferRef<FBoneTransformData>::CreateUniformBufferImmediate(FBoneTransformData(), UniformBuffer_SingleFrame);

    UE_LOG(LogSoftBodyPhysics, Log, TEXT("Initialized soft body: %d simulated, %d total vertices."), SimVertexCount, TotalVertices);
}

/**
 * @brief Initializes GPU buffers for the simulation.
 * @param TargetMesh The skeletal mesh to attach buffers to.
 * @details Creates buffers with UE 5.5.3’s RHI API and attaches vertex offsets.
 */
void USoftBodyPhysicsComponent::SetupRHIBuffers(USkeletalMeshComponent* TargetMesh)
{
    FRHICommandListImmediate& RHICmdList = GRHICommandList.GetImmediateCommandList();

    // SimPositionsBuffer
    FRHIResourceCreateInfo PositionsCreateInfo(TEXT("SimPositionsBuffer"));
    FRHIBufferDesc PositionsDesc(
        SimPositions.Num() * sizeof(FVector), // Size
        BUF_Dynamic | BUF_ShaderResource | BUF_UnorderedAccess, // Usage
        sizeof(FVector), // Stride
        0, // Alignment
        PF_R32G32B32F // Format
    );
    SimPositionsBuffer = GDynamicRHI->RHICreateBuffer(RHICmdList, PositionsDesc, ERHIAccess::UAVCompute, PositionsCreateInfo);
    SimPositionsUAV = RHICmdList.CreateUnorderedAccessView(SimPositionsBuffer, PF_R32G32B32F);
    void* PosData = RHICmdList.LockBuffer(SimPositionsBuffer, 0, SimPositions.Num() * sizeof(FVector), RLM_WriteOnly);
    FMemory::Memcpy(PosData, SimPositions.GetData(), SimPositions.Num() * sizeof(FVector));
    RHICmdList.UnlockBuffer(SimPositionsBuffer);

    // SimVelocitiesBuffer
    FRHIResourceCreateInfo VelocitiesCreateInfo(TEXT("SimVelocitiesBuffer"));
    FRHIBufferDesc VelocitiesDesc(
        SimVelocities.Num() * sizeof(FVector),
        BUF_Dynamic | BUF_ShaderResource | BUF_UnorderedAccess,
        sizeof(FVector),
        0,
        PF_R32G32B32F
    );
    SimVelocitiesBuffer = GDynamicRHI->RHICreateBuffer(RHICmdList, VelocitiesDesc, ERHIAccess::UAVCompute, VelocitiesCreateInfo);
    SimVelocitiesUAV = RHICmdList.CreateUnorderedAccessView(SimVelocitiesBuffer, PF_R32G32B32F);
    void* VelData = RHICmdList.LockBuffer(SimVelocitiesBuffer, 0, SimVelocities.Num() * sizeof(FVector), RLM_WriteOnly);
    FMemory::Memcpy(VelData, SimVelocities.GetData(), SimVelocities.Num() * sizeof(FVector));
    RHICmdList.UnlockBuffer(SimVelocitiesBuffer);

    // SpringsBuffer
    TArray<int32> SpringsFlat;
    for (int32 i = 0; i < Springs.Num(); i++)
    {
        SpringsFlat.Add(Springs[i].Num());
        SpringsFlat.Append(Springs[i]);
    }
    FRHIResourceCreateInfo SpringsCreateInfo(TEXT("SpringsBuffer"));
    FRHIBufferDesc SpringsDesc(
        SpringsFlat.Num() * sizeof(int32),
        BUF_Dynamic | BUF_ShaderResource,
        sizeof(int32),
        0,
        PF_R32_SINT
    );
    SpringsBuffer = GDynamicRHI->RHICreateBuffer(RHICmdList, SpringsDesc, ERHIAccess::SRVCompute, SpringsCreateInfo);
    SpringsSRV = RHICmdList.CreateShaderResourceView(SpringsBuffer, sizeof(int32), PF_R32_SINT);
    void* SpringsData = RHICmdList.LockBuffer(SpringsBuffer, 0, SpringsFlat.Num() * sizeof(int32), RLM_WriteOnly);
    FMemory::Memcpy(SpringsData, SpringsFlat.GetData(), SpringsFlat.Num() * sizeof(int32));
    RHICmdList.UnlockBuffer(SpringsBuffer);

    // BoneOffsetsBuffer
    TArray<FVector> BoneOffsetArray;
    for (const auto& Pair : BoneOffsets) BoneOffsetArray.Add(Pair.Value);
    FRHIResourceCreateInfo BoneOffsetsCreateInfo(TEXT("BoneOffsetsBuffer"));
    FRHIBufferDesc BoneOffsetsDesc(
        BoneOffsetArray.Num() * sizeof(FVector),
        BUF_Dynamic | BUF_ShaderResource,
        sizeof(FVector),
        0,
        PF_R32G32B32F
    );
    BoneOffsetsBuffer = GDynamicRHI->RHICreateBuffer(RHICmdList, BoneOffsetsDesc, ERHIAccess::SRVCompute, BoneOffsetsCreateInfo);
    BoneOffsetsSRV = RHICmdList.CreateShaderResourceView(BoneOffsetsBuffer, sizeof(FVector), PF_R32G32B32F);
    void* BoneData = RHICmdList.LockBuffer(BoneOffsetsBuffer, 0, BoneOffsetArray.Num() * sizeof(FVector), RLM_WriteOnly);
    FMemory::Memcpy(BoneData, BoneOffsetArray.GetData(), BoneOffsetArray.Num() * sizeof(FVector));
    RHICmdList.UnlockBuffer(BoneOffsetsBuffer);

    // VertexOffsetsBuffer
    FSkeletalMeshLODRenderData& LODData = TargetMesh->GetSkeletalMeshRenderData()->LODRenderData[0];
    FRHIResourceCreateInfo VertexOffsetsCreateInfo(TEXT("VertexOffsetsBuffer"));
    FRHIBufferDesc VertexOffsetsDesc(
        VertexOffsets.Num() * sizeof(FVector),
        BUF_Dynamic | BUF_ShaderResource | BUF_UnorderedAccess | BUF_VertexBuffer,
        sizeof(FVector),
        0,
        PF_R32G32B32F
    );
    VertexOffsetsBuffer = GDynamicRHI->RHICreateBuffer(RHICmdList, VertexOffsetsDesc, ERHIAccess::UAVCompute, VertexOffsetsCreateInfo);
    VertexOffsetsUAV = RHICmdList.CreateUnorderedAccessView(VertexOffsetsBuffer, PF_R32G32B32F);
    void* OffsetsData = RHICmdList.LockBuffer(VertexOffsetsBuffer, 0, VertexOffsets.Num() * sizeof(FVector), RLM_WriteOnly);
    FMemory::Memcpy(OffsetsData, VertexOffsets.GetData(), VertexOffsets.Num() * sizeof(FVector));
    RHICmdList.UnlockBuffer(VertexOffsetsBuffer);

    // Attach to mesh
    LODData.StaticVertexBuffers.PositionVertexBuffer.VertexBufferRHI = VertexOffsetsBuffer;
}

/**
 * @brief Updates simulation parameters for the current frame.
 * @param Mesh The skeletal mesh component.
 * @param DeltaTime Time since last frame.
 * @details Updates uniform buffers with constants and bone transforms.
 */
void USoftBodyPhysicsComponent::UpdateShaderParams(USkeletalMeshComponent* Mesh, float DeltaTime)
{
    FSoftBodyShaderParams Params{};
    Params.Stiffness = Stiffness;
    Params.Damping = Damping;
    Params.MuscleStrength = MuscleStrength;
    Params.MaxVelocity = MaxVelocity;
    Params.DeltaTime = FMath::Min(DeltaTime, 0.033f); // Stability cap
    Params.SimVertexCount = SimVertexCount;
    Params.TotalVertexCount = VertexOffsets.Num();
    Params.Padding = 0; // Alignment
    ShaderParamsBuffer = TUniformBufferRef<FSoftBodyShaderParams>::CreateUniformBufferImmediate(Params, UniformBuffer_SingleFrame);

    FBoneTransformData BoneData{};
    int32 BoneIndex = 0;
    for (const auto& Pair : VertexToBoneMap)
    {
        if (BoneIndex >= 256) break; // Shader limit
        BoneData.BoneMatrices[BoneIndex] = FMatrix44f(Mesh->GetBoneTransform(Pair.Value).ToMatrixWithScale());
        BoneIndex++;
    }
    BoneTransformsBuffer = TUniformBufferRef<FBoneTransformData>::CreateUniformBufferImmediate(BoneData, UniformBuffer_SingleFrame);
}

/**
 * @brief Runs the compute shader to update the simulation.
 * @param RHICmdList The immediate command list.
 * @details Transitions resources and dispatches the shader.
 */
void USoftBodyPhysicsComponent::DispatchComputeShader(FRHICommandListImmediate& RHICmdList)
{
    // Transition resources
    TArray<FRHITransitionInfo> Transitions;
    Transitions.Add(FRHITransitionInfo(SimPositionsBuffer, ERHIAccess::Unknown, ERHIAccess::UAVCompute));
    Transitions.Add(FRHITransitionInfo(SimVelocitiesBuffer, ERHIAccess::Unknown, ERHIAccess::UAVCompute));
    Transitions.Add(FRHITransitionInfo(SpringsBuffer, ERHIAccess::Unknown, ERHIAccess::SRVCompute));
    Transitions.Add(FRHITransitionInfo(BoneOffsetsBuffer, ERHIAccess::Unknown, ERHIAccess::SRVCompute));
    Transitions.Add(FRHITransitionInfo(VertexOffsetsBuffer, ERHIAccess::Unknown, ERHIAccess::UAVCompute));
    RHICmdList.Transition(Transitions);

    // Dispatch shader
    FSoftBodyComputeShader().Dispatch(
        RHICmdList,
        SimPositionsBuffer, SimPositionsUAV,
        SimVelocitiesBuffer, SimVelocitiesUAV,
        SpringsBuffer, SpringsSRV,
        BoneOffsetsBuffer, BoneOffsetsSRV,
        VertexOffsetsBuffer, VertexOffsetsUAV,
        ShaderParamsBuffer,
        BoneTransformsBuffer,
        SimVertexCount
    );

    // Transition back for rendering
    RHICmdList.Transition(FRHITransitionInfo(VertexOffsetsBuffer, ERHIAccess::UAVCompute, ERHIAccess::VertexOrIndexBuffer));
}

/**
 * @brief Gets a vertex’s simulated position.
 * @param VertexIndex Index in simulation array.
 * @return Position, or zero if invalid.
 */
FVector USoftBodyPhysicsComponent::GetSimulatedVertexPosition(int32 VertexIndex) const
{
    return SimPositions.IsValidIndex(VertexIndex) ? SimPositions[VertexIndex] : FVector::ZeroVector;
}/*
* FileName = SoftBodyComputeShader.h
* FilePath = SoftBodyDemo/Plugins/SoftBodyPhysics/Source/SoftBodyPhysics/Public
*/

#pragma once

#include "CoreMinimal.h"
#include "GlobalShader.h" // For FGlobalShader and shader type macros
#include "UniformBuffer.h" // For TUniformBufferRef
#include "ShaderParameterUtils.h" // For parameter binding utilities
#include "SoftBodyPhysicsTypes.h" // Custom types for soft body simulation

// Ensure this header is included only once to prevent redefinition errors
#ifndef SOFTBODYCOMPUTESHADER_H
#define SOFTBODYCOMPUTESHADER_H

/**
 * @class FSoftBodyComputeShader
 * @brief A global compute shader for GPU-based soft body physics simulation in Unreal Engine 5.5.3.
 * @details Simulates vertex positions and velocities using a mass-spring system with bone influences.
 *          Designed for maximum compatibility with UE 5.5.3’s RHI and shader pipeline.
 */
class FSoftBodyComputeShader : public FGlobalShader
{
    DECLARE_GLOBAL_SHADER(FSoftBodyComputeShader); // Declares shader type boilerplate

public:
    /** @brief Default constructor required by Unreal's shader system. */
    FSoftBodyComputeShader() = default;

    /**
     * @brief Constructs the shader with compiled initializer data.
     * @param Initializer Shader initializer containing parameter map from SoftBodyPhysics.usf.
     * @details Binds UAVs, SRVs, and uniform buffers to shader parameters for simulation.
     */
    FSoftBodyComputeShader(const ShaderMetaType::CompiledShaderInitializerType& Initializer)
        : FGlobalShader(Initializer)
    {
        // Bind UAV parameters for simulation outputs
        SimPositionsParam.Bind(Initializer.ParameterMap, TEXT("SimPositions"));
        SimVelocitiesParam.Bind(Initializer.ParameterMap, TEXT("SimVelocities"));
        VertexOffsetsParam.Bind(Initializer.ParameterMap, TEXT("VertexOffsets"));

        // Bind SRV parameters for input buffers
        SpringsParam.Bind(Initializer.ParameterMap, TEXT("Springs"));
        BoneOffsetsParam.Bind(Initializer.ParameterMap, TEXT("BoneOffsets"));

        // Bind uniform buffer parameters for constants
        ShaderParamsParam.Bind(Initializer.ParameterMap, TEXT("SoftBodyConstants"));
        BoneTransformsParam.Bind(Initializer.ParameterMap, TEXT("BoneTransforms"));
    }

    /**
     * @brief Checks if this shader should compile for a given platform and permutation.
     * @param Parameters Permutation parameters including platform and flags.
     * @return True if SM5 is supported, ensuring compatibility with DirectX 11+ or equivalent.
     */
    static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
    {
        return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5);
    }

    /**
     * @brief Configures the shader compilation environment.
     * @param Parameters Permutation parameters.
     * @param OutEnvironment Environment to modify with defines.
     * @note Defines THREADGROUPSIZE_X as 64, matching the .usf file’s thread group size.
     */
    static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
    {
        FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment);
        OutEnvironment.SetDefine(TEXT("THREADGROUPSIZE_X"), 64);
    }

    /**
     * @brief Dispatches the compute shader to simulate soft body physics.
     * @param RHICmdList Immediate command list for GPU execution.
     * @param SimPositions Buffer for simulated vertex positions.
     * @param SimPositionsUAV UAV for writing positions.
     * @param SimVelocities Buffer for vertex velocities.
     * @param SimVelocitiesUAV UAV for writing velocities.
     * @param Springs Buffer with spring connections.
     * @param SpringsSRV SRV for reading springs.
     * @param BoneOffsets Buffer with bone offset data.
     * @param BoneOffsetsSRV SRV for reading offsets.
     * @param VertexOffsets Buffer for mesh vertex offsets.
     * @param VertexOffsetsUAV UAV for writing offsets.
     * @param ShaderParams Uniform buffer with simulation parameters.
     * @param BoneTransforms Uniform buffer with bone matrices.
     * @param NumThreadsX Number of vertices to simulate.
     * @note Executes the shader with 64 threads per group in X dimension.
     */
    void Dispatch(
        FRHICommandListImmediate& RHICmdList,
        FRHIBuffer* SimPositions, FRHIUnorderedAccessView* SimPositionsUAV,
        FRHIBuffer* SimVelocities, FRHIUnorderedAccessView* SimVelocitiesUAV,
        FRHIBuffer* Springs, FRHIShaderResourceView* SpringsSRV,
        FRHIBuffer* BoneOffsets, FRHIShaderResourceView* BoneOffsetsSRV,
        FRHIBuffer* VertexOffsets, FRHIUnorderedAccessView* VertexOffsetsUAV,
        TUniformBufferRef<FSoftBodyShaderParams> ShaderParams,
        TUniformBufferRef<FBoneTransformData> BoneTransforms,
        uint32 NumThreadsX
    );

private:
    // UAV and SRV parameters use FShaderResourceParameter for UE 5.5.3 compatibility
    FShaderResourceParameter SimPositionsParam;   ///< UAV binding for simulated positions
    FShaderResourceParameter SimVelocitiesParam;  ///< UAV binding for simulated velocities
    FShaderResourceParameter VertexOffsetsParam;  ///< UAV binding for vertex offsets
    FShaderResourceParameter SpringsParam;        ///< SRV binding for spring connections
    FShaderResourceParameter BoneOffsetsParam;    ///< SRV binding for bone offsets

    // Uniform buffer parameters remain FShaderUniformBufferParameter
    FShaderUniformBufferParameter ShaderParamsParam;   ///< Uniform buffer for simulation constants
    FShaderUniformBufferParameter BoneTransformsParam; ///< Uniform buffer for bone transforms
};

#endif // SOFTBODYCOMPUTESHADER_H/* <NEW_LINE> */
/*
* FileName = SoftBodyPhysics.h
* FilePath = <UnrealProjectName>/Plugins/<PluginName>/Source/<PluginName>/Public
*/

#pragma once

#include "Modules/ModuleManager.h"

// Declare the log category for the entire plugin here (single definition)
DECLARE_LOG_CATEGORY_EXTERN(LogSoftBodyPhysics, Log, All);

/**
 * @class FSoftBodyPhysicsModule
 * @brief Module for the SoftBodyPhysics plugin.
 * @details Manages plugin lifecycle. Shader integration uses material system for UE 5.5.3 compatibility.
 */
class FSoftBodyPhysicsModule : public IModuleInterface
{
public:
    /** @brief Called when the module is loaded into memory. */
    virtual void StartupModule() override;

    /** @brief Called when the module is unloaded from memory. */
    virtual void ShutdownModule() override;
};

class USoftBodyPhysicsComponent; // Forward declaration/* <NEW_LINE> */
/*
* FileName = <FileName>
* FilePath = <UnrealProjectName>/Plugins/<PluginName>/Source/<PluginName>/Public
*/

#pragma once
#include "CoreMinimal.h"
#include "Components/ActorComponent.h"
#include "RHI.h"
#include "RHICommandList.h"
#include "UniformBuffer.h"
#include "SoftBodyPhysicsTypes.h"
#include "SoftBodyPhysicsComponent.generated.h"

DECLARE_LOG_CATEGORY_EXTERN(LogSoftBodyPhysics, Log, All);

UCLASS(ClassGroup = (Custom), meta = (BlueprintSpawnableComponent))
class SOFTBODYPHYSICS_API USoftBodyPhysicsComponent : public UActorComponent
{
    GENERATED_BODY()

public:
    USoftBodyPhysicsComponent();

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "SoftBodyPhysics", Meta = (ClampMin = "50", ClampMax = "500"))
    int32 SimVertexCount;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "SoftBodyPhysics", Meta = (ClampMin = "0.1"))
    float Stiffness;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "SoftBodyPhysics", Meta = (ClampMin = "0.0"))
    float Damping;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "SoftBodyPhysics", Meta = (ClampMin = "0.0", ClampMax = "1.0"))
    float MuscleStrength;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "SoftBodyPhysics", Meta = (ClampMin = "0.0"))
    float MaxVelocity;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "SoftBodyPhysics|Debug")
    bool bEnableDetailedLogging;

    UFUNCTION(BlueprintCallable, Category = "SoftBodyPhysics")
    void InitializeSoftBody(USkeletalMeshComponent* TargetMesh);

    UFUNCTION(BlueprintCallable, Category = "SoftBodyPhysics|Debug")
    FVector GetSimulatedVertexPosition(int32 VertexIndex) const;

protected:
    virtual void BeginPlay() override;
    virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

private:
    FRHIBuffer* SimPositionsBuffer;
    TRefCountPtr<FRHIUnorderedAccessView> SimPositionsUAV;
    FRHIBuffer* SimVelocitiesBuffer;
    TRefCountPtr<FRHIUnorderedAccessView> SimVelocitiesUAV;
    FRHIBuffer* SpringsBuffer;
    TRefCountPtr<FRHIShaderResourceView> SpringsSRV;
    FRHIBuffer* BoneOffsetsBuffer;
    TRefCountPtr<FRHIShaderResourceView> BoneOffsetsSRV;
    FRHIBuffer* VertexOffsetsBuffer;
    TRefCountPtr<FRHIUnorderedAccessView> VertexOffsetsUAV;

    TArray<FVector> SimPositions;
    TArray<FVector> SimVelocities;
    TArray<int32> SimVertexIndices;
    TArray<TArray<int32>> Springs;
    TArray<FVector> VertexOffsets;
    TMap<int32, int32> VertexToBoneMap;
    TMap<int32, FVector> BoneOffsets;

    TUniformBufferRef<FSoftBodyShaderParams> ShaderParamsBuffer;
    TUniformBufferRef<FBoneTransformData> BoneTransformsBuffer;

    void SetupRHIBuffers(USkeletalMeshComponent* TargetMesh);
    void UpdateShaderParams(USkeletalMeshComponent* Mesh, float DeltaTime);
    void DispatchComputeShader(FRHICommandListImmediate& RHICmdList);
};/* <NEW_LINE> */
/*
* FileName = <FileName>
* FilePath = <UnrealProjectName>/Plugins/<PluginName>/Source/<PluginName>/Public
*/

#pragma once
#include "CoreMinimal.h"

struct FSoftBodyShaderParams
{
    float Stiffness;
    float Damping;
    float MuscleStrength;
    float MaxVelocity;
    float DeltaTime;
    int32 SimVertexCount;
    int32 TotalVertexCount;
    int32 Padding; // 16-byte alignment
};

struct FBoneTransformData
{
    FMatrix44f BoneMatrices[256];
};// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	GlobalShader.h: Shader manager definitions.
=============================================================================*/

#pragma once

#include "Containers/Array.h"
#include "Containers/Map.h"
#include "Containers/UnrealString.h"
#include "CoreMinimal.h"
#include "HAL/Platform.h"
#include "Misc/AssertionMacros.h"
#include "Misc/Paths.h"
#include "RHI.h"
#include "RHIDefinitions.h"
#include "RHIResources.h"
#include "Serialization/MemoryImage.h"
#include "Serialization/MemoryLayout.h"
#include "Shader.h"
#include "ShaderParameterUtils.h"
#include "Templates/Tuple.h"
#include "Templates/UniquePtr.h"
#include "UObject/NameTypes.h"
#include "UObject/UnrealNames.h"

class FArchive;
class FShaderCommonCompileJob;
class FShaderCompileJob;
class FShaderParametersMetadata;
class FShaderUniformBufferParameter;
class FVertexFactoryType;
class ITargetPlatform;
struct FShaderCompilerEnvironment;
#if WITH_EDITOR
struct FShaderCacheLoadContext;
#endif

/** Used to identify the global shader map in compile queues. */
extern RENDERCORE_API const int32 GlobalShaderMapId;

/** Class that encapsulates logic to create a DDC key for the global shader map. */
class FGlobalShaderMapId
{
public:

	/** Create a global shader map Id for the given platform. */
	RENDERCORE_API FGlobalShaderMapId(EShaderPlatform Platform, const ITargetPlatform* TargetPlatform);

	/** Append to a string that will be used as a DDC key. */
	RENDERCORE_API void AppendKeyString(FString& KeyString, const TArray<FShaderTypeDependency>& Dependencies) const;

	const TMap<FString, TArray<FShaderTypeDependency>>& GetShaderFilenameToDependeciesMap() const { return ShaderFilenameToDependenciesMap; }

	RENDERCORE_API bool WithEditorOnly() const;

	inline EShaderPermutationFlags GetShaderPermutationFlags() const { return ::GetShaderPermutationFlags(LayoutParams); }

private:
	FPlatformTypeLayoutParameters LayoutParams;
	EShaderPlatform ShaderPlatform;
	FName IniPlatformName;

	/** Shader types that this shader map is dependent on and their stored state. Mapped by shader filename, so every filename can have it's own DDC key. */
	TMap<FString, TArray<FShaderTypeDependency>> ShaderFilenameToDependenciesMap;

	/** Shader pipeline types that this shader map is dependent on and their stored state. */
	TArray<FShaderPipelineTypeDependency> ShaderPipelineTypeDependencies;
};

struct FGlobalShaderPermutationParameters : public FShaderPermutationParameters
{
	const FName GlobalShaderName;

	FGlobalShaderPermutationParameters(FName InGlobalShaderName, EShaderPlatform InShaderPlatform, int32 InPermutationId = 0, EShaderPermutationFlags InFlags = EShaderPermutationFlags::HasEditorOnlyData)
		: FShaderPermutationParameters(InShaderPlatform, InPermutationId, InFlags)
		, GlobalShaderName(InGlobalShaderName)
	{}
};

/**
 * A shader meta type for the simplest shaders; shaders which are not material or vertex factory linked.
 * There should only a single instance of each simple shader type.
 */
class FGlobalShaderType : public FShaderType
{
	friend class FGlobalShaderTypeCompiler;
public:

	typedef FShader::CompiledShaderInitializerType CompiledShaderInitializerType;

	FGlobalShaderType(
		FTypeLayoutDesc& InTypeLayout,
		const TCHAR* InName,
		const TCHAR* InSourceFilename,
		const TCHAR* InFunctionName,
		uint32 InFrequency,
		int32 InTotalPermutationCount,
		ConstructSerializedType InConstructSerializedRef,
		ConstructCompiledType InConstructCompiledRef,
		ShouldCompilePermutationType InShouldCompilePermutationRef,
		ShouldPrecachePermutationType InShouldPrecachePermutationRef,
		GetRayTracingPayloadTypeType InGetRayTracingPayloadTypeRef,
		GetShaderBindingLayoutType InGetShaderBindingLayoutTypeRef,
#if WITH_EDITOR
		ModifyCompilationEnvironmentType InModifyCompilationEnvironmentRef,
		ValidateCompiledResultType InValidateCompiledResultRef,
#endif // WITH_EDITOR
		uint32 InTypeSize,
		const FShaderParametersMetadata* InRootParametersMetadata = nullptr
		):
		FShaderType(EShaderTypeForDynamicCast::Global, InTypeLayout, InName, InSourceFilename, InFunctionName, InFrequency, InTotalPermutationCount,
			InConstructSerializedRef,
			InConstructCompiledRef,
			InShouldCompilePermutationRef,
			InShouldPrecachePermutationRef,
			InGetRayTracingPayloadTypeRef,
			InGetShaderBindingLayoutTypeRef,
#if WITH_EDITOR
			InModifyCompilationEnvironmentRef,
			InValidateCompiledResultRef,
#endif // WITH_EDITOR
			InTypeSize,
			InRootParametersMetadata
		)
	{
		checkf(FPaths::GetExtension(InSourceFilename) == TEXT("usf"),
			TEXT("Incorrect virtual shader path extension for global shader '%s': Only .usf files should be "
			     "compiled."),
			InSourceFilename);
	}

	/**
	 * Checks if the shader type should be cached for a particular platform.
	 * @param Platform - The platform to check.
	 * @return True if this shader type should be cached.
	 */
	bool ShouldCompilePermutation(EShaderPlatform Platform, int32 PermutationId, EShaderPermutationFlags Flags) const
	{
		return FShaderType::ShouldCompilePermutation(FGlobalShaderPermutationParameters(GetFName(), Platform, PermutationId, Flags));
	}

	EShaderPermutationPrecacheRequest ShouldPrecachePermutation(EShaderPlatform Platform, int32 PermutationId, EShaderPermutationFlags Flags) const
	{
		return FShaderType::ShouldPrecachePermutation(FGlobalShaderPermutationParameters(GetFName(), Platform, PermutationId, Flags));
	}

#if WITH_EDITOR
	/**
	 * Sets up the environment used to compile an instance of this shader type.
	 * @param Platform - Platform to compile for.
	 * @param Environment - The shader compile environment that the function modifies.
	 */
	RENDERCORE_API void SetupCompileEnvironment(EShaderPlatform Platform, int32 PermutationId, EShaderPermutationFlags Flags, FShaderCompilerEnvironment& Environment) const;
#endif // WITH_EDITOR

	RENDERCORE_API static bool ShouldCompilePipeline(const FShaderPipelineType* ShaderPipelineType, EShaderPlatform Platform, EShaderPermutationFlags Flags);
};

class FGlobalShaderMapContent : public FShaderMapContent
{
	using Super = FShaderMapContent;
	friend class FGlobalShaderMap;
	friend class FGlobalShaderMapSection;
	DECLARE_TYPE_LAYOUT(FGlobalShaderMapContent, NonVirtual);
public:
	const FHashedName& GetHashedSourceFilename() const { return HashedSourceFilename; }

private:
	inline FGlobalShaderMapContent(EShaderPlatform InPlatform, const FHashedName& InHashedSourceFilename)
		: Super(InPlatform)
		, HashedSourceFilename(InHashedSourceFilename)
	{}

	LAYOUT_FIELD(FHashedName, HashedSourceFilename);
};

class FGlobalShaderMapSection : public TShaderMap<FGlobalShaderMapContent, FShaderMapPointerTable>
{
	using Super = TShaderMap<FGlobalShaderMapContent, FShaderMapPointerTable>;
	friend class FGlobalShaderMap;
public:
	RENDERCORE_API static FGlobalShaderMapSection* CreateFromArchive(FArchive& Ar);

#if WITH_EDITOR
	RENDERCORE_API static FGlobalShaderMapSection* CreateFromCache(FShaderCacheLoadContext& Ctx);
#endif

	UE_DEPRECATED(5.5, "Use overload accepting a FShaderSerializeContext instead")
	RENDERCORE_API bool Serialize(FArchive& Ar)
	{
		return false;
	}

	RENDERCORE_API bool Serialize(FShaderSerializeContext& Ctx);
	RENDERCORE_API virtual void GetShaderList(TMap<FHashedName, TShaderRef<FShader>>& OutShaders) const override;
	RENDERCORE_API virtual void GetShaderPipelineList(TArray<FShaderPipelineRef>& OutShaderPipelines) const override;
private:
	inline FGlobalShaderMapSection() 
	{ 
#if WITH_EDITOR
		// associate with a non-empty asset name as to not have an exception in the library
		FShaderMapBase::AssociateWithAsset(NAME_None);
#endif
	}

	inline FGlobalShaderMapSection(EShaderPlatform InPlatform, const FHashedName& InHashedSourceFilename)
	{
		AssignContent(new FGlobalShaderMapContent(InPlatform, InHashedSourceFilename));
	}

	TShaderRef<FShader> GetShader(FShaderType* ShaderType, int32 PermutationId = 0) const;
	FShaderPipelineRef GetShaderPipeline(const FShaderPipelineType* PipelineType) const;
};

class FGlobalShaderMap
{
public:
	RENDERCORE_API explicit FGlobalShaderMap(EShaderPlatform InPlatform);
	RENDERCORE_API ~FGlobalShaderMap();

	RENDERCORE_API TShaderRef<FShader> GetShader(FShaderType* ShaderType, int32 PermutationId = 0) const;
	RENDERCORE_API FShaderPipelineRef GetShaderPipeline(const FShaderPipelineType* PipelineType) const;

	template<typename ShaderType>
	TShaderRef<ShaderType> GetShader() const
	{
		ensureMsgf(ShaderType::GetStaticType().GetPermutationCount() == 1, TEXT("Failed to provide PermutationId for shader type %s with %u permutations"), ShaderType::GetStaticType().GetName(), ShaderType::GetStaticType().GetPermutationCount());
		return GetShader<ShaderType>(0);
	}

	template<typename ShaderType>
	TShaderRef<ShaderType> GetShader(int32 PermutationId) const
	{
		TShaderRef<FShader> Shader = GetShader(&ShaderType::GetStaticType(), PermutationId);
		checkf(Shader.IsValid(), TEXT("Failed to find shader type %s in Platform %s"), ShaderType::GetStaticType().GetName(), *LegacyShaderPlatformToShaderFormat(Platform).ToString());

		// Validate that the permutation has been precached
		ensureMsgf(ShaderType::ShouldPrecachePermutation(FGlobalShaderPermutationParameters(ShaderType::GetStaticType().GetFName(), Platform, PermutationId)) != EShaderPermutationPrecacheRequest::NotUsed,
			TEXT("Using a global shader permutation of %s which hasn't been requested for precaching at runtime. Check the implementation of ShouldPrecachePermutation on the global shader and make sure all required or development only permutations are requested for PSO precaching"), ShaderType::GetStaticType().GetName());

		return TShaderRef<ShaderType>::Cast(Shader);
	}

	/** Finds the shader with the given type.  Asserts on failure. */
	template<typename ShaderType>
	TShaderRef<ShaderType> GetShader(const typename ShaderType::FPermutationDomain& PermutationVector) const
	{
		return GetShader<ShaderType>(PermutationVector.ToDimensionValueId());
	}

	bool HasShader(FShaderType* Type, int32 PermutationId) const
	{
		return GetShader(Type, PermutationId).IsValid();
	}

	bool HasShaderPipeline(const FShaderPipelineType* ShaderPipelineType) const
	{
		return GetShaderPipeline(ShaderPipelineType).IsValid();
	}

	RENDERCORE_API bool IsEmpty() const;

	/** Whether the shadermap has all the shader types it needs (i.e. ones that returned ShouldCompilePermutation) */
	RENDERCORE_API bool IsComplete(const ITargetPlatform* TargetPlatform) const;

	RENDERCORE_API void Empty();
	RENDERCORE_API void ReleaseAllSections();

	RENDERCORE_API FShader* FindOrAddShader(const FShaderType* ShaderType, int32 PermutationId, FShader* Shader);
	RENDERCORE_API FShaderPipeline* FindOrAddShaderPipeline(const FShaderPipelineType* ShaderPipelineType, FShaderPipeline* ShaderPipeline);

	RENDERCORE_API void RemoveShaderTypePermutaion(const FShaderType* Type, int32 PermutationId);
	RENDERCORE_API void RemoveShaderPipelineType(const FShaderPipelineType* ShaderPipelineType);

	RENDERCORE_API void AddSection(FGlobalShaderMapSection* InSection);
	RENDERCORE_API FGlobalShaderMapSection* FindSection(const FHashedName& HashedShaderFilename);
	RENDERCORE_API FGlobalShaderMapSection* FindOrAddSection(const FShaderType* ShaderType);
	
	RENDERCORE_API void LoadFromGlobalArchive(FArchive& Ar);
	RENDERCORE_API void SaveToGlobalArchive(FArchive& Ar);

	RENDERCORE_API void BeginCreateAllShaders();

#if WITH_EDITOR
	RENDERCORE_API void GetOutdatedTypes(TArray<const FShaderType*>& OutdatedShaderTypes, TArray<const FShaderPipelineType*>& OutdatedShaderPipelineTypes, TArray<const FVertexFactoryType*>& OutdatedFactoryTypes) const;
	RENDERCORE_API void SaveShaderStableKeys(EShaderPlatform TargetShaderPlatform);
#endif // WITH_EDITOR

	const FGlobalShaderMapSection* GetFirstSection()
	{
		if (const auto It = SectionMap.CreateConstIterator())
		{
			return It.Value();
		}
		return nullptr;
	}

private:
	TMap<FHashedName, FGlobalShaderMapSection*> SectionMap;
	EShaderPlatform Platform;
};

extern RENDERCORE_API FGlobalShaderMap* GGlobalShaderMap[SP_NumPlatforms];


/**
 * FGlobalShader
 * 
 * Global shaders derive from this class to set their default recompile group as a global one
 */
class FGlobalShader : public FShader
{
	DECLARE_EXPORTED_TYPE_LAYOUT(FGlobalShader, RENDERCORE_API, NonVirtual);
public:
	using ShaderMetaType = FGlobalShaderType;
	using FPermutationParameters = FGlobalShaderPermutationParameters;

	FGlobalShader() = default;

	RENDERCORE_API FGlobalShader(const ShaderMetaType::CompiledShaderInitializerType& Initializer);
	
	template<typename TViewUniformShaderParameters>
	inline void SetParameters(FRHIBatchedShaderParameters& BatchedParameters, FRHIUniformBuffer* ViewUniformBuffer)
	{
		const auto& ViewUniformBufferParameter = static_cast<const FShaderUniformBufferParameter&>(GetUniformBufferParameter<TViewUniformShaderParameters>());
		SetUniformBufferParameter(BatchedParameters, ViewUniformBufferParameter, ViewUniformBuffer);
	}

	using FShader::ShouldCompilePermutation;
	using FShader::ShouldPrecachePermutation;
	
	static inline void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& Environment) { };
};

/**
 * An internal dummy pixel shader to use when the user calls RHISetPixelShader(NULL).
 */
class FNULLPS : public FGlobalShader
{
	DECLARE_EXPORTED_SHADER_TYPE(FNULLPS,Global, RENDERCORE_API);
public:

	static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters& Parameters)
	{
		return true;
	}

	FNULLPS( )	{ }
	FNULLPS(const ShaderMetaType::CompiledShaderInitializerType& Initializer):
		FGlobalShader(Initializer)
	{
	}
};

/**
 * Accesses the global shader map.  This is a global FGlobalShaderMap which contains an instance of each global shader type.
 *
 * @param Platform Which platform's global shader map to use
 * @param bRefreshShaderMap If true, the existing global shader map will be tossed first
 * @return A reference to the global shader map.
 */
extern RENDERCORE_API FGlobalShaderMap* GetGlobalShaderMap(EShaderPlatform Platform);

/**
  * Overload for the above GetGlobalShaderMap which takes a feature level and translates to the appropriate shader platform
  *
  * @param FeatureLevel - Which feature levels shader map to use
  * @param bRefreshShaderMap If true, the existing global shader map will be tossed first
  * @return A reference to the global shader map.
  *
  **/
inline FGlobalShaderMap* GetGlobalShaderMap(ERHIFeatureLevel::Type FeatureLevel)
{ 
	return GetGlobalShaderMap(GShaderPlatformForFeatureLevel[FeatureLevel]); 
}


/** DECLARE_GLOBAL_SHADER and IMPLEMENT_GLOBAL_SHADER setup a global shader class's boiler plate. They are meant to be used like so:
 *
 * class FMyGlobalShaderPS : public FGlobalShader
 * {
 *		// Setup the shader's boiler plate.
 *		DECLARE_GLOBAL_SHADER(FMyGlobalShaderPS);
 *
 *		// Setup the shader's permutation domain. If no dimensions, can do FPermutationDomain = FShaderPermutationNone.
 *		using FPermutationDomain = TShaderPermutationDomain<DIMENSIONS...>;
 *
 *		// ...
 * };
 *
 * // Instantiates global shader's global variable that will take care of compilation process of the shader. This needs imperatively to be
 * done in a .cpp file regardless of whether FMyGlobalShaderPS is in a header or not.
 * IMPLEMENT_GLOBAL_SHADER(FMyGlobalShaderPS, "/Engine/Private/MyShaderFile.usf", "MainPS", SF_Pixel);
 *
 * When the shader class is a public header, let say in RenderCore module public header, the class declaration macro then should have the RENDERCORE_API
 * like this:
 *
 * class FMyGlobalShaderPS : public FGlobalShader
 * {
 *		// Setup the shader's boiler plate.
 *		DECLARE_EXPORTED_GLOBAL_SHADER(FMyGlobalShaderPS, RENDERCORE_API);
 *
 *		// ...
 * };
 */
/*#define DECLARE_GLOBAL_SHADER(ShaderClass) \
	public: \
	\
	using ShaderMetaType = FGlobalShaderType; \
	\
	using ShaderMapType = FGlobalShaderMap; \
	\
	static ShaderMetaType StaticType; \
	\
	static FShader* ConstructSerializedInstance() { return new ShaderClass(); } \
	static FShader* ConstructCompiledInstance(const ShaderMetaType::CompiledShaderInitializerType& Initializer) \
	{ return new ShaderClass(Initializer); } \
	\
	static void ModifyCompilationEnvironmentImpl( \
		const FShaderPermutationParameters& Parameters, \
		FShaderCompilerEnvironment& OutEnvironment) \
	{ \
		FPermutationDomain PermutationVector(Parameters.PermutationId); \
		PermutationVector.ModifyCompilationEnvironment(OutEnvironment); \
		ShaderClass::ModifyCompilationEnvironment(Parameters, OutEnvironment); \
	}

#define IMPLEMENT_GLOBAL_SHADER(ShaderClass,SourceFilename,FunctionName,Frequency) \
	ShaderClass::ShaderMetaType ShaderClass::StaticType( \
		TEXT(#ShaderClass), \
		TEXT(SourceFilename), \
		TEXT(FunctionName), \
		Frequency, \
		ShaderClass::FPermutationDomain::PermutationCount, \
		ShaderClass::ConstructSerializedInstance, \
		ShaderClass::ConstructCompiledInstance, \
		ShaderClass::ConstructEditorContent, \
		ShaderClass::DestroyInstance, \
		ShaderClass::DestroyEditorContent, \
		ShaderClass::ModifyCompilationEnvironmentImpl, \
		ShaderClass::ShouldCompilePermutation, \
		ShaderClass::ValidateCompiledResult, \
		ShaderClass::FreezeMemoryImageImpl, \
		ShaderClass::FreezeMemoryImageEditorImpl, \
		sizeof(ShaderClass), \
		sizeof(ShaderClass::FEditorContent), \
		ShaderClass::GetRootParametersMetadata() \
		)
		*/

#define DECLARE_GLOBAL_SHADER(ShaderClass) DECLARE_SHADER_TYPE(ShaderClass, Global)
#define DECLARE_EXPORTED_GLOBAL_SHADER(ShaderClass, RequiredAPI) DECLARE_EXPORTED_SHADER_TYPE(ShaderClass, Global, RequiredAPI)
#define IMPLEMENT_GLOBAL_SHADER(ShaderClass,SourceFilename,FunctionName,Frequency) IMPLEMENT_SHADER_TYPE(,ShaderClass,TEXT(SourceFilename),TEXT(FunctionName),Frequency)

/**
* Groups of global shaders which can be used in recursive
* RHI command lists by platform RHI implementations.
*/
enum class ERecursiveShader
{
	None = 0,

	// Shaders used for resolving MSAA textures (defined in ResolveShader.h)
	Resolve = 1 << 0,

	// Shaders used for clearing textures and buffers (defined in ClearReplacementShaders.h)
	Clear = 1 << 1,

	// A null pixel shader (defined above)
	Null = 1 << 2
};
ENUM_CLASS_FLAGS(ERecursiveShader)

/*
* Set by the platform RHI implementations to indicate which groups of global shaders will be used recursively.
*/
extern RENDERCORE_API ERecursiveShader GRequiredRecursiveShaders;

/*
* Called on the render thread when the global shader map is available to force-init certain global shaders as specified by GRequiredRecursiveShaders.
*/
extern RENDERCORE_API void CreateRecursiveShaders();

void ForceInitGlobalShaderType(FShaderType& ShaderType);

template <typename TShaderType>
inline void ForceInitGlobalShaderType()
{
	ForceInitGlobalShaderType(TShaderType::GetStaticType());
}
// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	RHICommandList.h: RHI Command List definitions for queueing up & executing later.
=============================================================================*/

#pragma once

#include "CoreTypes.h"
#include "Misc/AssertionMacros.h"
#include "HAL/UnrealMemory.h"
#include "Templates/UnrealTemplate.h"
#include "Math/Color.h"
#include "Math/IntPoint.h"
#include "Math/IntRect.h"
#include "Math/Box2D.h"
#include "Math/PerspectiveMatrix.h"
#include "Math/TranslationMatrix.h"
#include "Math/ScaleMatrix.h"
#include "Math/Float16Color.h"
#include "HAL/ThreadSafeCounter.h"
#include "GenericPlatform/GenericPlatformProcess.h"
#include "Misc/MemStack.h"
#include "Misc/App.h"
#include "RHIStats.h"
#include "HAL/IConsoleManager.h"
#include "Async/TaskGraphInterfaces.h"
#include "HAL/LowLevelMemTracker.h"
#include "ProfilingDebugging/CsvProfiler.h"
#include "ProfilingDebugging/CpuProfilerTrace.h"
#include "RHIBreadcrumbs.h"
#include "RHIGlobals.h"
#include "RHIShaderParameters.h"
#include "RHITextureReference.h"
#include "RHIResourceReplace.h"
#include "Trace/Trace.h"

#include "DynamicRHI.h"
#include "RHITypes.h"
#include "RHIGlobals.h"

CSV_DECLARE_CATEGORY_MODULE_EXTERN(RHI_API, RHITStalls);
CSV_DECLARE_CATEGORY_MODULE_EXTERN(RHI_API, RHITFlushes);

/** Get the best default resource state for the given texture creation flags */
extern RHI_API ERHIAccess RHIGetDefaultResourceState(ETextureCreateFlags InUsage, bool bInHasInitialData);

/** Get the best default resource state for the given buffer creation flags */
extern RHI_API ERHIAccess RHIGetDefaultResourceState(EBufferUsageFlags InUsage, bool bInHasInitialData);

// Set to 1 to capture the callstack for every RHI command. Cheap & memory efficient representation: Use the 
// value in FRHICommand::StackFrames to get the pointer to the code (ie paste on a disassembly window)
#define RHICOMMAND_CALLSTACK		0
#if RHICOMMAND_CALLSTACK
#include "HAL/PlatformStackwalk.h"
#endif

class FApp;
class FBlendStateInitializerRHI;
class FGraphicsPipelineStateInitializer;
class FLastRenderTimeContainer;
class FRHICommandListBase;
class FRHIComputeShader;
class IRHICommandContext;
class IRHIComputeContext;
struct FDepthStencilStateInitializerRHI;
struct FRasterizerStateInitializerRHI;
struct FRHIResourceCreateInfo;
struct FRHIResourceInfo;
struct FRHIUniformBufferLayout;
struct FSamplerStateInitializerRHI;
struct FTextureMemoryStats;
class FComputePipelineState;
class FGraphicsPipelineState;
class FRayTracingPipelineState;
class FWorkGraphPipelineState;

DECLARE_STATS_GROUP(TEXT("RHICmdList"), STATGROUP_RHICMDLIST, STATCAT_Advanced);

UE_TRACE_CHANNEL_EXTERN(RHICommandsChannel, RHI_API);

// set this one to get a stat for each RHI command 
#define RHI_STATS 0

#if RHI_STATS
DECLARE_STATS_GROUP(TEXT("RHICommands"),STATGROUP_RHI_COMMANDS, STATCAT_Advanced);
#define RHISTAT(Method)	DECLARE_SCOPE_CYCLE_COUNTER(TEXT(#Method), STAT_RHI##Method, STATGROUP_RHI_COMMANDS)
#else
#define RHISTAT(Method)
#endif

#if !defined(RHI_EXECUTE_API)
#define RHI_EXECUTE_API RHI_API
#endif

enum class ERHIThreadMode
{
	None,
	DedicatedThread,
	Tasks
};

// Global for handling the "r.RHIThread.Enable" command.
extern RHI_API TOptional<ERHIThreadMode> GPendingRHIThreadMode;

namespace ERenderThreadIdleTypes
{
	enum Type
	{
		WaitingForAllOtherSleep,
		WaitingForGPUQuery,
		WaitingForGPUPresent,
		Num
	};
}

/** Accumulates how many cycles the renderthread has been idle. */
extern RHI_API uint32 GRenderThreadIdle[ERenderThreadIdleTypes::Num];

/** Helper to mark scopes as idle time on the render or RHI threads. */
struct FRenderThreadIdleScope
{
	FThreadIdleStats::FScopeIdle RHIThreadIdleScope;

	const ERenderThreadIdleTypes::Type Type;
	const bool bCondition;
	const uint32 Start;

	FRenderThreadIdleScope(ERenderThreadIdleTypes::Type Type, bool bInCondition = true)
		: RHIThreadIdleScope(!(bInCondition && IsInRHIThread()))
		, Type(Type)
		, bCondition(bInCondition && IsInRenderingThread())
		, Start(bCondition ? FPlatformTime::Cycles() : 0)
	{}

	~FRenderThreadIdleScope()
	{
		if (bCondition)
		{
			GRenderThreadIdle[Type] += FPlatformTime::Cycles() - Start;
		}
	}
};

/** How many cycles the from sampling input to the frame being flipped. */
extern RHI_API uint64 GInputLatencyTime;

/*UE::Trace::FChannel& FORCEINLINE GetRHICommandsChannel() 
{

}*/

/**
* Whether the RHI commands are being run in a thread other than the render thread
*/
bool FORCEINLINE IsRunningRHIInSeparateThread()
{
	return GIsRunningRHIInSeparateThread_InternalUseOnly;
}

/**
* Whether the RHI commands are being run on a dedicated thread other than the render thread
*/
bool FORCEINLINE IsRunningRHIInDedicatedThread()
{
	return GIsRunningRHIInDedicatedThread_InternalUseOnly;
}

/**
* Whether the RHI commands are being run on a dedicated thread other than the render thread
*/
bool FORCEINLINE IsRunningRHIInTaskThread()
{
	return GIsRunningRHIInTaskThread_InternalUseOnly;
}

extern RHI_API TAutoConsoleVariable<int32> CVarRHICmdWidth;

struct FRHICopyTextureInfo
{
	FIntRect GetSourceRect() const
	{
		return FIntRect(SourcePosition.X, SourcePosition.Y, SourcePosition.X + Size.X, SourcePosition.Y + Size.Y);
	}

	FIntRect GetDestRect() const
	{
		return FIntRect(DestPosition.X, DestPosition.Y, DestPosition.X + Size.X, DestPosition.Y + Size.Y);
	}

	// Number of texels to copy. By default it will copy the whole resource if no size is specified.
	FIntVector Size = FIntVector::ZeroValue;

	// Position of the copy from the source texture/to destination texture
	FIntVector SourcePosition = FIntVector::ZeroValue;
	FIntVector DestPosition = FIntVector::ZeroValue;

	uint32 SourceSliceIndex = 0;
	uint32 DestSliceIndex = 0;
	uint32 NumSlices = 1;

	// Mips to copy and destination mips
	uint32 SourceMipIndex = 0;
	uint32 DestMipIndex = 0;
	uint32 NumMips = 1;
};

struct FRHIBufferRange
{
	class FRHIBuffer* Buffer{ nullptr };
	uint64 Offset{ 0 };
	uint64 Size{ 0 };
};

/** Struct to hold common data between begin/end updatetexture3d */
struct FUpdateTexture3DData
{
	FUpdateTexture3DData(FRHITexture* InTexture, uint32 InMipIndex, const struct FUpdateTextureRegion3D& InUpdateRegion, uint32 InSourceRowPitch, uint32 InSourceDepthPitch, uint8* InSourceData, uint32 InDataSizeBytes, uint32 InFrameNumber)
		: Texture(InTexture)
		, MipIndex(InMipIndex)
		, UpdateRegion(InUpdateRegion)
		, RowPitch(InSourceRowPitch)
		, DepthPitch(InSourceDepthPitch)
		, Data(InSourceData)
		, DataSizeBytes(InDataSizeBytes)
		, FrameNumber(InFrameNumber)
	{
	}

	FRHITexture* Texture;
	uint32 MipIndex;
	FUpdateTextureRegion3D UpdateRegion;
	uint32 RowPitch;
	uint32 DepthPitch;
	uint8* Data;
	uint32 DataSizeBytes;
	uint32 FrameNumber;
	uint8 PlatformData[64];

private:
	FUpdateTexture3DData();
};

struct FRayTracingShaderBindings
{
	FRHITexture* Textures[64] = {};
	FRHIShaderResourceView* SRVs[64] = {};
	FRHIUniformBuffer* UniformBuffers[16] = {};
	FRHISamplerState* Samplers[32] = {};
	FRHIUnorderedAccessView* UAVs[16] = {};

	TArray<FRHIShaderParameterResource> BindlessParameters;
};

struct FRayTracingLocalShaderBindings
{
	const FRHIRayTracingGeometry* Geometry = nullptr;
	uint32 SegmentIndex = 0;
	uint32 RecordIndex = 0;
	uint32 ShaderIndexInPipeline = 0;
	uint32 UserData = 0;
	uint16 NumUniformBuffers = 0;
	uint16 LooseParameterDataSize = 0;
	FRHIUniformBuffer** UniformBuffers = nullptr;
	uint8* LooseParameterData = nullptr;
	
	UE_DEPRECATED(5.5, "Provide Geometry and RecordIndex instead.")
	uint32 InstanceIndex = 0;

	UE_DEPRECATED(5.5, "Provide Geometry and RecordIndex instead.")
	uint32 ShaderSlot = 0;

	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	FRayTracingLocalShaderBindings() = default;
	FRayTracingLocalShaderBindings(const FRayTracingLocalShaderBindings&) = default;
	FRayTracingLocalShaderBindings& operator=(const FRayTracingLocalShaderBindings&) = default;
	FRayTracingLocalShaderBindings(FRayTracingLocalShaderBindings&&) = default;
	FRayTracingLocalShaderBindings& operator=(FRayTracingLocalShaderBindings&&) = default;
	~FRayTracingLocalShaderBindings() = default;
	PRAGMA_ENABLE_DEPRECATION_WARNINGS
};

enum class ERayTracingBindingType : uint8
{
	HitGroup,
	CallableShader,
	MissShader,
};

struct FLockTracker
{
	struct FLockParams
	{
		void* RHIBuffer;
		void* Buffer;
		uint32 BufferSize;
		uint32 Offset;
		EResourceLockMode LockMode;

		FORCEINLINE_DEBUGGABLE FLockParams(void* InRHIBuffer, void* InBuffer, uint32 InOffset, uint32 InBufferSize, EResourceLockMode InLockMode)
			: RHIBuffer(InRHIBuffer)
			, Buffer(InBuffer)
			, BufferSize(InBufferSize)
			, Offset(InOffset)
			, LockMode(InLockMode)
		{
		}
	};

	FCriticalSection CriticalSection;
	TArray<FLockParams, TInlineAllocator<16> > OutstandingLocks;
	uint32 TotalMemoryOutstanding;

	FLockTracker()
	{
		TotalMemoryOutstanding = 0;
	}

	FORCEINLINE_DEBUGGABLE void Lock(void* RHIBuffer, void* Buffer, uint32 Offset, uint32 SizeRHI, EResourceLockMode LockMode)
	{
		FScopeLock Lock(&CriticalSection);
#if DO_CHECK
		for (auto& Parms : OutstandingLocks)
		{
			check(Parms.RHIBuffer != RHIBuffer);
		}
#endif
		OutstandingLocks.Add(FLockParams(RHIBuffer, Buffer, Offset, SizeRHI, LockMode));
		TotalMemoryOutstanding += SizeRHI;
	}
	FORCEINLINE_DEBUGGABLE FLockParams Unlock(void* RHIBuffer)
	{
		FScopeLock Lock(&CriticalSection);
		for (int32 Index = 0; Index < OutstandingLocks.Num(); Index++)
		{
			if (OutstandingLocks[Index].RHIBuffer == RHIBuffer)
			{
				FLockParams Result = OutstandingLocks[Index];
				OutstandingLocks.RemoveAtSwap(Index, EAllowShrinking::No);
				return Result;
			}
		}
		check(!"Mismatched RHI buffer locks.");
		return FLockParams(nullptr, nullptr, 0, 0, RLM_WriteOnly);
	}
};

#ifdef CONTINUABLE_PSO_VERIFY
#define PSO_VERIFY ensure
#else
#define PSO_VERIFY	check
#endif

struct FRHICommandBase
{
	FRHICommandBase* Next = nullptr;
	virtual void ExecuteAndDestruct(FRHICommandListBase& CmdList) = 0;
};

template <typename RHICmdListType, typename LAMBDA>
struct TRHILambdaCommand final : public FRHICommandBase
{
	LAMBDA Lambda;
#if CPUPROFILERTRACE_ENABLED
	const TCHAR* Name;
#endif

	TRHILambdaCommand(LAMBDA&& InLambda, const TCHAR* InName)
		: Lambda(Forward<LAMBDA>(InLambda))
#if CPUPROFILERTRACE_ENABLED
		, Name(InName)
#endif
	{}

	void ExecuteAndDestruct(FRHICommandListBase& CmdList) override final
	{
		TRACE_CPUPROFILER_EVENT_SCOPE_TEXT_ON_CHANNEL(Name, RHICommandsChannel);
		Lambda(*static_cast<RHICmdListType*>(&CmdList));
		Lambda.~LAMBDA();
	}
};

template <typename RHICmdListType, typename LAMBDA>
struct TRHILambdaCommand_NoMarker final : public FRHICommandBase
{
	LAMBDA Lambda;

	TRHILambdaCommand_NoMarker(LAMBDA&& InLambda)
		: Lambda(Forward<LAMBDA>(InLambda))
	{}

	void ExecuteAndDestruct(FRHICommandListBase& CmdList) override final
	{
		Lambda(*static_cast<RHICmdListType*>(&CmdList));
		Lambda.~LAMBDA();
	}
};

class FRHIContextArray : public TRHIPipelineArray<IRHIComputeContext*>
{
	using Base = TRHIPipelineArray<IRHIComputeContext*>;
public:
	using Base::Base;
};

template <typename RHICmdListType, typename LAMBDA>
struct TRHILambdaCommandMultiPipe final : public FRHICommandBase
{
	LAMBDA Lambda;
#if CPUPROFILERTRACE_ENABLED
	const TCHAR* Name;
#endif
	ERHIPipeline Pipelines;

	TRHILambdaCommandMultiPipe(LAMBDA&& InLambda, const TCHAR* InName, ERHIPipeline InPipelines)
		: Lambda(Forward<LAMBDA>(InLambda))
#if CPUPROFILERTRACE_ENABLED
		, Name(InName)
#endif
		, Pipelines(InPipelines)
	{}

	inline void ExecuteAndDestruct(FRHICommandListBase& CmdList) override final;
};

// Using variadic macro because some types are fancy template<A,B> stuff, which gets broken off at the comma and interpreted as multiple arguments. 
#define ALLOC_COMMAND(...) new ( AllocCommand(sizeof(__VA_ARGS__), alignof(__VA_ARGS__)) ) __VA_ARGS__
#define ALLOC_COMMAND_CL(RHICmdList, ...) new ( (RHICmdList).AllocCommand(sizeof(__VA_ARGS__), alignof(__VA_ARGS__)) ) __VA_ARGS__

// This controls if the cmd list bypass can be toggled at runtime. It is quite expensive to have these branches in there.
#define CAN_TOGGLE_COMMAND_LIST_BYPASS (!UE_BUILD_SHIPPING && !UE_BUILD_TEST)

class FRHICommandListScopedPipelineGuard
{
	FRHICommandListBase& RHICmdList;
	bool bPipelineSet = false;

public:
	FRHICommandListScopedPipelineGuard(FRHICommandListBase& RHICmdList);
	~FRHICommandListScopedPipelineGuard();
};

class FRHICommandListBase
{
protected:
	FMemStackBase MemManager;

	RHI_API FRHICommandListBase(FRHIGPUMask InGPUMask, bool bInImmediate);

public:
	// Move only.
	FRHICommandListBase(FRHICommandListBase const&) = delete;
	FRHICommandListBase(FRHICommandListBase&& Other) = default;

	RHI_API ~FRHICommandListBase();

	inline bool IsImmediate() const;
	inline FRHICommandListImmediate& GetAsImmediate();
	const int32 GetUsedMemory() const;

	bool AllowParallelTranslate() const
	{
		// Command lists cannot be translated in parallel for various reasons...

		// Parallel translate might be explicitly disabled (e.g. platform RHI doesn't support parallel translate)
		if (!bAllowParallelTranslate)
		{
			return false;
		}

		// All commands recorded by the immediate command list must not be parallel translated.
		// This is mostly for legacy reasons, since various parts of the renderer / RHI expect immediate commands to be single-threaded.
		if (PersistentState.bImmediate)
		{
			return false;
		}

		// Command lists that use RHIThreadFence(true) are going to mutate resource state, so must be single-threaded.
		if (bUsesLockFence)
		{
			return false;
		}

		// SetTrackedAccess mutates the FRHIViewableResource::TrackedAccess member.
		if (bUsesSetTrackedAccess)
		{
			return false;
		}

		// Some shader bundle implementations do not currently support parallel translate
		if (bUsesShaderBundles && !GRHISupportsShaderBundleParallel)
		{
			return false;
		}

		return true;
	}

	//
	// Adds a graph event as a dispatch dependency. The command list will not be dispatched to the
	// RHI / parallel translate threads until all its dispatch prerequisites have been completed.
	// 
	// Not safe to call after FinishRecording().
	//
	RHI_API void AddDispatchPrerequisite(const FGraphEventRef& Prereq);

	//
	// Marks the RHI command list as completed, allowing it to be dispatched to the RHI / parallel translate threads.
	// 
	// Must be called as the last command in a parallel rendering task. It is not safe to continue using the command 
	// list after FinishRecording() has been called.
	// 
	// Never call on the immediate command list.
	//
	RHI_API void FinishRecording();

	UE_DEPRECATED(5.5, "SetCurrentStat is deprecated and there is no replacement. Consider marking up rendering code with RDG event scopes or RHI breadcrumbs.")
	inline void SetCurrentStat(TStatId Stat) {}

	FORCEINLINE_DEBUGGABLE void* Alloc(int64 AllocSize, int64 Alignment)
	{
		return MemManager.Alloc(AllocSize, Alignment);
	}

	FORCEINLINE_DEBUGGABLE void* AllocCopy(const void* InSourceData, int64 AllocSize, int64 Alignment)
	{
		void* NewData = Alloc(AllocSize, Alignment);
		FMemory::Memcpy(NewData, InSourceData, AllocSize);
		return NewData;
	}

	template <typename T>
	FORCEINLINE_DEBUGGABLE T* Alloc()
	{
		return (T*)Alloc(sizeof(T), alignof(T));
	}

	template <typename T>
	FORCEINLINE_DEBUGGABLE const TArrayView<T> AllocArrayUninitialized(uint32 Num)
	{
		return TArrayView<T>((T*)Alloc(Num * sizeof(T), alignof(T)), Num);
	}

	template <typename T>
	FORCEINLINE_DEBUGGABLE const TArrayView<T> AllocArray(TConstArrayView<T> InArray)
	{
		if (InArray.Num() == 0)
		{
			return TArrayView<T>();
		}

		// @todo static_assert(TIsTrivial<T>::Value, "Only trivially constructible / copyable types can be used in RHICmdList.");
		void* NewArray = AllocCopy(InArray.GetData(), InArray.Num() * sizeof(T), alignof(T));
		return TArrayView<T>((T*) NewArray, InArray.Num());
	}

	FORCEINLINE_DEBUGGABLE TCHAR* AllocString(const TCHAR* Name)
	{
		int32 Len = FCString::Strlen(Name) + 1;
		TCHAR* NameCopy  = (TCHAR*)Alloc(Len * (int32)sizeof(TCHAR), (int32)sizeof(TCHAR));
		FCString::Strcpy(NameCopy, Len, Name);
		return NameCopy;
	}

	FORCEINLINE_DEBUGGABLE void* AllocCommand(int32 AllocSize, int32 Alignment)
	{
		checkSlow(!IsExecuting());
		checkfSlow(!Bypass(), TEXT("Invalid attempt to record commands in bypass mode."));
		FRHICommandBase* Result = (FRHICommandBase*) MemManager.Alloc(AllocSize, Alignment);
		++NumCommands;
		*CommandLink = Result;
		CommandLink = &Result->Next;
		return Result;
	}

	template <typename TCmd>
	FORCEINLINE void* AllocCommand()
	{
		return AllocCommand(sizeof(TCmd), alignof(TCmd));
	}

	template <typename LAMBDA>
	FORCEINLINE_DEBUGGABLE void EnqueueLambda(const TCHAR* LambdaName, LAMBDA&& Lambda)
	{
		if (IsBottomOfPipe())
		{
			Lambda(*this);
		}
		else
		{
			ALLOC_COMMAND(TRHILambdaCommand<FRHICommandListBase, LAMBDA>)(Forward<LAMBDA>(Lambda), LambdaName);
		}
	}

	template <typename LAMBDA>
	FORCEINLINE_DEBUGGABLE void EnqueueLambda(LAMBDA&& Lambda)
	{
		FRHICommandListBase::EnqueueLambda(TEXT("TRHILambdaCommand"), Forward<LAMBDA>(Lambda));
	}
	
	enum class EThreadFence
	{
		Enabled,
		Disabled
	};

	template <typename LAMBDA>
	void EnqueueLambdaMultiPipe(ERHIPipeline Pipelines, EThreadFence ThreadFence, const TCHAR* LambdaName, LAMBDA&& Lambda)
	{
		checkf(IsTopOfPipe() || Bypass(), TEXT("Cannot enqueue a multi-pipe lambda from the bottom of pipe."));

		ERHIPipeline OldPipeline = ActivePipelines;
		ActivatePipelines(Pipelines);

		if (IsBottomOfPipe())
		{
			FRHIContextArray LocalContexts { InPlace, nullptr };
			for (ERHIPipeline Pipeline : MakeFlagsRange(Pipelines))
			{
				LocalContexts[Pipeline] = Contexts[Pipeline];
				check(LocalContexts[Pipeline]);
			}

			// Static cast to enforce const type in lambda args
			Lambda(static_cast<FRHIContextArray const&>(LocalContexts));
		}
		else
		{
			ALLOC_COMMAND(TRHILambdaCommandMultiPipe<FRHICommandListBase, LAMBDA>)(Forward<LAMBDA>(Lambda), LambdaName, Pipelines);
		}

		ActivatePipelines(OldPipeline);
		
		if (ThreadFence == EThreadFence::Enabled)
		{
			RHIThreadFence(true);
		}
	}

	FORCEINLINE bool HasCommands() const
	{
		// Assume we have commands if anything is allocated.
		return !MemManager.IsEmpty();
	}

	FORCEINLINE bool IsExecuting() const
	{
		return bExecuting;
	}

	FORCEINLINE bool IsBottomOfPipe() const
	{
		return Bypass() || IsExecuting();
	}

	FORCEINLINE bool IsTopOfPipe() const
	{
		return !IsBottomOfPipe();
	}

	FORCEINLINE bool IsGraphics() const
	{
		// Exact equality is deliberate. Only return true if the graphics pipe is the only active pipe.
		return ActivePipelines == ERHIPipeline::Graphics;
	}

	FORCEINLINE bool IsAsyncCompute() const
	{
		// Exact equality is deliberate. Only return true if the compute pipe is the only active pipe.
		return ActivePipelines == ERHIPipeline::AsyncCompute;
	}

	FORCEINLINE ERHIPipeline GetPipeline() const
	{
		check(ActivePipelines == ERHIPipeline::None || IsSingleRHIPipeline(ActivePipelines));
		return ActivePipelines;
	}

	FORCEINLINE IRHICommandContext& GetContext()
	{
		checkf(IsSingleRHIPipeline(ActivePipelines), TEXT("Exactly one pipeline must be active to call GetContext(). Current pipeline mask is '0x%02x'."), static_cast<std::underlying_type_t<ERHIPipeline>>(ActivePipelines));
		checkf(GraphicsContext, TEXT("There is no active graphics context on this command list. There may be a missing call to SwitchPipeline()."));
		return *GraphicsContext;
	}

	FORCEINLINE IRHIComputeContext& GetComputeContext()
	{
		checkf(IsSingleRHIPipeline(ActivePipelines), TEXT("Exactly one pipeline must be active to call GetComputeContext(). Current pipeline mask is '0x%02x'."), static_cast<std::underlying_type_t<ERHIPipeline>>(ActivePipelines));
		checkf(ComputeContext, TEXT("There is no active compute context on this command list. There may be a missing call to SwitchPipeline()."));
		return *ComputeContext;
	}

	FORCEINLINE IRHIUploadContext& GetUploadContext()
	{
		if(!UploadContext)
		{
			UploadContext = GDynamicRHI->RHIGetUploadContext();
		}
		return *UploadContext;
	}
	
	inline bool Bypass() const;

private:
	RHI_API void ActivatePipelines(ERHIPipeline Pipelines);
	RHI_API void InvalidBufferFatalError(const FRHIResourceCreateInfo& CreateInfo, EBufferUsageFlags Usage, uint32 Stride);

public:
	RHI_API ERHIPipeline SwitchPipeline(ERHIPipeline Pipeline);

	FORCEINLINE FRHIGPUMask GetGPUMask() const { return PersistentState.CurrentGPUMask; }

	bool IsRecursive		   () const { return PersistentState.bRecursive; }
	bool IsOutsideRenderPass   () const { return !PersistentState.bInsideRenderPass; }
	bool IsInsideRenderPass    () const { return PersistentState.bInsideRenderPass;  }
	bool IsInsideComputePass   () const { return PersistentState.bInsideComputePass; }

#if HAS_GPU_STATS
	RHI_API TOptional<FRHIDrawStatsCategory const*> SetDrawStatsCategory(TOptional<FRHIDrawStatsCategory const*> Category);
#endif

	RHI_API FGraphEventRef RHIThreadFence(bool bSetLockFence = false);

	FORCEINLINE void* LockBuffer(FRHIBuffer* Buffer, uint32 Offset, uint32 SizeRHI, EResourceLockMode LockMode)
	{
		checkf(IsTopOfPipe() || Bypass(), TEXT("Buffers may only be locked while recording RHI command lists, not during RHI command list execution."));

		FRHICommandListScopedPipelineGuard ScopedPipeline(*this);
		return GDynamicRHI->RHILockBuffer(*this, Buffer, Offset, SizeRHI, LockMode);
	}

	FORCEINLINE void UnlockBuffer(FRHIBuffer* Buffer)
	{
		checkf(IsTopOfPipe() || Bypass(), TEXT("Buffers may only be unlocked while recording RHI command lists, not during RHI command list execution."));

		FRHICommandListScopedPipelineGuard ScopedPipeline(*this);
		GDynamicRHI->RHIUnlockBuffer(*this, Buffer);
	}

	// LockBufferMGPU / UnlockBufferMGPU may ONLY be called for buffers with the EBufferUsageFlags::MultiGPUAllocate flag set!
	// And buffers with that flag set may not call the regular (single GPU) LockBuffer / UnlockBuffer.  The single GPU version
	// of LockBuffer uses driver mirroring to propagate the updated buffer to other GPUs, while the MGPU / MultiGPUAllocate
	// version requires the caller to manually lock and initialize the buffer separately on each GPU.  This can be done by
	// iterating over FRHIGPUMask::All() and calling LockBufferMGPU / UnlockBufferMGPU for each version.
	//
	// EBufferUsageFlags::MultiGPUAllocate is only needed for cases where CPU initialized data needs to be different per GPU,
	// which is a rare edge case.  Currently, this is only used for the ray tracing acceleration structure address buffer,
	// which contains virtual address references to other GPU resources, which may be in a different location on each GPU.
	//
	FORCEINLINE void* LockBufferMGPU(FRHIBuffer* Buffer, uint32 GPUIndex, uint32 Offset, uint32 SizeRHI, EResourceLockMode LockMode)
	{
		checkf(IsTopOfPipe() || Bypass(), TEXT("Buffers may only be locked while recording RHI command lists, not during RHI command list execution."));

		return GDynamicRHI->RHILockBufferMGPU(*this, Buffer, GPUIndex, Offset, SizeRHI, LockMode);
	}

	FORCEINLINE void UnlockBufferMGPU(FRHIBuffer* Buffer, uint32 GPUIndex)
	{
		checkf(IsTopOfPipe() || Bypass(), TEXT("Buffers may only be unlocked while recording RHI command lists, not during RHI command list execution."));

		GDynamicRHI->RHIUnlockBufferMGPU(*this, Buffer, GPUIndex);
	}
	
	FORCEINLINE FBufferRHIRef CreateBuffer(uint32 Size, EBufferUsageFlags Usage, uint32 Stride, ERHIAccess ResourceState, FRHIResourceCreateInfo& CreateInfo)
	{
		FRHIBufferDesc BufferDesc = CreateInfo.bWithoutNativeResource
			? FRHIBufferDesc::Null()
			: FRHIBufferDesc(Size, Stride, Usage);

		if (Size == 0 && !BufferDesc.IsNull())
		{
			InvalidBufferFatalError(CreateInfo, Usage, Stride);
		}

		FRHICommandListScopedPipelineGuard ScopedPipeline(*this);
		FBufferRHIRef Buffer = GDynamicRHI->RHICreateBuffer(*this, BufferDesc, ResourceState, CreateInfo);
		Buffer->SetTrackedAccess_Unsafe(ResourceState);
		return Buffer;
	}

	FORCEINLINE FBufferRHIRef CreateVertexBuffer(uint32 Size, EBufferUsageFlags Usage, ERHIAccess ResourceState, FRHIResourceCreateInfo& CreateInfo)
	{
		return CreateBuffer(Size, Usage | EBufferUsageFlags::VertexBuffer, 0, ResourceState, CreateInfo);
	}

	FORCEINLINE FBufferRHIRef CreateVertexBuffer(uint32 Size, EBufferUsageFlags Usage, FRHIResourceCreateInfo& CreateInfo)
	{
		ERHIAccess ResourceState = RHIGetDefaultResourceState(Usage | EBufferUsageFlags::VertexBuffer, false);
		return CreateVertexBuffer(Size, Usage, ResourceState, CreateInfo);
	}

	FORCEINLINE FBufferRHIRef CreateStructuredBuffer(uint32 Stride, uint32 Size, EBufferUsageFlags Usage, ERHIAccess ResourceState, FRHIResourceCreateInfo& CreateInfo)
	{
		return CreateBuffer(Size, Usage | EBufferUsageFlags::StructuredBuffer, Stride, ResourceState, CreateInfo);
	}

	FORCEINLINE FBufferRHIRef CreateStructuredBuffer(uint32 Stride, uint32 Size, EBufferUsageFlags Usage, FRHIResourceCreateInfo& CreateInfo)
	{
		ERHIAccess ResourceState = RHIGetDefaultResourceState(Usage | EBufferUsageFlags::StructuredBuffer, false);
		return CreateStructuredBuffer(Stride, Size, Usage, ResourceState, CreateInfo);
	}

	FORCEINLINE FBufferRHIRef CreateIndexBuffer(uint32 Stride, uint32 Size, EBufferUsageFlags Usage, ERHIAccess ResourceState, FRHIResourceCreateInfo& CreateInfo)
	{
		return CreateBuffer(Size, Usage | EBufferUsageFlags::IndexBuffer, Stride, ResourceState, CreateInfo);
	}

	FORCEINLINE FBufferRHIRef CreateIndexBuffer(uint32 Stride, uint32 Size, EBufferUsageFlags Usage, FRHIResourceCreateInfo& CreateInfo)
	{
		ERHIAccess ResourceState = RHIGetDefaultResourceState(Usage | EBufferUsageFlags::IndexBuffer, false);
		return CreateIndexBuffer(Stride, Size, Usage, ResourceState, CreateInfo);
	}

	FORCEINLINE void UpdateUniformBuffer(FRHIUniformBuffer* UniformBufferRHI, const void* Contents)
	{
		FRHICommandListScopedPipelineGuard ScopedPipeline(*this);
		GDynamicRHI->RHIUpdateUniformBuffer(*this, UniformBufferRHI, Contents);
	}

	FORCEINLINE void UpdateStreamSourceSlot(FRHIStreamSourceSlot* StreamSourceSlotRHI, FRHIBuffer* BufferRHI)
	{
		check(StreamSourceSlotRHI);
		EnqueueLambda([this, StreamSourceSlotRHI, BufferRHI] (FRHICommandListBase&)
		{
			StreamSourceSlotRHI->Buffer = BufferRHI;
		});
	}

	FORCEINLINE void UpdateTexture2D(FRHITexture* Texture, uint32 MipIndex, const struct FUpdateTextureRegion2D& UpdateRegion, uint32 SourcePitch, const uint8* SourceData)
	{
		checkf(UpdateRegion.DestX + UpdateRegion.Width <= Texture->GetSizeX(), TEXT("UpdateTexture2D out of bounds on X. Texture: %s, %i, %i, %i"), *Texture->GetName().ToString(), UpdateRegion.DestX, UpdateRegion.Width, Texture->GetSizeX());
		checkf(UpdateRegion.DestY + UpdateRegion.Height <= Texture->GetSizeY(), TEXT("UpdateTexture2D out of bounds on Y. Texture: %s, %i, %i, %i"), *Texture->GetName().ToString(), UpdateRegion.DestY, UpdateRegion.Height, Texture->GetSizeY());
		LLM_SCOPE(ELLMTag::Textures);

		FRHICommandListScopedPipelineGuard ScopedPipeline(*this);
		GDynamicRHI->RHIUpdateTexture2D(*this, Texture, MipIndex, UpdateRegion, SourcePitch, SourceData);
	}

	FORCEINLINE FTextureRHIRef CreateTexture(const FRHITextureCreateDesc& CreateDesc)
	{
		LLM_SCOPE(EnumHasAnyFlags(CreateDesc.Flags, TexCreate_RenderTargetable | TexCreate_DepthStencilTargetable) ? ELLMTag::RenderTargets : ELLMTag::Textures);

		if (CreateDesc.InitialState == ERHIAccess::Unknown)
		{
			// Need to copy the incoming descriptor since we need to override the initial state.
			FRHITextureCreateDesc NewCreateDesc(CreateDesc);
			NewCreateDesc.SetInitialState(RHIGetDefaultResourceState(CreateDesc.Flags, CreateDesc.BulkData != nullptr));

			return GDynamicRHI->RHICreateTexture(*this, NewCreateDesc);
		}

		return GDynamicRHI->RHICreateTexture(*this, CreateDesc);
	}

	FORCEINLINE void UpdateFromBufferTexture2D(FRHITexture* Texture, uint32 MipIndex, const struct FUpdateTextureRegion2D& UpdateRegion, uint32 SourcePitch, FRHIBuffer* Buffer, uint32 BufferOffset)
	{
		checkf(UpdateRegion.DestX + UpdateRegion.Width <= Texture->GetSizeX(), TEXT("UpdateFromBufferTexture2D out of bounds on X. Texture: %s, %i, %i, %i"), *Texture->GetName().ToString(), UpdateRegion.DestX, UpdateRegion.Width, Texture->GetSizeX());
		checkf(UpdateRegion.DestY + UpdateRegion.Height <= Texture->GetSizeY(), TEXT("UpdateFromBufferTexture2D out of bounds on Y. Texture: %s, %i, %i, %i"), *Texture->GetName().ToString(), UpdateRegion.DestY, UpdateRegion.Height, Texture->GetSizeY());
		LLM_SCOPE(ELLMTag::Textures);

		FRHICommandListScopedPipelineGuard ScopedPipeline(*this);
		GDynamicRHI->RHIUpdateFromBufferTexture2D(*this, Texture, MipIndex, UpdateRegion, SourcePitch, Buffer, BufferOffset);
	}

	FORCEINLINE void UpdateTexture3D(FRHITexture* Texture, uint32 MipIndex, const struct FUpdateTextureRegion3D& UpdateRegion, uint32 SourceRowPitch, uint32 SourceDepthPitch, const uint8* SourceData)
	{
		checkf(UpdateRegion.DestX + UpdateRegion.Width <= Texture->GetSizeX(), TEXT("UpdateTexture3D out of bounds on X. Texture: %s, %i, %i, %i"), *Texture->GetName().ToString(), UpdateRegion.DestX, UpdateRegion.Width, Texture->GetSizeX());
		checkf(UpdateRegion.DestY + UpdateRegion.Height <= Texture->GetSizeY(), TEXT("UpdateTexture3D out of bounds on Y. Texture: %s, %i, %i, %i"), *Texture->GetName().ToString(), UpdateRegion.DestY, UpdateRegion.Height, Texture->GetSizeY());
		checkf(UpdateRegion.DestZ + UpdateRegion.Depth <= Texture->GetSizeZ(), TEXT("UpdateTexture3D out of bounds on Z. Texture: %s, %i, %i, %i"), *Texture->GetName().ToString(), UpdateRegion.DestZ, UpdateRegion.Depth, Texture->GetSizeZ());
		LLM_SCOPE(ELLMTag::Textures);

		FRHICommandListScopedPipelineGuard ScopedPipeline(*this);
		GDynamicRHI->RHIUpdateTexture3D(*this, Texture, MipIndex, UpdateRegion, SourceRowPitch, SourceDepthPitch, SourceData);
	}

	FORCEINLINE FTextureReferenceRHIRef CreateTextureReference(FRHITexture* InReferencedTexture = nullptr)
	{
		return GDynamicRHI->RHICreateTextureReference(*this, InReferencedTexture);
	}

	RHI_API void UpdateTextureReference(FRHITextureReference* TextureRef, FRHITexture* NewTexture);

	FORCEINLINE FShaderResourceViewRHIRef CreateShaderResourceView(FRHIBuffer* Buffer, FRHIViewDesc::FBufferSRV::FInitializer const& ViewDesc)
	{
		LLM_SCOPE_BYNAME(TEXT("RHIMisc/CreateShaderResourceView"));
		return GDynamicRHI->RHICreateShaderResourceView(*this, Buffer, ViewDesc);
	}

	FORCEINLINE FShaderResourceViewRHIRef CreateShaderResourceView(FRHITexture* Texture, FRHIViewDesc::FTextureSRV::FInitializer const& ViewDesc)
	{
		LLM_SCOPE_BYNAME(TEXT("RHIMisc/CreateShaderResourceView"));
		checkf(Texture->GetTextureReference() == nullptr, TEXT("Creating a shader resource view of an FRHITextureReference is not supported."));

		return GDynamicRHI->RHICreateShaderResourceView(*this, Texture, ViewDesc);
	}

	FORCEINLINE FUnorderedAccessViewRHIRef CreateUnorderedAccessView(FRHIBuffer* Buffer, FRHIViewDesc::FBufferUAV::FInitializer const& ViewDesc)
	{
		LLM_SCOPE_BYNAME(TEXT("RHIMisc/CreateUnorderedAccessView"));
		return GDynamicRHI->RHICreateUnorderedAccessView(*this, Buffer, ViewDesc);
	}

	FORCEINLINE FUnorderedAccessViewRHIRef CreateUnorderedAccessView(FRHITexture* Texture, FRHIViewDesc::FTextureUAV::FInitializer const& ViewDesc)
	{
		LLM_SCOPE_BYNAME(TEXT("RHIMisc/CreateUnorderedAccessView"));
		checkf(Texture->GetTextureReference() == nullptr, TEXT("Creating an unordered access view of an FRHITextureReference is not supported."));

		return GDynamicRHI->RHICreateUnorderedAccessView(*this, Texture, ViewDesc);
	}

	FORCEINLINE FShaderResourceViewRHIRef CreateShaderResourceView(const FShaderResourceViewInitializer& Initializer)
	{
		return CreateShaderResourceView(Initializer.Buffer, Initializer);
	}

	//UE_DEPRECATED(5.3, "Use the CreateUnorderedAccessView function that takes an FRHIViewDesc.")
	FORCEINLINE FUnorderedAccessViewRHIRef CreateUnorderedAccessView(FRHIBuffer* Buffer, bool bUseUAVCounter, bool bAppendBuffer)
	{
		return CreateUnorderedAccessView(Buffer, FRHIViewDesc::CreateBufferUAV()
			.SetTypeFromBuffer(Buffer)
			.SetAtomicCounter(bUseUAVCounter)
			.SetAppendBuffer(bAppendBuffer)
		);
	}

	//UE_DEPRECATED(5.3, "Use the CreateUnorderedAccessView function that takes an FRHIViewDesc.")
	FORCEINLINE FUnorderedAccessViewRHIRef CreateUnorderedAccessView(FRHIBuffer* Buffer, uint8 Format)
	{
		// For back-compat reasons, SRVs of byte-address buffers created via this function ignore the Format, and instead create raw views.
		if (Buffer && EnumHasAnyFlags(Buffer->GetDesc().Usage, BUF_ByteAddressBuffer))
		{
			return CreateUnorderedAccessView(Buffer, FRHIViewDesc::CreateBufferUAV()
				.SetType(FRHIViewDesc::EBufferType::Raw)
			);
		}
		else
		{
			return CreateUnorderedAccessView(Buffer, FRHIViewDesc::CreateBufferUAV()
				.SetType(FRHIViewDesc::EBufferType::Typed)
				.SetFormat(EPixelFormat(Format))
			);
		}
	}

	//UE_DEPRECATED(5.3, "Use the CreateUnorderedAccessView function that takes an FRHIViewDesc.")
	FORCEINLINE FUnorderedAccessViewRHIRef CreateUnorderedAccessView(FRHITexture* Texture, uint32 MipLevel = 0, uint16 FirstArraySlice = 0, uint16 NumArraySlices = 0)
	{
		check(MipLevel < 256);

		return CreateUnorderedAccessView(Texture, FRHIViewDesc::CreateTextureUAV()
			.SetDimensionFromTexture(Texture)
			.SetMipLevel(uint8(MipLevel))
			.SetArrayRange(FirstArraySlice, NumArraySlices)
		);
	}

	//UE_DEPRECATED(5.3, "Use the CreateUnorderedAccessView function that takes an FRHIViewDesc.")
	FORCEINLINE FUnorderedAccessViewRHIRef CreateUnorderedAccessView(FRHITexture* Texture, uint32 MipLevel, uint8 Format, uint16 FirstArraySlice = 0, uint16 NumArraySlices = 0)
	{
		check(MipLevel < 256);

		return CreateUnorderedAccessView(Texture, FRHIViewDesc::CreateTextureUAV()
			.SetDimensionFromTexture(Texture)
			.SetMipLevel(uint8(MipLevel))
			.SetFormat(EPixelFormat(Format))
			.SetArrayRange(FirstArraySlice, NumArraySlices)
		);
	}

	//UE_DEPRECATED(5.3, "Use the CreateShaderResourceView function that takes an FRHIViewDesc.")
	FORCEINLINE FShaderResourceViewRHIRef CreateShaderResourceView(FRHIBuffer* Buffer)
	{
		FShaderResourceViewRHIRef SRVRef = CreateShaderResourceView(Buffer, FRHIViewDesc::CreateBufferSRV()
			.SetTypeFromBuffer(Buffer));
		checkf(SRVRef->GetDesc().Buffer.SRV.BufferType != FRHIViewDesc::EBufferType::Typed,
			TEXT("Typed buffer should be created using CreateShaderResourceView where Format is specified."));
		return SRVRef;
	}

	//UE_DEPRECATED(5.3, "Use the CreateShaderResourceView function that takes an FRHIViewDesc.")
	FORCEINLINE FShaderResourceViewRHIRef CreateShaderResourceView(FRHIBuffer* Buffer, uint32 Stride, uint8 Format)
	{
		check(Format != PF_Unknown);
		check(Stride == GPixelFormats[Format].BlockBytes);

		// For back-compat reasons, SRVs of byte-address buffers created via this function ignore the Format, and instead create raw views.
		if (Buffer && EnumHasAnyFlags(Buffer->GetDesc().Usage, BUF_ByteAddressBuffer))
		{
			return CreateShaderResourceView(Buffer, FRHIViewDesc::CreateBufferSRV()
				.SetType(FRHIViewDesc::EBufferType::Raw)
			);
		}
		else
		{
			return CreateShaderResourceView(Buffer, FRHIViewDesc::CreateBufferSRV()
				.SetType(FRHIViewDesc::EBufferType::Typed)
				.SetFormat(EPixelFormat(Format))
			);
		}
	}

	//UE_DEPRECATED(5.3, "Use the CreateShaderResourceView function that takes an FRHIViewDesc.")
	FORCEINLINE FShaderResourceViewRHIRef CreateShaderResourceView(FRHITexture* Texture, const FRHITextureSRVCreateInfo& CreateInfo)
	{
		return CreateShaderResourceView(Texture, FRHIViewDesc::CreateTextureSRV()
			.SetDimensionFromTexture(Texture)
			.SetFormat     (CreateInfo.Format)
			.SetMipRange   (CreateInfo.MipLevel, CreateInfo.NumMipLevels)
			.SetDisableSRGB(CreateInfo.SRGBOverride == SRGBO_ForceDisable)
			.SetArrayRange (CreateInfo.FirstArraySlice, CreateInfo.NumArraySlices)
			.SetPlane      (CreateInfo.MetaData)
		);
	}

	//UE_DEPRECATED(5.3, "Use the CreateShaderResourceView function that takes an FRHIViewDesc.")
	FORCEINLINE FShaderResourceViewRHIRef CreateShaderResourceView(FRHITexture* Texture, uint8 MipLevel)
	{
		return CreateShaderResourceView(Texture, FRHIViewDesc::CreateTextureSRV()
			.SetDimensionFromTexture(Texture)
			.SetMipRange(MipLevel, 1)
		);
	}

	//UE_DEPRECATED(5.3, "Use the CreateShaderResourceView function that takes an FRHIViewDesc.")
	FORCEINLINE FShaderResourceViewRHIRef CreateShaderResourceView(FRHITexture* Texture, uint8 MipLevel, uint8 NumMipLevels, EPixelFormat Format)
	{
		return CreateShaderResourceView(Texture, FRHIViewDesc::CreateTextureSRV()
			.SetDimensionFromTexture(Texture)
			.SetMipRange(MipLevel, NumMipLevels)
			.SetFormat(Format)
		);
	}

	//UE_DEPRECATED(5.3, "Use the CreateShaderResourceView function that takes an FRHIViewDesc.")
	FORCEINLINE FShaderResourceViewRHIRef CreateShaderResourceViewWriteMask(FRHITexture* Texture2DRHI)
	{
		return CreateShaderResourceView(Texture2DRHI, FRHIViewDesc::CreateTextureSRV()
			.SetDimensionFromTexture(Texture2DRHI)
			.SetPlane(ERHITexturePlane::CMask)
		);
	}

	//UE_DEPRECATED(5.3, "Use the CreateShaderResourceView function that takes an FRHIViewDesc.")
	FORCEINLINE FShaderResourceViewRHIRef CreateShaderResourceViewFMask(FRHITexture* Texture2DRHI)
	{
		return CreateShaderResourceView(Texture2DRHI, FRHIViewDesc::CreateTextureSRV()
			.SetDimensionFromTexture(Texture2DRHI)
			.SetPlane(ERHITexturePlane::FMask)
		);
	}

	FORCEINLINE FRHIResourceCollectionRef CreateResourceCollection(TConstArrayView<FRHIResourceCollectionMember> InMembers)
	{
		LLM_SCOPE_BYNAME(TEXT("RHIMisc/CreateResourceCollection"));
		return GDynamicRHI->RHICreateResourceCollection(*this, InMembers);
	}

	FORCEINLINE FRayTracingGeometryRHIRef CreateRayTracingGeometry(const FRayTracingGeometryInitializer& Initializer)
	{
		return GDynamicRHI->RHICreateRayTracingGeometry(*this, Initializer);
	}

	FORCEINLINE FShaderBindingTableRHIRef CreateRayTracingShaderBindingTable(const FRayTracingShaderBindingTableInitializer& Initializer)
	{
		return GDynamicRHI->RHICreateShaderBindingTable(*this, Initializer);
	}
	
	UE_DEPRECATED(5.5, "Use the global scope RHICalcRayTracingGeometrySize function instead.")
	FORCEINLINE FRayTracingAccelerationStructureSize CalcRayTracingGeometrySize(const FRayTracingGeometryInitializer& Initializer)
	{
		return GDynamicRHI->RHICalcRayTracingGeometrySize(Initializer);
	}

	FORCEINLINE void ReplaceResources(TArray<FRHIResourceReplaceInfo>&& ReplaceInfos)
	{
		if (ReplaceInfos.Num() == 0)
		{
			return;
		}

		GDynamicRHI->RHIReplaceResources(*this, MoveTemp(ReplaceInfos));
	}

	FORCEINLINE void BindDebugLabelName(FRHITexture* Texture, const TCHAR* Name)
	{
		GDynamicRHI->RHIBindDebugLabelName(*this, Texture, Name);
	}

	FORCEINLINE void BindDebugLabelName(FRHIBuffer* Buffer, const TCHAR* Name)
	{
		GDynamicRHI->RHIBindDebugLabelName(*this, Buffer, Name);
	}

	FORCEINLINE void BindDebugLabelName(FRHIUnorderedAccessView* UnorderedAccessViewRHI, const TCHAR* Name)
	{
		GDynamicRHI->RHIBindDebugLabelName(*this, UnorderedAccessViewRHI, Name);
	}

	inline FRHIBatchedShaderParameters& GetScratchShaderParameters()
	{
		FRHIBatchedShaderParameters*& ScratchShaderParameters = ShaderParameterState.ScratchShaderParameters;

		if (!ScratchShaderParameters)
		{
			ScratchShaderParameters = new (MemManager) FRHIBatchedShaderParameters(*CreateBatchedShaderParameterAllocator(ERHIBatchedShaderParameterAllocatorPageSize::Small));
		}

		if (!ensureMsgf(!ScratchShaderParameters->HasParameters(), TEXT("Scratch shader parameters left without committed parameters")))
		{
			ScratchShaderParameters->Reset();
		}

		return *ScratchShaderParameters;
	}

	inline FRHIBatchedShaderUnbinds& GetScratchShaderUnbinds()
	{
		if (!ensureMsgf(!ScratchShaderUnbinds.HasParameters(), TEXT("Scratch shader parameters left without committed parameters")))
		{
			ScratchShaderUnbinds.Reset();
		}
		return ScratchShaderUnbinds;
	}

	// Returns true if the RHI needs unbind commands
	bool NeedsShaderUnbinds() const
	{
		return GRHIGlobals.NeedsShaderUnbinds;
	}

	FRHIBatchedShaderParametersAllocator* CreateBatchedShaderParameterAllocator(ERHIBatchedShaderParameterAllocatorPageSize PageSize)
	{
		return new (MemManager) FRHIBatchedShaderParametersAllocator(ShaderParameterState.AllocatorsRoot, *this, PageSize);
	}

protected:
	FMemStackBase& GetAllocator() { return MemManager; }

	FORCEINLINE void ValidateBoundShader(FRHIVertexShader*        ShaderRHI) { checkSlow(PersistentState.BoundShaderInput.VertexShaderRHI          == ShaderRHI); }
	FORCEINLINE void ValidateBoundShader(FRHIPixelShader*         ShaderRHI) { checkSlow(PersistentState.BoundShaderInput.PixelShaderRHI           == ShaderRHI); }
	FORCEINLINE void ValidateBoundShader(FRHIGeometryShader*      ShaderRHI) { checkSlow(PersistentState.BoundShaderInput.GetGeometryShader()      == ShaderRHI); }
	FORCEINLINE void ValidateBoundShader(FRHIComputeShader*       ShaderRHI) { checkSlow(PersistentState.BoundComputeShaderRHI                     == ShaderRHI); }
	FORCEINLINE void ValidateBoundShader(FRHIWorkGraphShader*     ShaderRHI) { checkSlow(PersistentState.BoundWorkGraphShaderRHI                   == ShaderRHI); }
	FORCEINLINE void ValidateBoundShader(FRHIMeshShader*          ShaderRHI) { checkSlow(PersistentState.BoundShaderInput.GetMeshShader()          == ShaderRHI); }
	FORCEINLINE void ValidateBoundShader(FRHIAmplificationShader* ShaderRHI) { checkSlow(PersistentState.BoundShaderInput.GetAmplificationShader() == ShaderRHI); }

	FORCEINLINE void ValidateBoundShader(FRHIGraphicsShader* ShaderRHI)
	{
#if DO_GUARD_SLOW
		switch (ShaderRHI->GetFrequency())
		{
		case SF_Vertex:        checkSlow(PersistentState.BoundShaderInput.VertexShaderRHI          == ShaderRHI); break;
		case SF_Mesh:          checkSlow(PersistentState.BoundShaderInput.GetMeshShader()          == ShaderRHI); break;
		case SF_Amplification: checkSlow(PersistentState.BoundShaderInput.GetAmplificationShader() == ShaderRHI); break;
		case SF_Pixel:         checkSlow(PersistentState.BoundShaderInput.PixelShaderRHI           == ShaderRHI); break;
		case SF_Geometry:      checkSlow(PersistentState.BoundShaderInput.GetGeometryShader()      == ShaderRHI); break;
		default: checkfSlow(false, TEXT("Unexpected graphics shader type %d"), ShaderRHI->GetFrequency());
		}
#endif // DO_GUARD_SLOW
	}

	FORCEINLINE void ValidateShaderParameters(const FRHIBatchedShaderParameters& ShaderParameters)
	{
#if RHI_VALIDATE_BATCHED_SHADER_PARAMETERS
		check(this == &ShaderParameters.Allocator.RHICmdList);
#endif
	}

	FORCEINLINE void ValidateShaderBundleComputeDispatch(TConstArrayView<FRHIShaderBundleComputeDispatch> Dispatches)
	{
#if RHI_VALIDATE_BATCHED_SHADER_PARAMETERS
		for (const FRHIShaderBundleComputeDispatch& Dispatch : Dispatches)
		{
			if (Dispatch.IsValid())
			{
				ValidateShaderParameters(*Dispatch.Parameters);
			}
		}
#endif
	}

	void CacheActiveRenderTargets(const FRHIRenderPassInfo& Info)
	{
		FRHISetRenderTargetsInfo RTInfo;
		Info.ConvertToRenderTargetsInfo(RTInfo);

		for (int32 RTIdx = 0; RTIdx < RTInfo.NumColorRenderTargets; ++RTIdx)
		{
			PersistentState.CachedRenderTargets[RTIdx] = RTInfo.ColorRenderTarget[RTIdx];
		}

		PersistentState.CachedNumSimultanousRenderTargets = RTInfo.NumColorRenderTargets;
		PersistentState.CachedDepthStencilTarget = RTInfo.DepthStencilRenderTarget;
		PersistentState.bHasFragmentDensityAttachment = RTInfo.ShadingRateTexture != nullptr;
		PersistentState.MultiViewCount = RTInfo.MultiViewCount;
	}

	void IncrementSubpass()
	{
		PersistentState.SubpassIndex++;
	}
	
	void ResetSubpass(ESubpassHint SubpassHint)
	{
		PersistentState.SubpassHint = SubpassHint;
		PersistentState.SubpassIndex = 0;
	}

protected:
	FRHICommandBase*    Root            = nullptr;
	FRHICommandBase**   CommandLink     = nullptr;

	// The active context into which graphics commands are recorded.
	IRHICommandContext* GraphicsContext = nullptr;

	// The active compute context into which (possibly async) compute commands are recorded.
	IRHIComputeContext* ComputeContext  = nullptr;

	// The active upload context into which RHI specific commands are recorded.
	IRHIUploadContext* UploadContext 	= nullptr;
	
	// The RHI contexts available to the command list during execution.
	// These are always set for the immediate command list, see InitializeImmediateContexts().
	FRHIContextArray Contexts { InPlace, nullptr };

	uint32 NumCommands           = 0;
	bool bExecuting              = false;
	bool bAllowParallelTranslate = true;
	bool bUsesSetTrackedAccess   = false;
	bool bUsesShaderBundles      = false;
	bool bUsesLockFence          = false;

	// The currently selected pipelines that RHI commands are directed to, during command list recording.
	// This is also adjusted during command list execution based on recorded use of ActivatePipeline().
	ERHIPipeline ActivePipelines = ERHIPipeline::None;

#if DO_CHECK
	// Used to check for valid pipelines passed to ActivatePipeline().
	ERHIPipeline AllowedPipelines = ERHIPipeline::All;
#endif

	struct FRHICommandRHIThreadFence* LastLockFenceCommand = nullptr;

	// Graph event used to gate the execution of the command list on the completion of any dependent tasks
	// e.g. PSO async compilation and parallel RHICmdList recording tasks.
	FGraphEventRef DispatchEvent;

	struct FShaderParameterState
	{
		FRHIBatchedShaderParameters* ScratchShaderParameters = nullptr;
		FRHIBatchedShaderParametersAllocator* AllocatorsRoot = nullptr;

		FShaderParameterState() = default;

		FShaderParameterState(FShaderParameterState&& RHS)
		{
			AllocatorsRoot = RHS.AllocatorsRoot;
			ScratchShaderParameters = RHS.ScratchShaderParameters;
			RHS.AllocatorsRoot = nullptr;
			RHS.ScratchShaderParameters = nullptr;
		}

		~FShaderParameterState()
		{
			if (ScratchShaderParameters)
			{
				ScratchShaderParameters->~FRHIBatchedShaderParameters();
				ScratchShaderParameters = nullptr;
			}

			for (FRHIBatchedShaderParametersAllocator* Node = AllocatorsRoot; Node; Node = Node->Next)
			{
				Node->~FRHIBatchedShaderParametersAllocator();
			}
			AllocatorsRoot = nullptr;
		}
	};

	FShaderParameterState ShaderParameterState;
	FRHIBatchedShaderUnbinds ScratchShaderUnbinds;

#if WITH_RHI_BREADCRUMBS

	struct
	{
		FRHIBreadcrumbNode* Current = FRHIBreadcrumbNode::Sentinel;
		FRHIBreadcrumbList UnknownParentList {};
		bool bEmitBreadcrumbs = false;
	} CPUBreadcrumbState {};

	struct FBreadcrumbState
	{
		FRHIBreadcrumbNode* Current = FRHIBreadcrumbNode::Sentinel;
		TOptional<FRHIBreadcrumbNode*> Latest {};
		FRHIBreadcrumbNode* Prev = nullptr;
		FRHIBreadcrumbRange Range {};
	};

	TRHIPipelineArray<FBreadcrumbState> GPUBreadcrumbState { InPlace };

	FRHIBreadcrumbAllocatorArray BreadcrumbAllocatorRefs {};
	TSharedPtr<FRHIBreadcrumbAllocator> BreadcrumbAllocator;

	struct FActivatePipelineCommand
	{
		FActivatePipelineCommand* Next = nullptr;
		FRHIBreadcrumbNode* Target = nullptr;
		ERHIPipeline Pipelines;
	};
	struct
	{
		FActivatePipelineCommand* First = nullptr;
		FActivatePipelineCommand* Prev = nullptr;
	} ActivatePipelineCommands {};
#endif

#if HAS_GPU_STATS
	TOptional<FRHIDrawStatsCategory const*> InitialDrawStatsCategory {};
#endif

	// The values in this struct are preserved when the command list is moved or reset.
	struct FPersistentState
	{
		uint32 CachedNumSimultanousRenderTargets = 0;
		TStaticArray<FRHIRenderTargetView, MaxSimultaneousRenderTargets> CachedRenderTargets;
		FRHIDepthRenderTargetView CachedDepthStencilTarget;

		ESubpassHint SubpassHint = ESubpassHint::None;
		uint8 SubpassIndex = 0;
		uint8 MultiViewCount = 0;

		uint8 bHasFragmentDensityAttachment		: 1;

		uint8 bInsideRenderPass					: 1;
		uint8 bInsideComputePass				: 1;
		uint8 bInsideOcclusionQueryBatch		: 1;
		uint8 bRecursive						: 1;
		uint8 bImmediate						: 1;

		FRHIGPUMask CurrentGPUMask;
		FRHIGPUMask InitialGPUMask;

		FBoundShaderStateInput BoundShaderInput;
		FRHIComputeShader* BoundComputeShaderRHI = nullptr;
		FRHIWorkGraphShader* BoundWorkGraphShaderRHI = nullptr;

#if WITH_RHI_BREADCRUMBS
		FRHIBreadcrumbNode* LocalBreadcrumb = FRHIBreadcrumbNode::Sentinel;
#endif

#if HAS_GPU_STATS
		TOptional<FRHIDrawStatsCategory const*> CurrentDrawStatsCategory {};
#endif

		TStaticArray<void*, MAX_NUM_GPUS> QueryBatchData_Timestamp { InPlace, nullptr };
		TStaticArray<void*, MAX_NUM_GPUS> QueryBatchData_Occlusion { InPlace, nullptr };

		FPersistentState(FRHIGPUMask InInitialGPUMask, bool bInImmediate = false)
			: bHasFragmentDensityAttachment(0)
			, bInsideRenderPass(0)
			, bInsideComputePass(0)
			, bInsideOcclusionQueryBatch(0)
			, bRecursive(0)
			, bImmediate(bInImmediate)
			, CurrentGPUMask(InInitialGPUMask)
			, InitialGPUMask(InInitialGPUMask)
		{}

	} PersistentState;

	FRHIDrawStats DrawStats {};

public:
#if WITH_RHI_BREADCRUMBS
	friend FRHIBreadcrumbEventManual;
	friend FRHIBreadcrumbEventScope;

	FRHIBreadcrumbNode*& GetCurrentBreadcrumbRef()
	{
		return PersistentState.LocalBreadcrumb;
	}

	RHI_API void AttachBreadcrumbSubTree(FRHIBreadcrumbAllocator& Allocator, FRHIBreadcrumbList& Nodes);
#endif

	void Stats_AddDraw()
	{
#if HAS_GPU_STATS
		DrawStats.AddDraw(PersistentState.CurrentGPUMask, PersistentState.CurrentDrawStatsCategory.GetValue());
#else
		DrawStats.AddDraw(PersistentState.CurrentGPUMask, nullptr);
#endif
	}

	void Stats_AddDrawAndPrimitives(EPrimitiveType PrimitiveType, uint32 NumPrimitives)
	{
#if HAS_GPU_STATS
		DrawStats.AddDrawAndPrimitives(PersistentState.CurrentGPUMask, PersistentState.CurrentDrawStatsCategory.GetValue(), PrimitiveType, NumPrimitives);
#else
		DrawStats.AddDrawAndPrimitives(PersistentState.CurrentGPUMask, nullptr, PrimitiveType, NumPrimitives);
#endif
	}

	TStaticArray<void*, MAX_NUM_GPUS>& GetQueryBatchData(ERenderQueryType QueryType)
	{
		switch (QueryType)
		{
		default: checkNoEntry(); [[fallthrough]];
		case RQT_AbsoluteTime: return PersistentState.QueryBatchData_Timestamp;
		case RQT_Occlusion:    return PersistentState.QueryBatchData_Occlusion;
		}
	}

private:
	FRHICommandListBase(FPersistentState const& InPersistentState);

	// Replays recorded commands. Used internally, do not call directly.
	RHI_EXECUTE_API void Execute();

	friend class FRHICommandListExecutor;
	friend class FRHICommandListIterator;
	friend class FRHICommandListScopedFlushAndExecute;
	friend class FRHIComputeCommandList;
	friend class FRHICommandListImmediate;
	friend class FRHICommandList_RecursiveHazardous;
	friend class FRHIComputeCommandList_RecursiveHazardous;
	friend struct FRHICommandSetGPUMask;

	template <typename RHICmdListType, typename LAMBDA>
	friend struct TRHILambdaCommandMultiPipe;

#if WITH_RHI_BREADCRUMBS
	friend bool IRHIComputeContext::ShouldEmitBreadcrumbs() const;
#endif
};

#if WITH_RHI_BREADCRUMBS
//
// Returns true if RHI breadcrumb strings should be emitted to platform GPU profiling APIs.
// Platform RHI implementations should check for this inside RHIBeginBreadcrumbGPU and RHIEndBreadcrumbGPU.
//
inline bool IRHIComputeContext::ShouldEmitBreadcrumbs() const
{
	return GetExecutingCommandList().CPUBreadcrumbState.bEmitBreadcrumbs;
}
#endif

struct FUnnamedRhiCommand
{
	static const TCHAR* TStr() { return TEXT("FUnnamedRhiCommand"); }
};

template<typename TCmd, typename NameType = FUnnamedRhiCommand>
struct FRHICommand : public FRHICommandBase
{
#if RHICOMMAND_CALLSTACK
	uint64 StackFrames[16];

	FRHICommand()
	{
		FPlatformStackWalk::CaptureStackBackTrace(StackFrames, 16);
	}
#endif

	void ExecuteAndDestruct(FRHICommandListBase& CmdList) override final
	{
		LLM_SCOPE_BYNAME(TEXT("RHIMisc/CommandList/ExecuteAndDestruct"));
		TRACE_CPUPROFILER_EVENT_SCOPE_ON_CHANNEL_STR(NameType::TStr(), RHICommandsChannel);

		TCmd* ThisCmd = static_cast<TCmd*>(this);
		ThisCmd->Execute(CmdList);
		ThisCmd->~TCmd();
	}
};

#define FRHICOMMAND_UNNAMED(CommandName)							\
	struct CommandName final : public FRHICommand<CommandName, FUnnamedRhiCommand>

#define FRHICOMMAND_UNNAMED_TPL(TemplateType, CommandName)			\
	template<typename TemplateType>									\
	struct CommandName final : public FRHICommand<CommandName<TemplateType>, FUnnamedRhiCommand>

#define FRHICOMMAND_MACRO(CommandName)								\
	struct PREPROCESSOR_JOIN(CommandName##String, __LINE__)			\
	{																\
		static const TCHAR* TStr() { return TEXT(#CommandName); }	\
	};																\
	struct CommandName final : public FRHICommand<CommandName, PREPROCESSOR_JOIN(CommandName##String, __LINE__)>

#define FRHICOMMAND_MACRO_TPL(TemplateType, CommandName)			\
	struct PREPROCESSOR_JOIN(CommandName##String, __LINE__)			\
	{																\
		static const TCHAR* TStr() { return TEXT(#CommandName); }	\
	};																\
	template<typename TemplateType>									\
	struct CommandName final : public FRHICommand<CommandName<TemplateType>, PREPROCESSOR_JOIN(CommandName##String, __LINE__)>

FRHICOMMAND_MACRO(FRHICommandBeginUpdateMultiFrameResource)
{
	FRHITexture* Texture;
	FORCEINLINE_DEBUGGABLE FRHICommandBeginUpdateMultiFrameResource(FRHITexture* InTexture)
		: Texture(InTexture)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandEndUpdateMultiFrameResource)
{
	FRHITexture* Texture;
	FORCEINLINE_DEBUGGABLE FRHICommandEndUpdateMultiFrameResource(FRHITexture* InTexture)
		: Texture(InTexture)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandBeginUpdateMultiFrameUAV)
{
	FRHIUnorderedAccessView* UAV;
	FORCEINLINE_DEBUGGABLE FRHICommandBeginUpdateMultiFrameUAV(FRHIUnorderedAccessView* InUAV)
		: UAV(InUAV)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandEndUpdateMultiFrameUAV)
{
	FRHIUnorderedAccessView* UAV;
	FORCEINLINE_DEBUGGABLE FRHICommandEndUpdateMultiFrameUAV(FRHIUnorderedAccessView* InUAV)
		: UAV(InUAV)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

#if WITH_MGPU
FRHICOMMAND_MACRO(FRHICommandSetGPUMask)
{
	FRHIGPUMask GPUMask;
	FORCEINLINE_DEBUGGABLE FRHICommandSetGPUMask(FRHIGPUMask InGPUMask)
		: GPUMask(InGPUMask)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandTransferResources)
{
	TConstArrayView<FTransferResourceParams> Params;

	FORCEINLINE_DEBUGGABLE FRHICommandTransferResources(TConstArrayView<FTransferResourceParams> InParams)
		: Params(InParams)
	{
	}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandTransferResourceSignal)
{
	TConstArrayView<FTransferResourceFenceData*> FenceDatas;
	FRHIGPUMask SrcGPUMask;

	FORCEINLINE_DEBUGGABLE FRHICommandTransferResourceSignal(TConstArrayView<FTransferResourceFenceData*> InFenceDatas, FRHIGPUMask InSrcGPUMask)
		: FenceDatas(InFenceDatas)
		, SrcGPUMask(InSrcGPUMask)
	{
	}

	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};

FRHICOMMAND_MACRO(FRHICommandTransferResourceWait)
{
	TConstArrayView<FTransferResourceFenceData*> FenceDatas;

	FORCEINLINE_DEBUGGABLE FRHICommandTransferResourceWait(TConstArrayView<FTransferResourceFenceData*> InFenceDatas)
		: FenceDatas(InFenceDatas)
	{
	}

	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};

FRHICOMMAND_MACRO(FRHICommandCrossGPUTransfer)
{
	TConstArrayView<FTransferResourceParams> Params;
	TConstArrayView<FCrossGPUTransferFence*> PreTransfer;
	TConstArrayView<FCrossGPUTransferFence*> PostTransfer;

	FORCEINLINE_DEBUGGABLE FRHICommandCrossGPUTransfer(TConstArrayView<FTransferResourceParams> InParams, TConstArrayView<FCrossGPUTransferFence*> InPreTransfer, TConstArrayView<FCrossGPUTransferFence*> InPostTransfer)
		: Params(InParams)
		, PreTransfer(InPreTransfer)
		, PostTransfer(InPostTransfer)
	{
	}

	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};

FRHICOMMAND_MACRO(FRHICommandCrossGPUTransferSignal)
{
	TConstArrayView<FTransferResourceParams> Params;
	TConstArrayView<FCrossGPUTransferFence*> PreTransfer;

	FORCEINLINE_DEBUGGABLE FRHICommandCrossGPUTransferSignal(TConstArrayView<FTransferResourceParams> InParams, TConstArrayView<FCrossGPUTransferFence*> InPreTransfer)
		: Params(InParams)
		, PreTransfer(InPreTransfer)
	{
	}

	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};

FRHICOMMAND_MACRO(FRHICommandCrossGPUTransferWait)
{
	TConstArrayView<FCrossGPUTransferFence*> SyncPoints;

	FORCEINLINE_DEBUGGABLE FRHICommandCrossGPUTransferWait(TConstArrayView<FCrossGPUTransferFence*> InSyncPoints)
		: SyncPoints(InSyncPoints)
	{
	}

	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};
#endif // WITH_MGPU

FRHICOMMAND_MACRO(FRHICommandSetStencilRef)
{
	uint32 StencilRef;
	FORCEINLINE_DEBUGGABLE FRHICommandSetStencilRef(uint32 InStencilRef)
		: StencilRef(InStencilRef)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO_TPL(TRHIShader, FRHICommandSetShaderParameters)
{
	TRHIShader* Shader;
	TConstArrayView<uint8> ParametersData;
	TConstArrayView<FRHIShaderParameter> Parameters;
	TConstArrayView<FRHIShaderParameterResource> ResourceParameters;
	TConstArrayView<FRHIShaderParameterResource> BindlessParameters;

	FORCEINLINE_DEBUGGABLE FRHICommandSetShaderParameters(
		TRHIShader* InShader
		, TConstArrayView<uint8> InParametersData
		, TConstArrayView<FRHIShaderParameter> InParameters
		, TConstArrayView<FRHIShaderParameterResource> InResourceParameters
		, TConstArrayView<FRHIShaderParameterResource> InBindlessParameters
	)
		: Shader(InShader)
		, ParametersData(InParametersData)
		, Parameters(InParameters)
		, ResourceParameters(InResourceParameters)
		, BindlessParameters(InBindlessParameters)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO_TPL(TRHIShader, FRHICommandSetShaderUnbinds)
{
	TRHIShader* Shader;
	TConstArrayView<FRHIShaderParameterUnbind> Unbinds;

	FORCEINLINE_DEBUGGABLE FRHICommandSetShaderUnbinds(TRHIShader * InShader, TConstArrayView<FRHIShaderParameterUnbind> InUnbinds)
		: Shader(InShader)
		, Unbinds(InUnbinds)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};

FRHICOMMAND_MACRO(FRHICommandDrawPrimitive)
{
	uint32 BaseVertexIndex;
	uint32 NumPrimitives;
	uint32 NumInstances;
	FORCEINLINE_DEBUGGABLE FRHICommandDrawPrimitive(uint32 InBaseVertexIndex, uint32 InNumPrimitives, uint32 InNumInstances)
		: BaseVertexIndex(InBaseVertexIndex)
		, NumPrimitives(InNumPrimitives)
		, NumInstances(InNumInstances)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandDrawIndexedPrimitive)
{
	FRHIBuffer* IndexBuffer;
	int32 BaseVertexIndex;
	uint32 FirstInstance;
	uint32 NumVertices;
	uint32 StartIndex;
	uint32 NumPrimitives;
	uint32 NumInstances;
	FORCEINLINE_DEBUGGABLE FRHICommandDrawIndexedPrimitive(FRHIBuffer* InIndexBuffer, int32 InBaseVertexIndex, uint32 InFirstInstance, uint32 InNumVertices, uint32 InStartIndex, uint32 InNumPrimitives, uint32 InNumInstances)
		: IndexBuffer(InIndexBuffer)
		, BaseVertexIndex(InBaseVertexIndex)
		, FirstInstance(InFirstInstance)
		, NumVertices(InNumVertices)
		, StartIndex(InStartIndex)
		, NumPrimitives(InNumPrimitives)
		, NumInstances(InNumInstances)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetBlendFactor)
{
	FLinearColor BlendFactor;
	FORCEINLINE_DEBUGGABLE FRHICommandSetBlendFactor(const FLinearColor& InBlendFactor)
		: BlendFactor(InBlendFactor)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetStreamSource)
{
	uint32 StreamIndex;
	FRHIBuffer* VertexBuffer;
	uint32 Offset;
	FORCEINLINE_DEBUGGABLE FRHICommandSetStreamSource(uint32 InStreamIndex, FRHIBuffer* InVertexBuffer, uint32 InOffset)
		: StreamIndex(InStreamIndex)
		, VertexBuffer(InVertexBuffer)
		, Offset(InOffset)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetViewport)
{
	float MinX;
	float MinY;
	float MinZ;
	float MaxX;
	float MaxY;
	float MaxZ;
	FORCEINLINE_DEBUGGABLE FRHICommandSetViewport(float InMinX, float InMinY, float InMinZ, float InMaxX, float InMaxY, float InMaxZ)
		: MinX(InMinX)
		, MinY(InMinY)
		, MinZ(InMinZ)
		, MaxX(InMaxX)
		, MaxY(InMaxY)
		, MaxZ(InMaxZ)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetStereoViewport)
{
	float LeftMinX;
	float RightMinX;
	float LeftMinY;
	float RightMinY;
	float MinZ;
	float LeftMaxX;
	float RightMaxX;
	float LeftMaxY;
	float RightMaxY;
	float MaxZ;
	FORCEINLINE_DEBUGGABLE FRHICommandSetStereoViewport(float InLeftMinX, float InRightMinX, float InLeftMinY, float InRightMinY, float InMinZ, float InLeftMaxX, float InRightMaxX, float InLeftMaxY, float InRightMaxY, float InMaxZ)
		: LeftMinX(InLeftMinX)
		, RightMinX(InRightMinX)
		, LeftMinY(InLeftMinY)
		, RightMinY(InRightMinY)
		, MinZ(InMinZ)
		, LeftMaxX(InLeftMaxX)
		, RightMaxX(InRightMaxX)
		, LeftMaxY(InLeftMaxY)
		, RightMaxY(InRightMaxY)
		, MaxZ(InMaxZ)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetScissorRect)
{
	bool bEnable;
	uint32 MinX;
	uint32 MinY;
	uint32 MaxX;
	uint32 MaxY;
	FORCEINLINE_DEBUGGABLE FRHICommandSetScissorRect(bool InbEnable, uint32 InMinX, uint32 InMinY, uint32 InMaxX, uint32 InMaxY)
		: bEnable(InbEnable)
		, MinX(InMinX)
		, MinY(InMinY)
		, MaxX(InMaxX)
		, MaxY(InMaxY)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandBeginRenderPass)
{
	FRHIRenderPassInfo Info;
	const TCHAR* Name;

	FRHICommandBeginRenderPass(const FRHIRenderPassInfo& InInfo, const TCHAR* InName)
		: Info(InInfo)
		, Name(InName)
	{
	}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandEndRenderPass)
{
	FRHICommandEndRenderPass()
	{
	}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandNextSubpass)
{
	FRHICommandNextSubpass()
	{
	}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetComputePipelineState)
{
	FComputePipelineState* ComputePipelineState;
	FORCEINLINE_DEBUGGABLE FRHICommandSetComputePipelineState(FComputePipelineState* InComputePipelineState)
		: ComputePipelineState(InComputePipelineState)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetGraphicsPipelineState)
{
	FGraphicsPipelineState* GraphicsPipelineState;
	uint32 StencilRef;
	bool bApplyAdditionalState;
	FORCEINLINE_DEBUGGABLE FRHICommandSetGraphicsPipelineState(FGraphicsPipelineState* InGraphicsPipelineState, uint32 InStencilRef, bool bInApplyAdditionalState)
		: GraphicsPipelineState(InGraphicsPipelineState)
		, StencilRef(InStencilRef)
		, bApplyAdditionalState(bInApplyAdditionalState)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

#if PLATFORM_USE_FALLBACK_PSO
FRHICOMMAND_MACRO(FRHICommandSetGraphicsPipelineStateFromInitializer)
{
	FGraphicsPipelineStateInitializer PsoInit;
	uint32 StencilRef;
	bool bApplyAdditionalState;
	FORCEINLINE_DEBUGGABLE FRHICommandSetGraphicsPipelineStateFromInitializer(const FGraphicsPipelineStateInitializer& InPsoInit, uint32 InStencilRef, bool bInApplyAdditionalState)
		: PsoInit(InPsoInit)
		, StencilRef(InStencilRef)
		, bApplyAdditionalState(bInApplyAdditionalState)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};
#endif

FRHICOMMAND_MACRO(FRHICommandDispatchComputeShader)
{
	uint32 ThreadGroupCountX;
	uint32 ThreadGroupCountY;
	uint32 ThreadGroupCountZ;
	FORCEINLINE_DEBUGGABLE FRHICommandDispatchComputeShader(uint32 InThreadGroupCountX, uint32 InThreadGroupCountY, uint32 InThreadGroupCountZ)
		: ThreadGroupCountX(InThreadGroupCountX)
		, ThreadGroupCountY(InThreadGroupCountY)
		, ThreadGroupCountZ(InThreadGroupCountZ)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandDispatchIndirectComputeShader)
{
	FRHIBuffer* ArgumentBuffer;
	uint32 ArgumentOffset;
	FORCEINLINE_DEBUGGABLE FRHICommandDispatchIndirectComputeShader(FRHIBuffer* InArgumentBuffer, uint32 InArgumentOffset)
		: ArgumentBuffer(InArgumentBuffer)
		, ArgumentOffset(InArgumentOffset)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

using FRHIRecordBundleComputeDispatchCallback = TFunction<void(FRHIShaderBundleComputeDispatch& Dispatch)>;
using FRHIRecordBundleGraphicsDispatchCallback = TFunction<void(FRHIShaderBundleGraphicsDispatch& Dispatch)>;

FRHICOMMAND_MACRO(FRHICommandDispatchComputeShaderBundle)
{
	FRHIShaderBundle* ShaderBundle;
	FRHIBuffer* RecordArgBuffer;
	TConstArrayView<FRHIShaderParameterResource> SharedBindlessParameters;
	TArray<FRHIShaderBundleComputeDispatch> Dispatches;
	bool bEmulated;
	FORCEINLINE_DEBUGGABLE FRHICommandDispatchComputeShaderBundle()
		: ShaderBundle(nullptr)
		, RecordArgBuffer(nullptr)
		, bEmulated(true)
	{
	}
	FORCEINLINE_DEBUGGABLE FRHICommandDispatchComputeShaderBundle(
		FRHIShaderBundle* InShaderBundle,
		FRHIBuffer* InRecordArgBuffer,
		TConstArrayView<FRHIShaderParameterResource> InSharedBindlessParameters,
		TConstArrayView<FRHIShaderBundleComputeDispatch> InDispatches,
		bool bInEmulated
	)
		: ShaderBundle(InShaderBundle)
		, RecordArgBuffer(InRecordArgBuffer)
		, SharedBindlessParameters(InSharedBindlessParameters)
		, Dispatches(InDispatches)
		, bEmulated(bInEmulated)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandDispatchGraphicsShaderBundle)
{
	FRHIShaderBundle* ShaderBundle;
	FRHIBuffer* RecordArgBuffer;
	FRHIShaderBundleGraphicsState BundleState;
	TConstArrayView<FRHIShaderParameterResource> SharedBindlessParameters;
	TArray<FRHIShaderBundleGraphicsDispatch> Dispatches;
	bool bEmulated;
	FORCEINLINE_DEBUGGABLE FRHICommandDispatchGraphicsShaderBundle()
		: ShaderBundle(nullptr)
		, RecordArgBuffer(nullptr)
		, bEmulated(true)
	{
	}
	FORCEINLINE_DEBUGGABLE FRHICommandDispatchGraphicsShaderBundle(
		FRHIShaderBundle* InShaderBundle,
		FRHIBuffer* InRecordArgBuffer,
		const FRHIShaderBundleGraphicsState& InBundleState,
		TConstArrayView<FRHIShaderParameterResource> InSharedBindlessParameters,
		TConstArrayView<FRHIShaderBundleGraphicsDispatch> InDispatches,
		bool bInEmulated
	)
		: ShaderBundle(InShaderBundle)
		, RecordArgBuffer(InRecordArgBuffer)
		, BundleState(InBundleState)
		, SharedBindlessParameters(InSharedBindlessParameters)
		, Dispatches(InDispatches)
		, bEmulated(bInEmulated)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetShaderRootConstants)
{
	const FUint32Vector4 Constants;
	FORCEINLINE_DEBUGGABLE FRHICommandSetShaderRootConstants()
		: Constants()
	{
	}
	FORCEINLINE_DEBUGGABLE FRHICommandSetShaderRootConstants(
		const FUint32Vector4 InConstants
	)
		: Constants(InConstants)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandBeginUAVOverlap)
{
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandEndUAVOverlap)
{
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandBeginSpecificUAVOverlap)
{
	TArrayView<FRHIUnorderedAccessView* const> UAVs;
	FORCEINLINE_DEBUGGABLE FRHICommandBeginSpecificUAVOverlap(TArrayView<FRHIUnorderedAccessView* const> InUAVs) : UAVs(InUAVs) {}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandEndSpecificUAVOverlap)
{
	TArrayView<FRHIUnorderedAccessView* const> UAVs;
	FORCEINLINE_DEBUGGABLE FRHICommandEndSpecificUAVOverlap(TArrayView<FRHIUnorderedAccessView* const> InUAVs) : UAVs(InUAVs) {}
	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};

FRHICOMMAND_MACRO(FRHICommandDrawPrimitiveIndirect)
{
	FRHIBuffer* ArgumentBuffer;
	uint32 ArgumentOffset;
	FORCEINLINE_DEBUGGABLE FRHICommandDrawPrimitiveIndirect(FRHIBuffer* InArgumentBuffer, uint32 InArgumentOffset)
		: ArgumentBuffer(InArgumentBuffer)
		, ArgumentOffset(InArgumentOffset)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandDrawIndexedIndirect)
{
	FRHIBuffer* IndexBufferRHI;
	FRHIBuffer* ArgumentsBufferRHI;
	uint32 DrawArgumentsIndex;
	uint32 NumInstances;

	FORCEINLINE_DEBUGGABLE FRHICommandDrawIndexedIndirect(FRHIBuffer* InIndexBufferRHI, FRHIBuffer* InArgumentsBufferRHI, uint32 InDrawArgumentsIndex, uint32 InNumInstances)
		: IndexBufferRHI(InIndexBufferRHI)
		, ArgumentsBufferRHI(InArgumentsBufferRHI)
		, DrawArgumentsIndex(InDrawArgumentsIndex)
		, NumInstances(InNumInstances)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandDrawIndexedPrimitiveIndirect)
{
	FRHIBuffer* IndexBuffer;
	FRHIBuffer* ArgumentsBuffer;
	uint32 ArgumentOffset;

	FORCEINLINE_DEBUGGABLE FRHICommandDrawIndexedPrimitiveIndirect(FRHIBuffer* InIndexBuffer, FRHIBuffer* InArgumentsBuffer, uint32 InArgumentOffset)
		: IndexBuffer(InIndexBuffer)
		, ArgumentsBuffer(InArgumentsBuffer)
		, ArgumentOffset(InArgumentOffset)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandMultiDrawIndexedPrimitiveIndirect)
{
	FRHIBuffer* IndexBuffer;
	FRHIBuffer* ArgumentBuffer;
	uint32 ArgumentOffset;
	FRHIBuffer* CountBuffer;
	uint32 CountBufferOffset;
	uint32 MaxDrawArguments;
	FORCEINLINE_DEBUGGABLE FRHICommandMultiDrawIndexedPrimitiveIndirect(FRHIBuffer* InIndexBuffer, FRHIBuffer* InArgumentBuffer, uint32 InArgumentOffset, FRHIBuffer* InCountBuffer, uint32 InCountBufferOffset, uint32 InMaxDrawArguments)
		: IndexBuffer(InIndexBuffer)
		, ArgumentBuffer(InArgumentBuffer)
		, ArgumentOffset(InArgumentOffset)
		, CountBuffer(InCountBuffer)
		, CountBufferOffset(InCountBufferOffset)
		, MaxDrawArguments(InMaxDrawArguments)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};

FRHICOMMAND_MACRO(FRHICommandDispatchMeshShader)
{
	uint32 ThreadGroupCountX;
	uint32 ThreadGroupCountY;
	uint32 ThreadGroupCountZ;

	FORCEINLINE_DEBUGGABLE FRHICommandDispatchMeshShader(uint32 InThreadGroupCountX, uint32 InThreadGroupCountY, uint32 InThreadGroupCountZ)
		: ThreadGroupCountX(InThreadGroupCountX)
		, ThreadGroupCountY(InThreadGroupCountY)
		, ThreadGroupCountZ(InThreadGroupCountZ)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};

FRHICOMMAND_MACRO(FRHICommandDispatchIndirectMeshShader)
{
	FRHIBuffer* ArgumentBuffer;
	uint32 ArgumentOffset;

	FORCEINLINE_DEBUGGABLE FRHICommandDispatchIndirectMeshShader(FRHIBuffer * InArgumentBuffer, uint32 InArgumentOffset)
		: ArgumentBuffer(InArgumentBuffer)
		, ArgumentOffset(InArgumentOffset)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetDepthBounds)
{
	float MinDepth;
	float MaxDepth;

	FORCEINLINE_DEBUGGABLE FRHICommandSetDepthBounds(float InMinDepth, float InMaxDepth)
		: MinDepth(InMinDepth)
		, MaxDepth(InMaxDepth)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetShadingRate)
{
	EVRSShadingRate   ShadingRate;
	EVRSRateCombiner  Combiner;

	FORCEINLINE_DEBUGGABLE FRHICommandSetShadingRate(EVRSShadingRate InShadingRate, EVRSRateCombiner InCombiner)
		: ShadingRate(InShadingRate),
		Combiner(InCombiner)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandClearUAVFloat)
{
	FRHIUnorderedAccessView* UnorderedAccessViewRHI;
	FVector4f Values;

	FORCEINLINE_DEBUGGABLE FRHICommandClearUAVFloat(FRHIUnorderedAccessView* InUnorderedAccessViewRHI, const FVector4f& InValues)
		: UnorderedAccessViewRHI(InUnorderedAccessViewRHI)
		, Values(InValues)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandClearUAVUint)
{
	FRHIUnorderedAccessView* UnorderedAccessViewRHI;
	FUintVector4 Values;

	FORCEINLINE_DEBUGGABLE FRHICommandClearUAVUint(FRHIUnorderedAccessView* InUnorderedAccessViewRHI, const FUintVector4& InValues)
		: UnorderedAccessViewRHI(InUnorderedAccessViewRHI)
		, Values(InValues)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandCopyTexture)
{
	FRHICopyTextureInfo CopyInfo;
	FRHITexture* SourceTexture;
	FRHITexture* DestTexture;

	FORCEINLINE_DEBUGGABLE FRHICommandCopyTexture(FRHITexture* InSourceTexture, FRHITexture* InDestTexture, const FRHICopyTextureInfo& InCopyInfo)
		: CopyInfo(InCopyInfo)
		, SourceTexture(InSourceTexture)
		, DestTexture(InDestTexture)
	{
		ensure(SourceTexture);
		ensure(DestTexture);
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandResummarizeHTile)
{
	FRHITexture* DepthTexture;

	FORCEINLINE_DEBUGGABLE FRHICommandResummarizeHTile(FRHITexture* InDepthTexture)
	: DepthTexture(InDepthTexture)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandBeginTransitions)
{
	TArrayView<const FRHITransition*> Transitions;

	FRHICommandBeginTransitions(TArrayView<const FRHITransition*> InTransitions)
		: Transitions(InTransitions)
	{
	}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandEndTransitions)
{
	TArrayView<const FRHITransition*> Transitions;

	FRHICommandEndTransitions(TArrayView<const FRHITransition*> InTransitions)
		: Transitions(InTransitions)
	{
	}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandResourceTransition)
{
	FRHITransition* Transition;

	FRHICommandResourceTransition(FRHITransition* InTransition)
		: Transition(InTransition)
	{
	}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetTrackedAccess)
{
	TArrayView<const FRHITrackedAccessInfo> Infos;

	FRHICommandSetTrackedAccess(TArrayView<const FRHITrackedAccessInfo> InInfos)
		: Infos(InInfos)
	{
	}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetAsyncComputeBudget)
{
	EAsyncComputeBudget Budget;

	FORCEINLINE_DEBUGGABLE FRHICommandSetAsyncComputeBudget(EAsyncComputeBudget InBudget)
		: Budget(InBudget)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandCopyToStagingBuffer)
{
	FRHIBuffer* SourceBuffer;
	FRHIStagingBuffer* DestinationStagingBuffer;
	uint32 Offset;
	uint32 NumBytes;

	FORCEINLINE_DEBUGGABLE FRHICommandCopyToStagingBuffer(FRHIBuffer* InSourceBuffer, FRHIStagingBuffer* InDestinationStagingBuffer, uint32 InOffset, uint32 InNumBytes)
		: SourceBuffer(InSourceBuffer)
		, DestinationStagingBuffer(InDestinationStagingBuffer)
		, Offset(InOffset)
		, NumBytes(InNumBytes)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandWriteGPUFence)
{
	FRHIGPUFence* Fence;

	FORCEINLINE_DEBUGGABLE FRHICommandWriteGPUFence(FRHIGPUFence* InFence)
		: Fence(InFence)
	{
		if (Fence)
		{
			Fence->NumPendingWriteCommands.Increment();
		}
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetStaticUniformBuffers)
{
	FUniformBufferStaticBindings UniformBuffers;

	FORCEINLINE_DEBUGGABLE FRHICommandSetStaticUniformBuffers(const FUniformBufferStaticBindings & InUniformBuffers)
		: UniformBuffers(InUniformBuffers)
	{}

	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetStaticUniformBuffer)
{
	FRHIUniformBuffer* Buffer;
	FUniformBufferStaticSlot Slot;

	FORCEINLINE_DEBUGGABLE FRHICommandSetStaticUniformBuffer(FUniformBufferStaticSlot InSlot, FRHIUniformBuffer* InBuffer)
		: Buffer(InBuffer)
		, Slot(InSlot)
	{}

	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetUniformBufferDynamicOffset)
{
	uint32 Offset;
	FUniformBufferStaticSlot Slot;

	FORCEINLINE_DEBUGGABLE FRHICommandSetUniformBufferDynamicOffset(FUniformBufferStaticSlot InSlot, uint32 InOffset)
		: Offset(InOffset)
		, Slot(InSlot)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandBeginRenderQuery)
{
	FRHIRenderQuery* RenderQuery;

	FORCEINLINE_DEBUGGABLE FRHICommandBeginRenderQuery(FRHIRenderQuery* InRenderQuery)
		: RenderQuery(InRenderQuery)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandEndRenderQuery)
{
	FRHIRenderQuery* RenderQuery;

	FORCEINLINE_DEBUGGABLE FRHICommandEndRenderQuery(FRHIRenderQuery* InRenderQuery)
		: RenderQuery(InRenderQuery)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandCalibrateTimers)
{
	FRHITimestampCalibrationQuery* CalibrationQuery;

	FORCEINLINE_DEBUGGABLE FRHICommandCalibrateTimers(FRHITimestampCalibrationQuery * CalibrationQuery)
		: CalibrationQuery(CalibrationQuery)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};

FRHICOMMAND_MACRO(FRHICommandPostExternalCommandsReset)
{
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandBeginDrawingViewport)
{
	FRHIViewport* Viewport;
	FRHITexture* RenderTargetRHI;

	FORCEINLINE_DEBUGGABLE FRHICommandBeginDrawingViewport(FRHIViewport* InViewport, FRHITexture* InRenderTargetRHI)
		: Viewport(InViewport)
		, RenderTargetRHI(InRenderTargetRHI)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandEndDrawingViewport)
{
	FRHIViewport* Viewport;
	bool bPresent;
	bool bLockToVsync;

	FORCEINLINE_DEBUGGABLE FRHICommandEndDrawingViewport(FRHIViewport* InViewport, bool InbPresent, bool InbLockToVsync)
		: Viewport(InViewport)
		, bPresent(InbPresent)
		, bLockToVsync(InbLockToVsync)
	{
	}
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandDiscardRenderTargets)
{
	uint32 ColorBitMask;
	bool Depth;
	bool Stencil;

	FORCEINLINE_DEBUGGABLE FRHICommandDiscardRenderTargets(bool InDepth, bool InStencil, uint32 InColorBitMask)
		: ColorBitMask(InColorBitMask)
		, Depth(InDepth)
		, Stencil(InStencil)
	{
	}
	
	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandCopyBufferRegion)
{
	FRHIBuffer* DestBuffer;
	uint64 DstOffset;
	FRHIBuffer* SourceBuffer;
	uint64 SrcOffset;
	uint64 NumBytes;

	explicit FRHICommandCopyBufferRegion(FRHIBuffer* InDestBuffer, uint64 InDstOffset, FRHIBuffer* InSourceBuffer, uint64 InSrcOffset, uint64 InNumBytes)
		: DestBuffer(InDestBuffer)
		, DstOffset(InDstOffset)
		, SourceBuffer(InSourceBuffer)
		, SrcOffset(InSrcOffset)
		, NumBytes(InNumBytes)
	{}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_UNNAMED(FRHICommandBindAccelerationStructureMemory)
{
	FRHIRayTracingScene* Scene;
	FRHIBuffer* Buffer;
	uint32 BufferOffset;

	FRHICommandBindAccelerationStructureMemory(FRHIRayTracingScene* InScene, FRHIBuffer* InBuffer, uint32 InBufferOffset)
		: Scene(InScene)
		, Buffer(InBuffer)
		, BufferOffset(InBufferOffset)
	{}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_UNNAMED(FRHICommandBuildAccelerationStructure)
{
	FRayTracingSceneBuildParams SceneBuildParams;

	explicit FRHICommandBuildAccelerationStructure(FRayTracingSceneBuildParams InSceneBuildParams)
		: SceneBuildParams(MoveTemp(InSceneBuildParams))
	{}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandCommitRayTracingBindings)
{
	FRHIRayTracingScene* Scene;

	explicit FRHICommandCommitRayTracingBindings(FRHIRayTracingScene* InScene)
		: Scene(InScene)
	{}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandCommitShaderBindingTable)
{
	FRHIShaderBindingTable* SBT;

	explicit FRHICommandCommitShaderBindingTable(FRHIShaderBindingTable* InSBT)
		: SBT(InSBT)
	{}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandClearRayTracingBindings)
{
	FRHIRayTracingScene* Scene;

	explicit FRHICommandClearRayTracingBindings(FRHIRayTracingScene* InScene)
		: Scene(InScene)
	{}

	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};

FRHICOMMAND_MACRO(FRHICommandClearShaderBindingTable)
{
	FRHIShaderBindingTable* SBT;

	explicit FRHICommandClearShaderBindingTable(FRHIShaderBindingTable* InSBT)
		: SBT(InSBT)
	{}

	RHI_EXECUTE_API void Execute(FRHICommandListBase & CmdList);
};

FRHICOMMAND_UNNAMED(FRHICommandBuildAccelerationStructures)
{
	TConstArrayView<FRayTracingGeometryBuildParams> Params;
	FRHIBufferRange ScratchBufferRange;
	FRHIBuffer* ScratchBuffer;

	explicit FRHICommandBuildAccelerationStructures(TConstArrayView<FRayTracingGeometryBuildParams> InParams, const FRHIBufferRange& ScratchBufferRange)
		: Params(InParams)
		, ScratchBufferRange(ScratchBufferRange)
		, ScratchBuffer(ScratchBufferRange.Buffer)
	{}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandRayTraceDispatch)
{
	FRayTracingPipelineState* Pipeline;
	FRHIRayTracingScene* Scene;
	FRHIShaderBindingTable* SBT;
	FRayTracingShaderBindings GlobalResourceBindings;
	FRHIRayTracingShader* RayGenShader;
	FRHIBuffer* ArgumentBuffer;
	uint32 ArgumentOffset;
	uint32 Width;
	uint32 Height;

	FRHICommandRayTraceDispatch(FRayTracingPipelineState* InPipeline, FRHIRayTracingShader* InRayGenShader, FRHIRayTracingScene* InScene, const FRayTracingShaderBindings& InGlobalResourceBindings, uint32 InWidth, uint32 InHeight)
		: Pipeline(InPipeline)
		, Scene(InScene)
		, SBT(nullptr)
		, GlobalResourceBindings(InGlobalResourceBindings)
		, RayGenShader(InRayGenShader)
		, ArgumentBuffer(nullptr)
		, ArgumentOffset(0)
		, Width(InWidth)
		, Height(InHeight)
	{}

	FRHICommandRayTraceDispatch(FRayTracingPipelineState* InPipeline, FRHIRayTracingShader* InRayGenShader, FRHIShaderBindingTable* InSBT, const FRayTracingShaderBindings& InGlobalResourceBindings, uint32 InWidth, uint32 InHeight)
		: Pipeline(InPipeline)
		, Scene(nullptr)
		, SBT(InSBT)
		, GlobalResourceBindings(InGlobalResourceBindings)
		, RayGenShader(InRayGenShader)
		, ArgumentBuffer(nullptr)
		, ArgumentOffset(0)
		, Width(InWidth)
		, Height(InHeight)
	{}

	FRHICommandRayTraceDispatch(FRayTracingPipelineState* InPipeline, FRHIRayTracingShader* InRayGenShader, FRHIRayTracingScene* InScene, const FRayTracingShaderBindings& InGlobalResourceBindings, FRHIBuffer* InArgumentBuffer, uint32 InArgumentOffset)
		: Pipeline(InPipeline)
		, Scene(InScene)
		, SBT(nullptr)
		, GlobalResourceBindings(InGlobalResourceBindings)
		, RayGenShader(InRayGenShader)
		, ArgumentBuffer(InArgumentBuffer)
		, ArgumentOffset(InArgumentOffset)
		, Width(0)
		, Height(0)
	{}

	FRHICommandRayTraceDispatch(FRayTracingPipelineState* InPipeline, FRHIRayTracingShader* InRayGenShader, FRHIShaderBindingTable* InSBT, const FRayTracingShaderBindings& InGlobalResourceBindings, FRHIBuffer* InArgumentBuffer, uint32 InArgumentOffset)
		: Pipeline(InPipeline)
		, Scene(nullptr)
		, SBT(InSBT)
		, GlobalResourceBindings(InGlobalResourceBindings)
		, RayGenShader(InRayGenShader)
		, ArgumentBuffer(InArgumentBuffer)
		, ArgumentOffset(InArgumentOffset)
		, Width(0)
		, Height(0)
	{}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

FRHICOMMAND_MACRO(FRHICommandSetBindingsOnShaderBindingTable)
{
	FRHIShaderBindingTable* SBT = nullptr;
	FRHIRayTracingScene* Scene = nullptr;
	FRayTracingPipelineState* Pipeline = nullptr;
	int32 NumBindings = -1;
	const FRayTracingLocalShaderBindings* Bindings = nullptr;
	ERayTracingBindingType BindingType = ERayTracingBindingType::HitGroup;

	// Bindings Batch
	FRHICommandSetBindingsOnShaderBindingTable(FRHIRayTracingScene* InScene, FRayTracingPipelineState* InPipeline, uint32 InNumBindings, const FRayTracingLocalShaderBindings* InBindings, ERayTracingBindingType InBindingType)
		: Scene(InScene)
		, Pipeline(InPipeline)
		, NumBindings(InNumBindings)
		, Bindings(InBindings)
		, BindingType(InBindingType)
	{

	}

	// Bindings Batch
	FRHICommandSetBindingsOnShaderBindingTable(FRHIShaderBindingTable* InSBT, FRayTracingPipelineState* InPipeline, uint32 InNumBindings, const FRayTracingLocalShaderBindings* InBindings, ERayTracingBindingType InBindingType)
		: SBT(InSBT)
		, Pipeline(InPipeline)
		, NumBindings(InNumBindings)
		, Bindings(InBindings)
		, BindingType(InBindingType)
	{

	}

	RHI_EXECUTE_API void Execute(FRHICommandListBase& CmdList);
};

template<> RHI_EXECUTE_API void FRHICommandSetShaderParameters           <FRHIComputeShader>::Execute(FRHICommandListBase& CmdList);
template<> RHI_EXECUTE_API void FRHICommandSetShaderUnbinds              <FRHIComputeShader>::Execute(FRHICommandListBase& CmdList);

extern RHI_API FRHIComputePipelineState*	ExecuteSetComputePipelineState(FComputePipelineState* ComputePipelineState);
extern RHI_API FRHIGraphicsPipelineState*	ExecuteSetGraphicsPipelineState(class FGraphicsPipelineState* GraphicsPipelineState);
extern RHI_API FComputePipelineState*		FindComputePipelineState(FRHIComputeShader* ComputeShader, bool bVerifyUse = true);
extern RHI_API FComputePipelineState*		GetComputePipelineState(FRHIComputeCommandList& RHICmdList, FRHIComputeShader* ComputeShader, bool bVerifyUse = true);
extern RHI_API FGraphicsPipelineState*		FindGraphicsPipelineState(const FGraphicsPipelineStateInitializer& Initializer, bool bVerifyUse = true);
extern RHI_API FGraphicsPipelineState*		GetGraphicsPipelineState(FRHICommandList& RHICmdList, const FGraphicsPipelineStateInitializer& Initializer, bool bVerifyUse = true);
extern RHI_API FRHIComputePipelineState*	GetRHIComputePipelineState(FComputePipelineState*);
extern RHI_API FRHIWorkGraphPipelineState*	GetRHIWorkGraphPipelineState(FWorkGraphPipelineState*);
extern RHI_API FRHIRayTracingPipelineState*	GetRHIRayTracingPipelineState(FRayTracingPipelineState*);
extern RHI_API uint32					    GetRHIRayTracingPipelineStateMaxLocalBindingDataSize(FRayTracingPipelineState*);

class FRHIComputeCommandList : public FRHICommandListBase
{
protected:
	void OnBoundShaderChanged(FRHIComputeShader* InBoundComputeShaderRHI)
	{
		PersistentState.BoundComputeShaderRHI = InBoundComputeShaderRHI;
	}

	FRHIComputeCommandList(FRHIGPUMask GPUMask, bool bImmediate)
		: FRHICommandListBase(GPUMask, bImmediate)
	{}

public:
	static inline FRHIComputeCommandList& Get(FRHICommandListBase& RHICmdList)
	{
		return static_cast<FRHIComputeCommandList&>(RHICmdList);
	}

	FRHIComputeCommandList(FRHIGPUMask GPUMask = FRHIGPUMask::All())
		: FRHICommandListBase(GPUMask, false)
	{}

	FRHIComputeCommandList(FRHICommandListBase&& Other)
		: FRHICommandListBase(MoveTemp(Other))
	{}

	template <typename LAMBDA>
	FORCEINLINE_DEBUGGABLE void EnqueueLambda(const TCHAR* LambdaName, LAMBDA&& Lambda)
	{
		if (IsBottomOfPipe())
		{
			Lambda(*this);
		}
		else
		{
			ALLOC_COMMAND(TRHILambdaCommand<FRHIComputeCommandList, LAMBDA>)(Forward<LAMBDA>(Lambda), LambdaName);
		}
	}

	// Same as EnqueueLambda, but skips the Insights marker surrounding the lambda. Used by the RHI breadcrumb system.
	template <typename LAMBDA>
	FORCEINLINE_DEBUGGABLE void EnqueueLambda_NoMarker(LAMBDA&& Lambda)
	{
		if (IsBottomOfPipe())
		{
			Lambda(*this);
		}
		else
		{
			ALLOC_COMMAND(TRHILambdaCommand_NoMarker<FRHIComputeCommandList, LAMBDA>)(Forward<LAMBDA>(Lambda));
		}
	}

	template <typename LAMBDA>
	FORCEINLINE_DEBUGGABLE void EnqueueLambda(LAMBDA&& Lambda)
	{
		FRHIComputeCommandList::EnqueueLambda(TEXT("TRHILambdaCommand"), Forward<LAMBDA>(Lambda));
	}

	inline FRHIComputeShader* GetBoundComputeShader() const { return PersistentState.BoundComputeShaderRHI; }

	FORCEINLINE_DEBUGGABLE void SetStaticUniformBuffers(const FUniformBufferStaticBindings& UniformBuffers)
	{
		if (Bypass())
		{
			GetComputeContext().RHISetStaticUniformBuffers(UniformBuffers);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetStaticUniformBuffers)(UniformBuffers);
	}

	FORCEINLINE_DEBUGGABLE void SetStaticUniformBuffer(FUniformBufferStaticSlot Slot, FRHIUniformBuffer* Buffer)
	{
		if (Bypass())
		{
			GetComputeContext().RHISetStaticUniformBuffer(Slot, Buffer);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetStaticUniformBuffer)(Slot, Buffer);
	}

	FORCEINLINE_DEBUGGABLE void SetUniformBufferDynamicOffset(FUniformBufferStaticSlot Slot, uint32 Offset)
	{
		if (Bypass())
		{
			GetContext().RHISetUniformBufferDynamicOffset(Slot, Offset);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetUniformBufferDynamicOffset)(Slot, Offset);
	}

	FORCEINLINE_DEBUGGABLE void SetShaderParameters(
		FRHIComputeShader* InShader
		, TConstArrayView<uint8> InParametersData
		, TConstArrayView<FRHIShaderParameter> InParameters
		, TConstArrayView<FRHIShaderParameterResource> InResourceParameters
		, TConstArrayView<FRHIShaderParameterResource> InBindlessParameters
	)
	{
		ValidateBoundShader(InShader);

		if (Bypass())
		{
			GetComputeContext().RHISetShaderParameters(InShader, InParametersData, InParameters, InResourceParameters, InBindlessParameters);
			return;
		}

		ALLOC_COMMAND(FRHICommandSetShaderParameters<FRHIComputeShader>)(
			InShader
			, AllocArray(InParametersData)
			, AllocArray(InParameters)
			, AllocArray(InResourceParameters)
			, AllocArray(InBindlessParameters)
		);
	}

	FORCEINLINE_DEBUGGABLE void SetBatchedShaderParameters(FRHIComputeShader* InShader, FRHIBatchedShaderParameters& InBatchedParameters)
	{
		if (InBatchedParameters.HasParameters())
		{
			ON_SCOPE_EXIT
			{
				InBatchedParameters.Reset();
			};

			if (Bypass())
			{
				GetComputeContext().RHISetShaderParameters(InShader, InBatchedParameters.ParametersData, InBatchedParameters.Parameters, InBatchedParameters.ResourceParameters, InBatchedParameters.BindlessParameters);
				return;
			}

			ValidateBoundShader(InShader);
			ValidateShaderParameters(InBatchedParameters);
			ALLOC_COMMAND(FRHICommandSetShaderParameters<FRHIComputeShader>)(InShader, InBatchedParameters.ParametersData, InBatchedParameters.Parameters, InBatchedParameters.ResourceParameters, InBatchedParameters.BindlessParameters);
		}
	}

	FORCEINLINE_DEBUGGABLE void SetShaderUnbinds(FRHIComputeShader* InShader, TConstArrayView<FRHIShaderParameterUnbind> InUnbinds)
	{
		if (NeedsShaderUnbinds())
		{
			ValidateBoundShader(InShader);

			if (Bypass())
			{
				GetComputeContext().RHISetShaderUnbinds(InShader, InUnbinds);
				return;
			}

			ALLOC_COMMAND(FRHICommandSetShaderUnbinds<FRHIComputeShader>)(InShader, AllocArray(InUnbinds));
		}
	}

	FORCEINLINE_DEBUGGABLE void SetBatchedShaderUnbinds(FRHIComputeShader* InShader, FRHIBatchedShaderUnbinds& InBatchedUnbinds)
	{
		if (InBatchedUnbinds.HasParameters())
		{
			SetShaderUnbinds(InShader, InBatchedUnbinds.Unbinds);

			InBatchedUnbinds.Reset();
		}
	}

	FORCEINLINE_DEBUGGABLE void SetComputePipelineState(FComputePipelineState* ComputePipelineState, FRHIComputeShader* ComputeShader)
	{
		OnBoundShaderChanged(ComputeShader);
		if (Bypass())
		{
			FRHIComputePipelineState* RHIComputePipelineState = ExecuteSetComputePipelineState(ComputePipelineState);
			GetComputeContext().RHISetComputePipelineState(RHIComputePipelineState);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetComputePipelineState)(ComputePipelineState);
	}

	FORCEINLINE_DEBUGGABLE void SetAsyncComputeBudget(EAsyncComputeBudget Budget)
	{
		if (Bypass())
		{
			GetComputeContext().RHISetAsyncComputeBudget(Budget);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetAsyncComputeBudget)(Budget);
	}

	FORCEINLINE_DEBUGGABLE void DispatchComputeShader(uint32 ThreadGroupCountX, uint32 ThreadGroupCountY, uint32 ThreadGroupCountZ)
	{
		if (Bypass())
		{
			GetComputeContext().RHIDispatchComputeShader(ThreadGroupCountX, ThreadGroupCountY, ThreadGroupCountZ);
			return;
		}
		ALLOC_COMMAND(FRHICommandDispatchComputeShader)(ThreadGroupCountX, ThreadGroupCountY, ThreadGroupCountZ);
	}

	FORCEINLINE_DEBUGGABLE void DispatchIndirectComputeShader(FRHIBuffer* ArgumentBuffer, uint32 ArgumentOffset)
	{
		if (Bypass())
		{
			GetComputeContext().RHIDispatchIndirectComputeShader(ArgumentBuffer, ArgumentOffset);
			return;
		}
		ALLOC_COMMAND(FRHICommandDispatchIndirectComputeShader)(ArgumentBuffer, ArgumentOffset);
	}

	FORCEINLINE_DEBUGGABLE void ClearUAVFloat(FRHIUnorderedAccessView* UnorderedAccessViewRHI, const FVector4f& Values)
	{
		if (Bypass())
		{
			GetComputeContext().RHIClearUAVFloat(UnorderedAccessViewRHI, Values);
			return;
		}
		ALLOC_COMMAND(FRHICommandClearUAVFloat)(UnorderedAccessViewRHI, Values);
	}

	FORCEINLINE_DEBUGGABLE void ClearUAVUint(FRHIUnorderedAccessView* UnorderedAccessViewRHI, const FUintVector4& Values)
	{
		if (Bypass())
		{
			GetComputeContext().RHIClearUAVUint(UnorderedAccessViewRHI, Values);
			return;
		}
		ALLOC_COMMAND(FRHICommandClearUAVUint)(UnorderedAccessViewRHI, Values);
	}

	FORCEINLINE_DEBUGGABLE void BeginTransitions(TArrayView<const FRHITransition*> Transitions)
	{
#if WITH_PROFILEGPU
		extern RHI_API TAutoConsoleVariable<int32> GProfileGPUTransitions;
		RHI_BREADCRUMB_EVENT_CONDITIONAL(*this, GProfileGPUTransitions.GetValueOnAnyThread() != 0, "RHIBeginTransitions");
#endif

		if (Bypass())
		{
			GetComputeContext().RHIBeginTransitions(Transitions);

			for (const FRHITransition* Transition : Transitions)
			{
				Transition->MarkBegin(GetPipeline());
			}
		}
		else
		{
			// Copy the transition array into the command list
			FRHITransition** DstTransitionArray = (FRHITransition**)Alloc(sizeof(FRHITransition*) * Transitions.Num(), alignof(FRHITransition*));
			FMemory::Memcpy(DstTransitionArray, Transitions.GetData(), sizeof(FRHITransition*) * Transitions.Num());

			ALLOC_COMMAND(FRHICommandBeginTransitions)(MakeArrayView((const FRHITransition**)DstTransitionArray, Transitions.Num()));
		}
	}

	FORCEINLINE_DEBUGGABLE void EndTransitions(TArrayView<const FRHITransition*> Transitions)
	{
#if WITH_PROFILEGPU
		extern RHI_API TAutoConsoleVariable<int32> GProfileGPUTransitions;
		RHI_BREADCRUMB_EVENT_CONDITIONAL(*this, GProfileGPUTransitions.GetValueOnAnyThread() != 0, "RHIEndTransitions");
#endif

		if (Bypass())
		{
			GetComputeContext().RHIEndTransitions(Transitions);

			for (const FRHITransition* Transition : Transitions)
			{
				Transition->MarkEnd(GetPipeline());
			}
		}
		else
		{
			// Copy the transition array into the command list
			FRHITransition** DstTransitionArray = (FRHITransition**)Alloc(sizeof(FRHITransition*) * Transitions.Num(), alignof(FRHITransition*));
			FMemory::Memcpy(DstTransitionArray, Transitions.GetData(), sizeof(FRHITransition*) * Transitions.Num());

			ALLOC_COMMAND(FRHICommandEndTransitions)(MakeArrayView((const FRHITransition**)DstTransitionArray, Transitions.Num()));
		}
	}

	RHI_API void Transition(TArrayView<const FRHITransitionInfo> Infos, ERHITransitionCreateFlags CreateFlags = ERHITransitionCreateFlags::None);

	FORCEINLINE_DEBUGGABLE void BeginTransition(const FRHITransition* Transition)
	{
		BeginTransitions(MakeArrayView(&Transition, 1));
	}

	FORCEINLINE_DEBUGGABLE void EndTransition(const FRHITransition* Transition)
	{
		EndTransitions(MakeArrayView(&Transition, 1));
	}

	FORCEINLINE_DEBUGGABLE void Transition(const FRHITransitionInfo& Info, ERHITransitionCreateFlags CreateFlags = ERHITransitionCreateFlags::None)
	{
		Transition(MakeArrayView(&Info, 1), CreateFlags);
	}

	//
	// Performs an immediate transition with the option of broadcasting to multiple pipelines.
	// Uses both the immediate and async compute contexts. Falls back to graphics-only if async compute is not supported.
	//
	RHI_API void Transition(TArrayView<const FRHITransitionInfo> Infos, ERHIPipeline SrcPipelines, ERHIPipeline DstPipelines, ERHITransitionCreateFlags TransitionCreateFlags = ERHITransitionCreateFlags::None);

	FORCEINLINE_DEBUGGABLE void SetTrackedAccess(TArrayView<const FRHITrackedAccessInfo> Infos)
	{
		bUsesSetTrackedAccess = true;

		if (Bypass())
		{
			for (const FRHITrackedAccessInfo& Info : Infos)
			{
				GetComputeContext().SetTrackedAccess(Info);
			}
		}
		else
		{
			ALLOC_COMMAND(FRHICommandSetTrackedAccess)(AllocArray(Infos));
		}
	}

	FORCEINLINE_DEBUGGABLE void SetTrackedAccess(TArrayView<const FRHITransitionInfo> Infos)
	{
		for (const FRHITransitionInfo& Info : Infos)
		{
			if (FRHIViewableResource* Resource = GetViewableResource(Info))
			{
				SetTrackedAccess({ FRHITrackedAccessInfo(Resource, Info.AccessAfter) });
			}
		}
	}

	FORCEINLINE_DEBUGGABLE void SetShaderRootConstants(const FUint32Vector4& Constants)
	{
		if (Bypass())
		{
			GetContext().RHISetShaderRootConstants(Constants);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetShaderRootConstants)(Constants);
	}

	FORCEINLINE_DEBUGGABLE void SetComputeShaderRootConstants(const FUint32Vector4& Constants)
	{
		if (Bypass())
		{
			GetComputeContext().RHISetShaderRootConstants(Constants);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetShaderRootConstants)(Constants);
	}

	FORCEINLINE_DEBUGGABLE void DispatchComputeShaderBundle(
		FRHIShaderBundle* ShaderBundle,
		FRHIBuffer* RecordArgBuffer,
		TConstArrayView<FRHIShaderParameterResource> SharedBindlessParameters,
		TConstArrayView<FRHIShaderBundleComputeDispatch> Dispatches,
		bool bEmulated
	)
	{
		bUsesShaderBundles = true;

		if (Bypass())
		{
			GetContext().RHIDispatchComputeShaderBundle(ShaderBundle, RecordArgBuffer, SharedBindlessParameters, Dispatches, bEmulated);
			return;
		}
		ValidateShaderBundleComputeDispatch(Dispatches);
		ALLOC_COMMAND(FRHICommandDispatchComputeShaderBundle)(ShaderBundle, RecordArgBuffer, SharedBindlessParameters, Dispatches, bEmulated);
	}

	FORCEINLINE_DEBUGGABLE void DispatchComputeShaderBundle(
		TFunction<void(FRHICommandDispatchComputeShaderBundle&)>&& RecordCallback
	)
	{
		bUsesShaderBundles = true;

		// Need to explicitly enqueue the RHI command so we can avoid an unnecessary copy of the dispatches array.
		if (Bypass())
		{
			FRHICommandDispatchComputeShaderBundle DispatchBundleCommand;
			RecordCallback(DispatchBundleCommand);
			DispatchBundleCommand.Execute(*this);
		}
		else
		{
			FRHICommandDispatchComputeShaderBundle& DispatchBundleCommand = *ALLOC_COMMAND_CL(*this, FRHICommandDispatchComputeShaderBundle);
			RecordCallback(DispatchBundleCommand);
			ValidateShaderBundleComputeDispatch(DispatchBundleCommand.Dispatches);
		}
	}

	FORCEINLINE_DEBUGGABLE void DispatchGraphicsShaderBundle(
		FRHIShaderBundle* ShaderBundle,
		FRHIBuffer* RecordArgBuffer,
		const FRHIShaderBundleGraphicsState& BundleState,
		TConstArrayView<FRHIShaderParameterResource> SharedBindlessParameters,
		TConstArrayView<FRHIShaderBundleGraphicsDispatch> Dispatches,
		bool bEmulated
	)
	{
		bUsesShaderBundles = true;

		if (Bypass())
		{
			GetContext().RHIDispatchGraphicsShaderBundle(ShaderBundle, RecordArgBuffer, BundleState, SharedBindlessParameters, Dispatches, bEmulated);
			return;
		}
		ALLOC_COMMAND(FRHICommandDispatchGraphicsShaderBundle)(ShaderBundle, RecordArgBuffer, BundleState, SharedBindlessParameters, Dispatches, bEmulated);
	}

	FORCEINLINE_DEBUGGABLE void DispatchGraphicsShaderBundle(
		TFunction<void(FRHICommandDispatchGraphicsShaderBundle&)>&& RecordCallback
	)
	{
		bUsesShaderBundles = true;

		// Need to explicitly enqueue the RHI command so we can avoid an unnecessary copy of the dispatches array.
		if (Bypass())
		{
			FRHICommandDispatchGraphicsShaderBundle DispatchBundleCommand;
			RecordCallback(DispatchBundleCommand);
			DispatchBundleCommand.Execute(*this);
		}
		else
		{
			FRHICommandDispatchGraphicsShaderBundle& DispatchBundleCommand = *ALLOC_COMMAND_CL(*this, FRHICommandDispatchGraphicsShaderBundle);
			RecordCallback(DispatchBundleCommand);
		}
	}

	FORCEINLINE_DEBUGGABLE void BeginUAVOverlap()
	{
		if (Bypass())
		{
			GetComputeContext().RHIBeginUAVOverlap();
			return;
		}
		ALLOC_COMMAND(FRHICommandBeginUAVOverlap)();
	}

	FORCEINLINE_DEBUGGABLE void EndUAVOverlap()
	{
		if (Bypass())
		{
			GetComputeContext().RHIEndUAVOverlap();
			return;
		}
		ALLOC_COMMAND(FRHICommandEndUAVOverlap)();
	}

	FORCEINLINE_DEBUGGABLE void BeginUAVOverlap(FRHIUnorderedAccessView* UAV)
	{
		FRHIUnorderedAccessView* UAVs[1] = { UAV };
		BeginUAVOverlap(MakeArrayView(UAVs, 1));
	}

	FORCEINLINE_DEBUGGABLE void EndUAVOverlap(FRHIUnorderedAccessView* UAV)
	{
		FRHIUnorderedAccessView* UAVs[1] = { UAV };
		EndUAVOverlap(MakeArrayView(UAVs, 1));
	}

	FORCEINLINE_DEBUGGABLE void BeginUAVOverlap(TArrayView<FRHIUnorderedAccessView* const> UAVs)
	{
		if (Bypass())
		{
			GetComputeContext().RHIBeginUAVOverlap(UAVs);
			return;
		}

		const uint32 AllocSize = UAVs.Num() * sizeof(FRHIUnorderedAccessView*);
		FRHIUnorderedAccessView** InlineUAVs = (FRHIUnorderedAccessView**)Alloc(AllocSize, alignof(FRHIUnorderedAccessView*));
		FMemory::Memcpy(InlineUAVs, UAVs.GetData(), AllocSize);
		ALLOC_COMMAND(FRHICommandBeginSpecificUAVOverlap)(MakeArrayView(InlineUAVs, UAVs.Num()));
	}

	FORCEINLINE_DEBUGGABLE void EndUAVOverlap(TArrayView<FRHIUnorderedAccessView* const> UAVs)
	{
		if (Bypass())
		{
			GetComputeContext().RHIEndUAVOverlap(UAVs);
			return;
		}

		const uint32 AllocSize = UAVs.Num() * sizeof(FRHIUnorderedAccessView*);
		FRHIUnorderedAccessView** InlineUAVs = (FRHIUnorderedAccessView**)Alloc(AllocSize, alignof(FRHIUnorderedAccessView*));
		FMemory::Memcpy(InlineUAVs, UAVs.GetData(), AllocSize);
		ALLOC_COMMAND(FRHICommandEndSpecificUAVOverlap)(MakeArrayView(InlineUAVs, UAVs.Num()));
	}

#if WITH_RHI_BREADCRUMBS
	FORCEINLINE_DEBUGGABLE FRHIBreadcrumbAllocator& GetBreadcrumbAllocator()
	{
		if (!BreadcrumbAllocator.IsValid())
		{
			BreadcrumbAllocator = MakeShared<FRHIBreadcrumbAllocator>();
		}

		return *BreadcrumbAllocator;
	}

	FORCEINLINE_DEBUGGABLE void BeginBreadcrumbCPU(FRHIBreadcrumbNode* Breadcrumb, bool bLink)
	{
		check(Breadcrumb && Breadcrumb != FRHIBreadcrumbNode::Sentinel);
		BreadcrumbAllocatorRefs.AddUnique(Breadcrumb->Allocator);

		if (IsTopOfPipe())
		{
			// Recording thread
			Breadcrumb->BeginCPU();
			PersistentState.LocalBreadcrumb = Breadcrumb;

			if (bLink)
			{
				CPUBreadcrumbState.Current = Breadcrumb;

				if (Breadcrumb->GetParent() == FRHIBreadcrumbNode::Sentinel)
				{
					CPUBreadcrumbState.UnknownParentList.Append(Breadcrumb);
				}
			}
		}

		EnqueueLambda_NoMarker([Breadcrumb, bLink](FRHICommandListBase& ExecutingCmdList)
		{
			// Translating thread
			ExecutingCmdList.PersistentState.LocalBreadcrumb = Breadcrumb;

			if (bLink)
			{
				ExecutingCmdList.CPUBreadcrumbState.Current = Breadcrumb;
				Breadcrumb->BeginCPU();
			}
		});
	}

	FORCEINLINE_DEBUGGABLE void EndBreadcrumbCPU(FRHIBreadcrumbNode* Breadcrumb, bool bLink)
	{
		check(Breadcrumb && Breadcrumb != FRHIBreadcrumbNode::Sentinel);
		BreadcrumbAllocatorRefs.AddUnique(Breadcrumb->Allocator);

		if (IsTopOfPipe())
		{
			// Recording thread
			Breadcrumb->EndCPU();
			PersistentState.LocalBreadcrumb = Breadcrumb->GetParent();

			if (bLink)
			{
				CPUBreadcrumbState.Current = Breadcrumb->GetParent();
			}
		}

		EnqueueLambda_NoMarker([Breadcrumb, bLink](FRHICommandListBase& ExecutingCmdList)
		{
			// Translating thread
			ExecutingCmdList.PersistentState.LocalBreadcrumb = Breadcrumb->GetParent();
			check(ExecutingCmdList.PersistentState.LocalBreadcrumb != FRHIBreadcrumbNode::Sentinel);

			if (bLink)
			{
				ExecutingCmdList.CPUBreadcrumbState.Current = Breadcrumb->GetParent();
				check(ExecutingCmdList.CPUBreadcrumbState.Current != FRHIBreadcrumbNode::Sentinel);

				Breadcrumb->EndCPU();
			}
		});
	}

	FORCEINLINE_DEBUGGABLE void BeginBreadcrumbGPU(FRHIBreadcrumbNode* Breadcrumb, ERHIPipeline Pipeline)
	{
		check(Breadcrumb && Breadcrumb != FRHIBreadcrumbNode::Sentinel);
		check(IsSingleRHIPipeline(Pipeline));
		check(EnumHasAllFlags(ActivePipelines, Pipeline));
		check(!EnumHasAnyFlags(ERHIPipeline(Breadcrumb->BeginPipes.fetch_or(std::underlying_type_t<ERHIPipeline>(Pipeline))), Pipeline));

		BreadcrumbAllocatorRefs.AddUnique(Breadcrumb->Allocator);

		auto& State = GPUBreadcrumbState[Pipeline];
		State.Current = Breadcrumb;
		State.Latest = Breadcrumb;

		EnqueueLambda(TEXT("BeginBreadcrumbGPU"), [Breadcrumb, Pipeline](FRHICommandListBase& ExecutingCmdList)
		{
			auto& State = ExecutingCmdList.GPUBreadcrumbState[Pipeline];

			State.Range.InsertAfter(Breadcrumb, State.Prev, Pipeline);
			State.Prev = Breadcrumb;

			State.Current = Breadcrumb;
			State.Latest = Breadcrumb;

			ExecutingCmdList.Contexts[Pipeline]->RHIBeginBreadcrumbGPU(Breadcrumb);
		});
	}

	FORCEINLINE_DEBUGGABLE void EndBreadcrumbGPU(FRHIBreadcrumbNode* Breadcrumb, ERHIPipeline Pipeline)
	{
		check(Breadcrumb && Breadcrumb != FRHIBreadcrumbNode::Sentinel);
		check(IsSingleRHIPipeline(Pipeline));
		check(EnumHasAllFlags(ActivePipelines, Pipeline));
		check(!EnumHasAnyFlags(ERHIPipeline(Breadcrumb->EndPipes.fetch_or(std::underlying_type_t<ERHIPipeline>(Pipeline))), Pipeline));

		BreadcrumbAllocatorRefs.AddUnique(Breadcrumb->Allocator);

		auto& State = GPUBreadcrumbState[Pipeline];
		State.Current = Breadcrumb->GetParent();
		State.Latest = Breadcrumb->GetParent();

		EnqueueLambda(TEXT("EndBreadcrumbGPU"), [Breadcrumb, Pipeline](FRHICommandListBase& ExecutingCmdList)
		{
			auto& State = ExecutingCmdList.GPUBreadcrumbState[Pipeline];

			State.Current = Breadcrumb->GetParent();
			check(State.Current != FRHIBreadcrumbNode::Sentinel);

			State.Latest = Breadcrumb->GetParent();
			check(State.Latest != FRHIBreadcrumbNode::Sentinel);

			ExecutingCmdList.Contexts[Pipeline]->RHIEndBreadcrumbGPU(Breadcrumb);
		});
	}
#endif // WITH_RHI_BREADCRUMBS

	UE_DEPRECATED(5.5, "RHIPushEvent is deprecated. All events and markers now use the RHI breadcrumb system. Use RDG_EVENT_SCOPE or SCOPED_DRAW_EVENT macros to mark up rendering code, rather than calling this function directly.")
	FORCEINLINE_DEBUGGABLE void PushEvent(const TCHAR* Name, FColor Color)
	{
	}

	UE_DEPRECATED(5.5, "RHIPopEvent is deprecated. All events and markers now use the RHI breadcrumb system. Use RDG_EVENT_SCOPE or SCOPED_DRAW_EVENT macros to mark up rendering code, rather than calling this function directly.")
	FORCEINLINE_DEBUGGABLE void PopEvent()
	{
	}

	//UE_DEPRECATED(5.1, "SubmitCommandsHint is deprecated, and has no effect if called on a non-immediate RHI command list. Consider calling ImmediateFlush(EImmediateFlushType::DispatchToRHIThread) on the immediate command list instead.")
	inline void SubmitCommandsHint();

	FORCEINLINE_DEBUGGABLE void CopyToStagingBuffer(FRHIBuffer* SourceBuffer, FRHIStagingBuffer* DestinationStagingBuffer, uint32 Offset, uint32 NumBytes)
	{
		if (Bypass())
		{
			GetComputeContext().RHICopyToStagingBuffer(SourceBuffer, DestinationStagingBuffer, Offset, NumBytes);
			return;
		}
		ALLOC_COMMAND(FRHICommandCopyToStagingBuffer)(SourceBuffer, DestinationStagingBuffer, Offset, NumBytes);
	}

	FORCEINLINE_DEBUGGABLE void WriteGPUFence(FRHIGPUFence* Fence)
	{
		GDynamicRHI->RHIWriteGPUFence_TopOfPipe(*this, Fence);
	}

	FORCEINLINE_DEBUGGABLE void SetGPUMask(FRHIGPUMask InGPUMask)
	{
		if (PersistentState.CurrentGPUMask != InGPUMask)
		{
			PersistentState.CurrentGPUMask = InGPUMask;
#if WITH_MGPU
			if (Bypass())
			{
				// Apply the new mask to all contexts owned by this command list.
				for (IRHIComputeContext* Context : Contexts)
				{
					if (Context)
					{
						Context->RHISetGPUMask(PersistentState.CurrentGPUMask);
					}
				}
				return;
			}
			else
			{
				ALLOC_COMMAND(FRHICommandSetGPUMask)(PersistentState.CurrentGPUMask);
			}
#endif // WITH_MGPU
		}
	}

	FORCEINLINE_DEBUGGABLE void TransferResources(TConstArrayView<FTransferResourceParams> Params)
	{
#if WITH_MGPU
		if (Bypass())
		{
			GetComputeContext().RHITransferResources(Params);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandTransferResources)(AllocArray(Params));
		}
#endif // WITH_MGPU
	}

	FORCEINLINE_DEBUGGABLE void TransferResourceSignal(TConstArrayView<FTransferResourceFenceData*> FenceDatas, FRHIGPUMask SrcGPUMask)
	{
#if WITH_MGPU
		if (Bypass())
		{
			GetComputeContext().RHITransferResourceSignal(FenceDatas, SrcGPUMask);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandTransferResourceSignal)(AllocArray(FenceDatas), SrcGPUMask);
		}
#endif // WITH_MGPU
	}

	FORCEINLINE_DEBUGGABLE void TransferResourceWait(TConstArrayView<FTransferResourceFenceData*> FenceDatas)
	{
#if WITH_MGPU
		if (Bypass())
		{
			GetComputeContext().RHITransferResourceWait(FenceDatas);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandTransferResourceWait)(AllocArray(FenceDatas));
		}
#endif // WITH_MGPU
	}

	FORCEINLINE_DEBUGGABLE void CrossGPUTransfer(TConstArrayView<FTransferResourceParams> Params, TConstArrayView<FCrossGPUTransferFence*> PreTransfer, TConstArrayView<FCrossGPUTransferFence*> PostTransfer)
	{
#if WITH_MGPU
		if (Bypass())
		{
			GetComputeContext().RHICrossGPUTransfer(Params, PreTransfer, PostTransfer);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandCrossGPUTransfer)(AllocArray(Params), AllocArray(PreTransfer), AllocArray(PostTransfer));
		}
#endif // WITH_MGPU
	}

	FORCEINLINE_DEBUGGABLE void CrossGPUTransferSignal(TConstArrayView<FTransferResourceParams> Params, TConstArrayView<FCrossGPUTransferFence*> PreTransfer)
	{
#if WITH_MGPU
		if (Bypass())
		{
			GetComputeContext().RHICrossGPUTransferSignal(Params, PreTransfer);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandCrossGPUTransferSignal)(AllocArray(Params), AllocArray(PreTransfer));
		}
#endif // WITH_MGPU
	}

	FORCEINLINE_DEBUGGABLE void CrossGPUTransferWait(TConstArrayView<FCrossGPUTransferFence*> SyncPoints)
	{
#if WITH_MGPU
		if (Bypass())
		{
			GetComputeContext().RHICrossGPUTransferWait(SyncPoints);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandCrossGPUTransferWait)(AllocArray(SyncPoints));
		}
#endif // WITH_MGPU
	}

	RHI_API void BuildAccelerationStructure(FRHIRayTracingGeometry* Geometry);
	RHI_API void BuildAccelerationStructures(TConstArrayView<FRayTracingGeometryBuildParams> Params);

	FORCEINLINE_DEBUGGABLE void BuildAccelerationStructures(TConstArrayView<FRayTracingGeometryBuildParams> Params, const FRHIBufferRange& ScratchBufferRange)
	{
		if (Bypass())
		{
			GetComputeContext().RHIBuildAccelerationStructures(Params, ScratchBufferRange);
		}
		else
		{
			// Copy the params themselves as well their segment lists, if there are any.
			// AllocArray() can't be used here directly, as we have to modify the params after copy.
			size_t DataSize = sizeof(FRayTracingGeometryBuildParams) * Params.Num();
			FRayTracingGeometryBuildParams* InlineParams = (FRayTracingGeometryBuildParams*) Alloc(DataSize, alignof(FRayTracingGeometryBuildParams));
			FMemory::Memcpy(InlineParams, Params.GetData(), DataSize);
			for (int32 i=0; i<Params.Num(); ++i)
			{
				if (Params[i].Segments.Num())
				{
					InlineParams[i].Segments = AllocArray(Params[i].Segments);
				}
			}
			ALLOC_COMMAND(FRHICommandBuildAccelerationStructures)(MakeArrayView(InlineParams, Params.Num()), ScratchBufferRange);

			RHIThreadFence(true);
		}
	}

	FORCEINLINE_DEBUGGABLE void BuildAccelerationStructure(const FRayTracingSceneBuildParams& SceneBuildParams)
	{
		if (Bypass())
		{
			GetComputeContext().RHIBuildAccelerationStructure(SceneBuildParams);
		}
		else
		{
			FRayTracingSceneBuildParams InlineParams = SceneBuildParams;
			InlineParams.ReferencedGeometries = AllocArray(SceneBuildParams.ReferencedGeometries);
			InlineParams.PerInstanceGeometries = AllocArray(SceneBuildParams.PerInstanceGeometries);

			ALLOC_COMMAND(FRHICommandBuildAccelerationStructure)(MoveTemp(InlineParams));

			// This RHI command modifies members of the FRHIRayTracingScene inside platform RHI implementations.
			// It therefore needs the RHI lock fence to prevent races on those members.
			RHIThreadFence(true);
		}
	}

	FORCEINLINE_DEBUGGABLE void BindAccelerationStructureMemory(FRHIRayTracingScene* Scene, FRHIBuffer* Buffer, uint32 BufferOffset)
	{
		if (Bypass())
		{
			GetComputeContext().RHIBindAccelerationStructureMemory(Scene, Buffer, BufferOffset);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandBindAccelerationStructureMemory)(Scene, Buffer, BufferOffset);

			// This RHI command modifies members of the FRHIRayTracingScene inside platform RHI implementations.
			// It therefore needs the RHI lock fence to prevent races on those members.
			RHIThreadFence(true);
		}
	}

	FORCEINLINE_DEBUGGABLE void PostExternalCommandsReset()
	{
		if (Bypass())
		{
			GetContext().RHIPostExternalCommandsReset();
			return;
		}
		ALLOC_COMMAND(FRHICommandPostExternalCommandsReset)();
	}
};

template<> RHI_EXECUTE_API void FRHICommandSetShaderParameters           <FRHIGraphicsShader>::Execute(FRHICommandListBase& CmdList);
template<> RHI_EXECUTE_API void FRHICommandSetShaderUnbinds              <FRHIGraphicsShader>::Execute(FRHICommandListBase& CmdList);

class FRHICommandList : public FRHIComputeCommandList
{
protected:
	using FRHIComputeCommandList::OnBoundShaderChanged;

	void OnBoundShaderChanged(const FBoundShaderStateInput& InBoundShaderStateInput)
	{
		PersistentState.BoundShaderInput = InBoundShaderStateInput;
	}

	FRHICommandList(FRHIGPUMask GPUMask, bool bImmediate)
		: FRHIComputeCommandList(GPUMask, bImmediate)
	{}

public:
	static inline FRHICommandList& Get(FRHICommandListBase& RHICmdList)
	{
		return static_cast<FRHICommandList&>(RHICmdList);
	}

	FRHICommandList(FRHIGPUMask GPUMask = FRHIGPUMask::All())
		: FRHIComputeCommandList(GPUMask)
	{}

	FRHICommandList(FRHICommandListBase&& Other)
		: FRHIComputeCommandList(MoveTemp(Other))
	{}

	inline FRHIVertexShader*        GetBoundVertexShader       () const { return PersistentState.BoundShaderInput.VertexShaderRHI;          }
	inline FRHIMeshShader*          GetBoundMeshShader         () const { return PersistentState.BoundShaderInput.GetMeshShader();          }
	inline FRHIAmplificationShader* GetBoundAmplificationShader() const { return PersistentState.BoundShaderInput.GetAmplificationShader(); }
	inline FRHIPixelShader*         GetBoundPixelShader        () const { return PersistentState.BoundShaderInput.PixelShaderRHI;           }
	inline FRHIGeometryShader*      GetBoundGeometryShader     () const { return PersistentState.BoundShaderInput.GetGeometryShader();      }

	template <typename LAMBDA>
	FORCEINLINE_DEBUGGABLE void EnqueueLambda(const TCHAR* LambdaName, LAMBDA&& Lambda)
	{
		if (IsBottomOfPipe())
		{
			Lambda(*this);
		}
		else
		{
			ALLOC_COMMAND(TRHILambdaCommand<FRHICommandList, LAMBDA>)(Forward<LAMBDA>(Lambda), LambdaName);
		}
	}

	template <typename LAMBDA>
	FORCEINLINE_DEBUGGABLE void EnqueueLambda(LAMBDA&& Lambda)
	{
		FRHICommandList::EnqueueLambda(TEXT("TRHILambdaCommand"), Forward<LAMBDA>(Lambda));
	}

	using FRHIComputeCommandList::SetShaderParameters;

	FORCEINLINE_DEBUGGABLE void SetShaderParameters(
		FRHIGraphicsShader* InShader
		, TConstArrayView<uint8> InParametersData
		, TConstArrayView<FRHIShaderParameter> InParameters
		, TConstArrayView<FRHIShaderParameterResource> InResourceParameters
		, TConstArrayView<FRHIShaderParameterResource> InBindlessParameters
	)
	{
		ValidateBoundShader(InShader);

		if (Bypass())
		{
			GetContext().RHISetShaderParameters(InShader, InParametersData, InParameters, InResourceParameters, InBindlessParameters);
			return;
		}

		ALLOC_COMMAND(FRHICommandSetShaderParameters<FRHIGraphicsShader>)(
			InShader
			, AllocArray(InParametersData)
			, AllocArray(InParameters)
			, AllocArray(InResourceParameters)
			, AllocArray(InBindlessParameters)
			);
	}

	using FRHIComputeCommandList::SetBatchedShaderParameters;

	FORCEINLINE_DEBUGGABLE void SetBatchedShaderParameters(FRHIGraphicsShader* InShader, FRHIBatchedShaderParameters& InBatchedParameters)
	{
		if (InBatchedParameters.HasParameters())
		{
			ON_SCOPE_EXIT
			{
				InBatchedParameters.Reset();
			};

			if (Bypass())
			{
				GetContext().RHISetShaderParameters(InShader, InBatchedParameters.ParametersData, InBatchedParameters.Parameters, InBatchedParameters.ResourceParameters, InBatchedParameters.BindlessParameters);
				return;
			}

			ValidateBoundShader(InShader);
			ValidateShaderParameters(InBatchedParameters);
			ALLOC_COMMAND(FRHICommandSetShaderParameters<FRHIGraphicsShader>)(InShader, InBatchedParameters.ParametersData, InBatchedParameters.Parameters, InBatchedParameters.ResourceParameters, InBatchedParameters.BindlessParameters);
		}
	}

	using FRHIComputeCommandList::SetShaderUnbinds;

	FORCEINLINE_DEBUGGABLE void SetShaderUnbinds(FRHIGraphicsShader* InShader, TConstArrayView<FRHIShaderParameterUnbind> InUnbinds)
	{
		if (NeedsShaderUnbinds())
		{
			ValidateBoundShader(InShader);

			if (Bypass())
			{
				GetContext().RHISetShaderUnbinds(InShader, InUnbinds);
				return;
			}

			ALLOC_COMMAND(FRHICommandSetShaderUnbinds<FRHIGraphicsShader>)(InShader, AllocArray(InUnbinds));
		}
	}

	using FRHIComputeCommandList::SetBatchedShaderUnbinds;

	FORCEINLINE_DEBUGGABLE void SetBatchedShaderUnbinds(FRHIGraphicsShader* InShader, FRHIBatchedShaderUnbinds& InBatchedUnbinds)
	{
		if (InBatchedUnbinds.HasParameters())
		{
			SetShaderUnbinds(InShader, InBatchedUnbinds.Unbinds);

			InBatchedUnbinds.Reset();
		}
	}

	FORCEINLINE_DEBUGGABLE void SetBlendFactor(const FLinearColor& BlendFactor = FLinearColor::White)
	{
		//check(IsOutsideRenderPass());
		if (Bypass())
		{
			GetContext().RHISetBlendFactor(BlendFactor);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetBlendFactor)(BlendFactor);
	}

	FORCEINLINE_DEBUGGABLE void DrawPrimitive(uint32 BaseVertexIndex, uint32 NumPrimitives, uint32 NumInstances)
	{
		//check(IsOutsideRenderPass());
		if (Bypass())
		{
			GetContext().RHIDrawPrimitive(BaseVertexIndex, NumPrimitives, NumInstances);
			return;
		}
		ALLOC_COMMAND(FRHICommandDrawPrimitive)(BaseVertexIndex, NumPrimitives, NumInstances);
	}

	FORCEINLINE_DEBUGGABLE void DrawIndexedPrimitive(FRHIBuffer* IndexBuffer, int32 BaseVertexIndex, uint32 FirstInstance, uint32 NumVertices, uint32 StartIndex, uint32 NumPrimitives, uint32 NumInstances)
	{
		//check(IsOutsideRenderPass());
		if (Bypass())
		{
			GetContext().RHIDrawIndexedPrimitive(IndexBuffer, BaseVertexIndex, FirstInstance, NumVertices, StartIndex, NumPrimitives, NumInstances);
			return;
		}
		ALLOC_COMMAND(FRHICommandDrawIndexedPrimitive)(IndexBuffer, BaseVertexIndex, FirstInstance, NumVertices, StartIndex, NumPrimitives, NumInstances);
	}

	FORCEINLINE_DEBUGGABLE void SetStreamSource(uint32 StreamIndex, FRHIBuffer* VertexBuffer, uint32 Offset)
	{
		if (Bypass())
		{
			GetContext().RHISetStreamSource(StreamIndex, VertexBuffer, Offset);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetStreamSource)(StreamIndex, VertexBuffer, Offset);
	}

	FORCEINLINE_DEBUGGABLE void SetStreamSourceSlot(uint32 StreamIndex, FRHIStreamSourceSlot* StreamSourceSlot, uint32 Offset)
	{
		EnqueueLambda([StreamIndex, StreamSourceSlot, Offset] (FRHICommandListBase& RHICmdList)
		{
			FRHICommandSetStreamSource Command(StreamIndex, StreamSourceSlot ? StreamSourceSlot->Buffer : nullptr, Offset);
			Command.Execute(RHICmdList);
		});
	}

	FORCEINLINE_DEBUGGABLE void SetStencilRef(uint32 StencilRef)
	{
		//check(IsOutsideRenderPass());
		if (Bypass())
		{
			GetContext().RHISetStencilRef(StencilRef);
			return;
		}

		ALLOC_COMMAND(FRHICommandSetStencilRef)(StencilRef);
	}

	FORCEINLINE_DEBUGGABLE void SetViewport(float MinX, float MinY, float MinZ, float MaxX, float MaxY, float MaxZ)
	{
		//check(IsOutsideRenderPass());
		if (Bypass())
		{
			GetContext().RHISetViewport(MinX, MinY, MinZ, MaxX, MaxY, MaxZ);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetViewport)(MinX, MinY, MinZ, MaxX, MaxY, MaxZ);
	}

	FORCEINLINE_DEBUGGABLE void SetStereoViewport(float LeftMinX, float RightMinX, float LeftMinY, float RightMinY, float MinZ, float LeftMaxX, float RightMaxX, float LeftMaxY, float RightMaxY, float MaxZ)
	{
		//check(IsOutsideRenderPass());
		if (Bypass())
		{
			GetContext().RHISetStereoViewport(LeftMinX, RightMinX, LeftMinY, RightMinY, MinZ, LeftMaxX, RightMaxX, LeftMaxY, RightMaxY, MaxZ);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetStereoViewport)(LeftMinX, RightMinX, LeftMinY, RightMinY, MinZ, LeftMaxX, RightMaxX, LeftMaxY, RightMaxY, MaxZ);
	}

	FORCEINLINE_DEBUGGABLE void SetScissorRect(bool bEnable, uint32 MinX, uint32 MinY, uint32 MaxX, uint32 MaxY)
	{
		//check(IsOutsideRenderPass());
		if (Bypass())
		{
			GetContext().RHISetScissorRect(bEnable, MinX, MinY, MaxX, MaxY);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetScissorRect)(bEnable, MinX, MinY, MaxX, MaxY);
	}

	void ApplyCachedRenderTargets(
		FGraphicsPipelineStateInitializer& GraphicsPSOInit
		)
	{
		GraphicsPSOInit.RenderTargetsEnabled = PersistentState.CachedNumSimultanousRenderTargets;

		for (uint32 i = 0; i < GraphicsPSOInit.RenderTargetsEnabled; ++i)
		{
			if (PersistentState.CachedRenderTargets[i].Texture)
			{
				GraphicsPSOInit.RenderTargetFormats[i] = UE_PIXELFORMAT_TO_UINT8(PersistentState.CachedRenderTargets[i].Texture->GetFormat());
				GraphicsPSOInit.RenderTargetFlags[i] = PersistentState.CachedRenderTargets[i].Texture->GetFlags();
			}
			else
			{
				GraphicsPSOInit.RenderTargetFormats[i] = PF_Unknown;
			}

			if (GraphicsPSOInit.RenderTargetFormats[i] != PF_Unknown)
			{
				GraphicsPSOInit.NumSamples = static_cast<uint16>(PersistentState.CachedRenderTargets[i].Texture->GetNumSamples());
			}
		}

		if (PersistentState.CachedDepthStencilTarget.Texture)
		{
			GraphicsPSOInit.DepthStencilTargetFormat = PersistentState.CachedDepthStencilTarget.Texture->GetFormat();
			GraphicsPSOInit.DepthStencilTargetFlag = PersistentState.CachedDepthStencilTarget.Texture->GetFlags();
			const FRHITexture* TextureArray = PersistentState.CachedDepthStencilTarget.Texture->GetTexture2DArray();
		}
		else
		{
			GraphicsPSOInit.DepthStencilTargetFormat = PF_Unknown;
		}

		GraphicsPSOInit.DepthTargetLoadAction = PersistentState.CachedDepthStencilTarget.DepthLoadAction;
		GraphicsPSOInit.DepthTargetStoreAction = PersistentState.CachedDepthStencilTarget.DepthStoreAction;
		GraphicsPSOInit.StencilTargetLoadAction = PersistentState.CachedDepthStencilTarget.StencilLoadAction;
		GraphicsPSOInit.StencilTargetStoreAction = PersistentState.CachedDepthStencilTarget.GetStencilStoreAction();
		GraphicsPSOInit.DepthStencilAccess = PersistentState.CachedDepthStencilTarget.GetDepthStencilAccess();

		if (GraphicsPSOInit.DepthStencilTargetFormat != PF_Unknown)
		{
			GraphicsPSOInit.NumSamples =  static_cast<uint16>(PersistentState.CachedDepthStencilTarget.Texture->GetNumSamples());
		}

		GraphicsPSOInit.SubpassHint = PersistentState.SubpassHint;
		GraphicsPSOInit.SubpassIndex = PersistentState.SubpassIndex;
		GraphicsPSOInit.MultiViewCount = PersistentState.MultiViewCount;
		GraphicsPSOInit.bHasFragmentDensityAttachment = PersistentState.bHasFragmentDensityAttachment;
	}

	FORCEINLINE_DEBUGGABLE void SetGraphicsPipelineState(class FGraphicsPipelineState* GraphicsPipelineState, const FBoundShaderStateInput& ShaderInput, uint32 StencilRef, bool bApplyAdditionalState)
	{
		//check(IsOutsideRenderPass());
		OnBoundShaderChanged(ShaderInput);
		if (Bypass())
		{
			FRHIGraphicsPipelineState* RHIGraphicsPipelineState = ExecuteSetGraphicsPipelineState(GraphicsPipelineState);
			GetContext().RHISetGraphicsPipelineState(RHIGraphicsPipelineState, StencilRef, bApplyAdditionalState);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetGraphicsPipelineState)(GraphicsPipelineState, StencilRef, bApplyAdditionalState);
	}

#if PLATFORM_USE_FALLBACK_PSO
	FORCEINLINE_DEBUGGABLE void SetGraphicsPipelineState(const FGraphicsPipelineStateInitializer& PsoInit, uint32 StencilRef, bool bApplyAdditionalState)
	{
		//check(IsOutsideRenderPass());
		OnBoundShaderChanged(PsoInit.BoundShaderState);
		if (Bypass())
		{
			GetContext().RHISetGraphicsPipelineState(PsoInit, StencilRef, bApplyAdditionalState);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetGraphicsPipelineStateFromInitializer)(PsoInit, StencilRef, bApplyAdditionalState);
	}
#endif

	FORCEINLINE_DEBUGGABLE void DrawPrimitiveIndirect(FRHIBuffer* ArgumentBuffer, uint32 ArgumentOffset)
	{
		//check(IsOutsideRenderPass());
		if (Bypass())
		{
			GetContext().RHIDrawPrimitiveIndirect(ArgumentBuffer, ArgumentOffset);
			return;
		}
		ALLOC_COMMAND(FRHICommandDrawPrimitiveIndirect)(ArgumentBuffer, ArgumentOffset);
	}

	UE_DEPRECATED(5.4, "Use DrawIndexedPrimitiveIndirect.")
	FORCEINLINE_DEBUGGABLE void DrawIndexedIndirect(FRHIBuffer* IndexBufferRHI, FRHIBuffer* ArgumentsBufferRHI, uint32 DrawArgumentsIndex, uint32 NumInstances)
	{
		//check(IsOutsideRenderPass());
		if (Bypass())
		{
			GetContext().RHIDrawIndexedIndirect(IndexBufferRHI, ArgumentsBufferRHI, DrawArgumentsIndex, NumInstances);
			return;
		}
		ALLOC_COMMAND(FRHICommandDrawIndexedIndirect)(IndexBufferRHI, ArgumentsBufferRHI, DrawArgumentsIndex, NumInstances);
	}

	FORCEINLINE_DEBUGGABLE void DrawIndexedPrimitiveIndirect(FRHIBuffer* IndexBuffer, FRHIBuffer* ArgumentsBuffer, uint32 ArgumentOffset)
	{
		//check(IsOutsideRenderPass());
		if (Bypass())
		{
			GetContext().RHIDrawIndexedPrimitiveIndirect(IndexBuffer, ArgumentsBuffer, ArgumentOffset);
			return;
		}
		ALLOC_COMMAND(FRHICommandDrawIndexedPrimitiveIndirect)(IndexBuffer, ArgumentsBuffer, ArgumentOffset);
	}

	FORCEINLINE_DEBUGGABLE void MultiDrawIndexedPrimitiveIndirect(FRHIBuffer* IndexBuffer, FRHIBuffer* ArgumentsBuffer, uint32 ArgumentOffset, FRHIBuffer* CountBuffer, uint32 CountBufferOffset, uint32 MaxDrawArguments)
	{
		//check(IsOutsideRenderPass());
		if (Bypass())
		{
			GetContext().RHIMultiDrawIndexedPrimitiveIndirect(IndexBuffer, ArgumentsBuffer, ArgumentOffset, CountBuffer, CountBufferOffset, MaxDrawArguments);
			return;
		}
		ALLOC_COMMAND(FRHICommandMultiDrawIndexedPrimitiveIndirect)(IndexBuffer, ArgumentsBuffer, ArgumentOffset, CountBuffer, CountBufferOffset, MaxDrawArguments);
	}

	FORCEINLINE_DEBUGGABLE void DispatchMeshShader(uint32 ThreadGroupCountX, uint32 ThreadGroupCountY, uint32 ThreadGroupCountZ)
	{
		if (Bypass())
		{
			GetContext().RHIDispatchMeshShader(ThreadGroupCountX, ThreadGroupCountY, ThreadGroupCountZ);
			return;
		}
		ALLOC_COMMAND(FRHICommandDispatchMeshShader)(ThreadGroupCountX, ThreadGroupCountY, ThreadGroupCountZ);
	}

	FORCEINLINE_DEBUGGABLE void DispatchIndirectMeshShader(FRHIBuffer* ArgumentBuffer, uint32 ArgumentOffset)
	{
		if (Bypass())
		{
			GetContext().RHIDispatchIndirectMeshShader(ArgumentBuffer, ArgumentOffset);
			return;
		}
		ALLOC_COMMAND(FRHICommandDispatchIndirectMeshShader)(ArgumentBuffer, ArgumentOffset);
	}

	FORCEINLINE_DEBUGGABLE void SetDepthBounds(float MinDepth, float MaxDepth)
	{
		//check(IsOutsideRenderPass());
		if (Bypass())
		{
			GetContext().RHISetDepthBounds(MinDepth, MaxDepth);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetDepthBounds)(MinDepth, MaxDepth);
	}
	
	FORCEINLINE_DEBUGGABLE void SetShadingRate(EVRSShadingRate ShadingRate, EVRSRateCombiner Combiner)
	{
#if PLATFORM_SUPPORTS_VARIABLE_RATE_SHADING
		if (Bypass())
		{
			GetContext().RHISetShadingRate(ShadingRate, Combiner);
			return;
		}
		ALLOC_COMMAND(FRHICommandSetShadingRate)(ShadingRate, Combiner);
#endif
	}

	FORCEINLINE_DEBUGGABLE void CopyTexture(FRHITexture* SourceTextureRHI, FRHITexture* DestTextureRHI, const FRHICopyTextureInfo& CopyInfo)
	{
		check(SourceTextureRHI && DestTextureRHI);
		check(SourceTextureRHI != DestTextureRHI);
		check(IsOutsideRenderPass());

		if (Bypass())
		{
			GetContext().RHICopyTexture(SourceTextureRHI, DestTextureRHI, CopyInfo);
			return;
		}
		ALLOC_COMMAND(FRHICommandCopyTexture)(SourceTextureRHI, DestTextureRHI, CopyInfo);
	}

	FORCEINLINE_DEBUGGABLE void ResummarizeHTile(FRHITexture* DepthTexture)
	{
		if (Bypass())
		{
			GetContext().RHIResummarizeHTile(DepthTexture);
			return;
		}
		ALLOC_COMMAND(FRHICommandResummarizeHTile)(DepthTexture);
	}

	FORCEINLINE_DEBUGGABLE void BeginRenderQuery(FRHIRenderQuery* RenderQuery)
	{
		GDynamicRHI->RHIBeginRenderQuery_TopOfPipe(*this, RenderQuery);
	}

	FORCEINLINE_DEBUGGABLE void EndRenderQuery(FRHIRenderQuery* RenderQuery)
	{
		GDynamicRHI->RHIEndRenderQuery_TopOfPipe(*this, RenderQuery);
	}

	FORCEINLINE_DEBUGGABLE void CalibrateTimers(FRHITimestampCalibrationQuery* CalibrationQuery)
	{
		if (Bypass())
		{
			GetContext().RHICalibrateTimers(CalibrationQuery);
			return;
		}
		ALLOC_COMMAND(FRHICommandCalibrateTimers)(CalibrationQuery);
	}

	UE_DEPRECATED(5.5, "PollOcclusionQueries is no longer necessary. It has been deprecated and there is no replacement. Remove any remaining calls to PollOcclusionQueries.")
	FORCEINLINE_DEBUGGABLE void PollOcclusionQueries()
	{
	}

	FORCEINLINE_DEBUGGABLE void BeginRenderPass(const FRHIRenderPassInfo& InInfo, const TCHAR* Name)
	{
		check(!IsInsideRenderPass());
		check(!IsInsideComputePass());

		InInfo.Validate();

		if (Bypass())
		{
			GetContext().RHIBeginRenderPass(InInfo, Name);
		}
		else
		{
			TCHAR* NameCopy  = AllocString(Name);
			ALLOC_COMMAND(FRHICommandBeginRenderPass)(InInfo, NameCopy);
		}

		CacheActiveRenderTargets(InInfo);
		ResetSubpass(InInfo.SubpassHint);
		PersistentState.bInsideRenderPass = true;

		if (InInfo.NumOcclusionQueries)
		{
			PersistentState.bInsideOcclusionQueryBatch = true;
			GDynamicRHI->RHIBeginRenderQueryBatch_TopOfPipe(*this, RQT_Occlusion);
		}
	}

	void EndRenderPass()
	{
		check(IsInsideRenderPass());
		check(!IsInsideComputePass());

		if (PersistentState.bInsideOcclusionQueryBatch)
		{
			GDynamicRHI->RHIEndRenderQueryBatch_TopOfPipe(*this, RQT_Occlusion);
			PersistentState.bInsideOcclusionQueryBatch = false;
		}

		if (Bypass())
		{
			GetContext().RHIEndRenderPass();
		}
		else
		{
			ALLOC_COMMAND(FRHICommandEndRenderPass)();
		}
		PersistentState.bInsideRenderPass = false;
		ResetSubpass(ESubpassHint::None);
	}

	FORCEINLINE_DEBUGGABLE void NextSubpass()
	{
		check(IsInsideRenderPass());
		if (Bypass())
		{
			GetContext().RHINextSubpass();
		}
		else
		{
			ALLOC_COMMAND(FRHICommandNextSubpass)();
		}
		IncrementSubpass();
	}

	UE_DEPRECATED(5.5, "RHIInvalidateCachedState is not implemented by any platform RHI.")
	FORCEINLINE_DEBUGGABLE void RHIInvalidateCachedState()
	{}

	UE_DEPRECATED(5.5, "DiscardRenderTargets is deprecated and will be removed in future engine versions.")
	FORCEINLINE void DiscardRenderTargets(bool Depth, bool Stencil, uint32 ColorBitMask)
	{
		if (Bypass())
		{
			GetContext().RHIDiscardRenderTargets(Depth, Stencil, ColorBitMask);
			return;
		}
		ALLOC_COMMAND(FRHICommandDiscardRenderTargets)(Depth, Stencil, ColorBitMask);
	}
	
	FORCEINLINE_DEBUGGABLE void CopyBufferRegion(FRHIBuffer* DestBuffer, uint64 DstOffset, FRHIBuffer* SourceBuffer, uint64 SrcOffset, uint64 NumBytes)
	{
		// No copy/DMA operation inside render passes
		check(IsOutsideRenderPass());

		if (Bypass())
		{
			GetContext().RHICopyBufferRegion(DestBuffer, DstOffset, SourceBuffer, SrcOffset, NumBytes);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandCopyBufferRegion)(DestBuffer, DstOffset, SourceBuffer, SrcOffset, NumBytes);
		}
	}

	UE_DEPRECATED(5.5, "GenerateMips on RHI command lists is deprecated and no longer functions. Use the FGenerateMips helper class from the RenderCore module to generate mips on textures.")
	RHI_API void GenerateMips(FRHITexture*);

	// Ray tracing API

	UE_DEPRECATED(5.5, "Use FRHIShaderBindingTable instead.")
	FORCEINLINE_DEBUGGABLE void CommitRayTracingBindings(FRHIRayTracingScene* Scene)
	{
		if (Bypass())
		{
			GetContext().RHICommitRayTracingBindings(Scene);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandCommitRayTracingBindings)(Scene);

			// This RHI command modifies members of the FRHIRayTracingScene inside platform RHI implementations.
			// It therefore needs the RHI lock fence to prevent races on those members.
			RHIThreadFence(true);
		}
	}

	FORCEINLINE_DEBUGGABLE void CommitShaderBindingTable(FRHIShaderBindingTable* SBT)
	{
		if (Bypass())
		{
			GetContext().RHICommitShaderBindingTable(SBT);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandCommitShaderBindingTable)(SBT);

			// This RHI command modifies members of the FRHIShaderBindingTable inside platform RHI implementations.
			// It therefore needs the RHI lock fence to prevent races on those members.
			RHIThreadFence(true);
		}
	}

	UE_DEPRECATED(5.5, "Use FRHIShaderBindingTable instead.")
	FORCEINLINE_DEBUGGABLE void ClearRayTracingBindings(FRHIRayTracingScene* Scene)
	{
		if (Bypass())
		{
			GetContext().RHIClearRayTracingBindings(Scene);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandClearRayTracingBindings)(Scene);

			// This RHI command modifies members of the FRHIRayTracingScene inside platform RHI implementations.
			// It therefore needs the RHI lock fence to prevent races on those members.
			RHIThreadFence(true);
		}
	}

	FORCEINLINE_DEBUGGABLE void ClearShaderBindingTable(FRHIShaderBindingTable* SBT)
	{
		if (Bypass())
		{
			GetContext().RHIClearShaderBindingTable(SBT);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandClearShaderBindingTable)(SBT);

			// This RHI command modifies members of the FRHIShaderBindingTable inside platform RHI implementations.
			// It therefore needs the RHI lock fence to prevent races on those members.
			RHIThreadFence(true);
		}
	}

	UE_DEPRECATED(5.5, "Provide FRHIShaderBindingTable instead of FRayTracingScene.")
	FORCEINLINE_DEBUGGABLE void RayTraceDispatch(FRayTracingPipelineState* Pipeline, FRHIRayTracingShader* RayGenShader, FRHIRayTracingScene* Scene, const FRayTracingShaderBindings& GlobalResourceBindings, uint32 Width, uint32 Height)
	{
		if (Bypass())
		{
			GetContext().RHIRayTraceDispatch(GetRHIRayTracingPipelineState(Pipeline), RayGenShader, Scene, GlobalResourceBindings, Width, Height);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandRayTraceDispatch)(Pipeline, RayGenShader, Scene, GlobalResourceBindings, Width, Height);
		}
	}

	FORCEINLINE_DEBUGGABLE void RayTraceDispatch(FRayTracingPipelineState* Pipeline, FRHIRayTracingShader* RayGenShader, FRHIShaderBindingTable* SBT, const FRayTracingShaderBindings& GlobalResourceBindings, uint32 Width, uint32 Height)
	{
		check(SBT != nullptr);
		if (Bypass())
		{
			GetContext().RHIRayTraceDispatch(GetRHIRayTracingPipelineState(Pipeline), RayGenShader, SBT, GlobalResourceBindings, Width, Height);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandRayTraceDispatch)(Pipeline, RayGenShader, SBT, GlobalResourceBindings, Width, Height);
		}
	}

	/*
	* Compatibility adaptor that operates on the new FRHIBatchedShaderParameters instead of legacy FRayTracingShaderBindings (planned for deprecation).
	* This will become the default native code path in a future UE version.
	*/
	RHI_API void RayTraceDispatch(FRayTracingPipelineState* Pipeline, FRHIRayTracingShader* RayGenShader, FRHIShaderBindingTable* SBT, FRHIBatchedShaderParameters& GlobalResourceBindings, uint32 Width, uint32 Height);

	/**
	 * Trace rays using dimensions from a GPU buffer containing uint[3], interpreted as number of rays in X, Y and Z dimensions.
	 * ArgumentBuffer must be in IndirectArgs|SRVCompute state.
	 */
	UE_DEPRECATED(5.5, "Provide FRHIShaderBindingTable instead of FRayTracingScene.")
	FORCEINLINE_DEBUGGABLE void RayTraceDispatchIndirect(FRayTracingPipelineState* Pipeline, FRHIRayTracingShader* RayGenShader, FRHIRayTracingScene* Scene, const FRayTracingShaderBindings& GlobalResourceBindings, FRHIBuffer* ArgumentBuffer, uint32 ArgumentOffset)
	{
		if (Bypass())
		{
			GetContext().RHIRayTraceDispatchIndirect(GetRHIRayTracingPipelineState(Pipeline), RayGenShader, Scene, GlobalResourceBindings, ArgumentBuffer, ArgumentOffset);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandRayTraceDispatch)(Pipeline, RayGenShader, Scene, GlobalResourceBindings, ArgumentBuffer, ArgumentOffset);
		}
	}

	FORCEINLINE_DEBUGGABLE void RayTraceDispatchIndirect(FRayTracingPipelineState* Pipeline, FRHIRayTracingShader* RayGenShader, FRHIShaderBindingTable* SBT, const FRayTracingShaderBindings& GlobalResourceBindings, FRHIBuffer* ArgumentBuffer, uint32 ArgumentOffset)
	{
		check(SBT != nullptr);
		if (Bypass())
		{
			GetContext().RHIRayTraceDispatchIndirect(GetRHIRayTracingPipelineState(Pipeline), RayGenShader, SBT, GlobalResourceBindings, ArgumentBuffer, ArgumentOffset);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandRayTraceDispatch)(Pipeline, RayGenShader, SBT, GlobalResourceBindings, ArgumentBuffer, ArgumentOffset);
		}
	}

	/*
	* Compatibility adaptor that operates on the new FRHIBatchedShaderParameters instead of legacy FRayTracingShaderBindings (planned for deprecation).
	* This will become the default native code path in a future UE version.
	*/
	RHI_API void RayTraceDispatchIndirect(FRayTracingPipelineState* Pipeline, FRHIRayTracingShader* RayGenShader, FRHIShaderBindingTable* SBT, FRHIBatchedShaderParameters& GlobalResourceBindings, FRHIBuffer* ArgumentBuffer, uint32 ArgumentOffset);

	UE_DEPRECATED(5.5, "Use FRHIShaderBindingTable instead.")
	FORCEINLINE_DEBUGGABLE void SetRayTracingBindings(
		FRHIRayTracingScene* Scene, FRayTracingPipelineState* Pipeline,
		uint32 NumBindings, const FRayTracingLocalShaderBindings* InBindings,
		ERayTracingBindingType BindingType,
		bool bCopyDataToInlineStorage = true)
	{
		// Upgrade bindings to new code path (duplicate bindings array to command list memory and patch to use Geometry + RecordIndex instead of the deprecated InstanceIndex + ShaderSlot)
		FRayTracingLocalShaderBindings* Bindings = nullptr;
		{
			if (NumBindings)
			{
				uint32 Size = sizeof(FRayTracingLocalShaderBindings) * NumBindings;
				Bindings = (FRayTracingLocalShaderBindings*)Alloc(Size, alignof(FRayTracingLocalShaderBindings));
				FMemory::Memcpy(Bindings, InBindings, Size);
			}

			for (uint32 i = 0; i < NumBindings; ++i)
			{
				PRAGMA_DISABLE_DEPRECATION_WARNINGS
				Bindings[i].Geometry = Scene->GetInitializer().PerInstanceGeometries[Bindings[i].InstanceIndex];
				Bindings[i].RecordIndex = (Scene->GetInitializer().SegmentPrefixSum[Bindings[i].InstanceIndex] + Bindings[i].SegmentIndex) * Scene->GetInitializer().ShaderSlotsPerGeometrySegment + Bindings[i].ShaderSlot;
				Bindings[i].InstanceIndex = INDEX_NONE;
				PRAGMA_ENABLE_DEPRECATION_WARNINGS

				if (Bindings[i].NumUniformBuffers)
				{
					Bindings[i].UniformBuffers = (FRHIUniformBuffer**)Alloc(sizeof(FRHIUniformBuffer*) * Bindings[i].NumUniformBuffers, alignof(FRHIUniformBuffer*));
					for (uint32 Index = 0; Index < Bindings[i].NumUniformBuffers; ++Index)
					{
						Bindings[i].UniformBuffers[Index] = InBindings[i].UniformBuffers[Index];
					}
				}

				if (Bindings[i].LooseParameterDataSize)
				{
					Bindings[i].LooseParameterData = (uint8*)Alloc(Bindings[i].LooseParameterDataSize, 16);
					FMemory::Memcpy(Bindings[i].LooseParameterData, InBindings[i].LooseParameterData, Bindings[i].LooseParameterDataSize);
				}
			}
		}

		if (Bypass())
		{
			GetContext().RHISetRayTracingBindings(Scene, GetRHIRayTracingPipelineState(Pipeline), NumBindings, Bindings, BindingType);
		}
		else
		{
			ALLOC_COMMAND(FRHICommandSetBindingsOnShaderBindingTable)(Scene, Pipeline, NumBindings, Bindings, BindingType);
		}
	}

	FORCEINLINE_DEBUGGABLE void SetBindingsOnShaderBindingTable(
		FRHIShaderBindingTable* SBT, FRayTracingPipelineState* Pipeline,
		uint32 NumBindings, const FRayTracingLocalShaderBindings* Bindings,
		ERayTracingBindingType BindingType,
		bool bCopyDataToInlineStorage = true)
	{
		if (Bypass())
		{
			GetContext().RHISetBindingsOnShaderBindingTable(SBT, GetRHIRayTracingPipelineState(Pipeline), NumBindings, Bindings, BindingType);
		}
		else
		{
			check(GetRHIRayTracingPipelineStateMaxLocalBindingDataSize(Pipeline) <= SBT->GetInitializer().LocalBindingDataSize);

			FRayTracingLocalShaderBindings* InlineBindings = nullptr;

			// By default all batch binding data is stored in the command list memory.
			// However, user may skip this copy if they take responsibility for keeping data alive until this command is executed.
			if (bCopyDataToInlineStorage)
			{
				if (NumBindings)
				{
					uint32 Size = sizeof(FRayTracingLocalShaderBindings) * NumBindings;
					InlineBindings = (FRayTracingLocalShaderBindings*)Alloc(Size, alignof(FRayTracingLocalShaderBindings));
					FMemory::Memcpy(InlineBindings, Bindings, Size);
				}

				for (uint32 i = 0; i < NumBindings; ++i)
				{
					if (InlineBindings[i].NumUniformBuffers)
					{
						InlineBindings[i].UniformBuffers = (FRHIUniformBuffer**)Alloc(sizeof(FRHIUniformBuffer*) * InlineBindings[i].NumUniformBuffers, alignof(FRHIUniformBuffer*));
						for (uint32 Index = 0; Index < InlineBindings[i].NumUniformBuffers; ++Index)
						{
							InlineBindings[i].UniformBuffers[Index] = Bindings[i].UniformBuffers[Index];
						}
					}

					if (InlineBindings[i].LooseParameterDataSize)
					{
						InlineBindings[i].LooseParameterData = (uint8*)Alloc(InlineBindings[i].LooseParameterDataSize, 16);
						FMemory::Memcpy(InlineBindings[i].LooseParameterData, Bindings[i].LooseParameterData, InlineBindings[i].LooseParameterDataSize);
					}
				}

				ALLOC_COMMAND(FRHICommandSetBindingsOnShaderBindingTable)(SBT, Pipeline, NumBindings, InlineBindings, BindingType);
			}
			else
			{
				ALLOC_COMMAND(FRHICommandSetBindingsOnShaderBindingTable)(SBT, Pipeline, NumBindings, Bindings, BindingType);
			}

			RHIThreadFence(true);
		}
	}

	UE_DEPRECATED(5.5, "Use FRHIShaderBindingTable instead.")
	FORCEINLINE_DEBUGGABLE void SetRayTracingHitGroups(
		FRHIRayTracingScene* Scene, FRayTracingPipelineState* Pipeline,
		uint32 NumBindings, const FRayTracingLocalShaderBindings* Bindings,
		bool bCopyDataToInlineStorage = true)
	{
		PRAGMA_DISABLE_DEPRECATION_WARNINGS
		SetRayTracingBindings(Scene, Pipeline, NumBindings, Bindings, ERayTracingBindingType::HitGroup, bCopyDataToInlineStorage);
		PRAGMA_ENABLE_DEPRECATION_WARNINGS
	}

	FORCEINLINE_DEBUGGABLE void SetRayTracingHitGroups(
		FRHIShaderBindingTable* SBT, FRayTracingPipelineState* Pipeline,
		uint32 NumBindings, const FRayTracingLocalShaderBindings* Bindings,
		bool bCopyDataToInlineStorage = true)
	{
		SetBindingsOnShaderBindingTable(SBT, Pipeline, NumBindings, Bindings, ERayTracingBindingType::HitGroup, bCopyDataToInlineStorage);
	}

	UE_DEPRECATED(5.5, "Use FRHIShaderBindingTable instead.")
	FORCEINLINE_DEBUGGABLE void SetRayTracingCallableShaders(
		FRHIRayTracingScene* Scene, FRayTracingPipelineState* Pipeline,
		uint32 NumBindings, const FRayTracingLocalShaderBindings* Bindings,
		bool bCopyDataToInlineStorage = true)
	{
		PRAGMA_DISABLE_DEPRECATION_WARNINGS
		SetRayTracingBindings(Scene, Pipeline, NumBindings, Bindings, ERayTracingBindingType::CallableShader, bCopyDataToInlineStorage);
		PRAGMA_ENABLE_DEPRECATION_WARNINGS
	}

	FORCEINLINE_DEBUGGABLE void SetRayTracingCallableShaders(
		FRHIShaderBindingTable* SBT, FRayTracingPipelineState* Pipeline,
		uint32 NumBindings, const FRayTracingLocalShaderBindings* Bindings,
		bool bCopyDataToInlineStorage = true)
	{
		SetBindingsOnShaderBindingTable(SBT, Pipeline, NumBindings, Bindings, ERayTracingBindingType::CallableShader, bCopyDataToInlineStorage);
	}

	UE_DEPRECATED(5.5, "Use FRHIShaderBindingTable instead.")
	FORCEINLINE_DEBUGGABLE void SetRayTracingMissShaders(
		FRHIRayTracingScene* Scene, FRayTracingPipelineState* Pipeline,
		uint32 NumBindings, const FRayTracingLocalShaderBindings* Bindings,
		bool bCopyDataToInlineStorage = true)
	{
		PRAGMA_DISABLE_DEPRECATION_WARNINGS
		SetRayTracingBindings(Scene, Pipeline, NumBindings, Bindings, ERayTracingBindingType::MissShader, bCopyDataToInlineStorage);
		PRAGMA_ENABLE_DEPRECATION_WARNINGS
	}

	FORCEINLINE_DEBUGGABLE void SetRayTracingMissShaders(
		FRHIShaderBindingTable* SBT, FRayTracingPipelineState* Pipeline,
		uint32 NumBindings, const FRayTracingLocalShaderBindings* Bindings,
		bool bCopyDataToInlineStorage = true)
	{
		SetBindingsOnShaderBindingTable(SBT, Pipeline, NumBindings, Bindings, ERayTracingBindingType::MissShader, bCopyDataToInlineStorage);
	}

	UE_DEPRECATED(5.5, "Use FRHIShaderBindingTable instead.")
	FORCEINLINE_DEBUGGABLE void SetRayTracingHitGroup(
		FRHIRayTracingScene* Scene, uint32 InstanceIndex, uint32 SegmentIndex, uint32 ShaderSlot,
		FRayTracingPipelineState* Pipeline, uint32 HitGroupIndex,
		uint32 NumUniformBuffers, FRHIUniformBuffer* const* UniformBuffers,
		uint32 LooseParameterDataSize, const void* LooseParameterData,
		uint32 UserData)
	{
		check(NumUniformBuffers <= UINT16_MAX);
		check(LooseParameterDataSize <= UINT16_MAX);

		FRayTracingLocalShaderBindings* InlineBindings = new(Alloc<FRayTracingLocalShaderBindings>()) FRayTracingLocalShaderBindings();
		PRAGMA_DISABLE_DEPRECATION_WARNINGS
		InlineBindings->Geometry = Scene->GetInitializer().PerInstanceGeometries[InstanceIndex];
		PRAGMA_ENABLE_DEPRECATION_WARNINGS
		InlineBindings->SegmentIndex = SegmentIndex;
		PRAGMA_DISABLE_DEPRECATION_WARNINGS
		InlineBindings->RecordIndex = (Scene->GetInitializer().SegmentPrefixSum[InstanceIndex] + SegmentIndex) * Scene->GetInitializer().ShaderSlotsPerGeometrySegment + ShaderSlot;
		PRAGMA_ENABLE_DEPRECATION_WARNINGS
		InlineBindings->ShaderIndexInPipeline = HitGroupIndex;
		InlineBindings->UserData = UserData;
		InlineBindings->NumUniformBuffers = (uint16)NumUniformBuffers;
		InlineBindings->LooseParameterDataSize = (uint16)LooseParameterDataSize;

		if (NumUniformBuffers)
		{
			InlineBindings->UniformBuffers = (FRHIUniformBuffer**)Alloc(sizeof(FRHIUniformBuffer*) * NumUniformBuffers, alignof(FRHIUniformBuffer*));
			for (uint32 Index = 0; Index < NumUniformBuffers; ++Index)
			{
				InlineBindings->UniformBuffers[Index] = UniformBuffers[Index];
			}
		}

		if (LooseParameterDataSize)
		{
			InlineBindings->LooseParameterData = (uint8*)Alloc(LooseParameterDataSize, 16);
			FMemory::Memcpy(InlineBindings->LooseParameterData, LooseParameterData, LooseParameterDataSize);
		}

		PRAGMA_DISABLE_DEPRECATION_WARNINGS
		SetRayTracingBindings(Scene, Pipeline, 1, InlineBindings, ERayTracingBindingType::HitGroup, /*bCopyDataToInlineStorage*/ false);
		PRAGMA_ENABLE_DEPRECATION_WARNINGS
	}

	FORCEINLINE_DEBUGGABLE void SetRayTracingHitGroup(
		FRHIShaderBindingTable* SBT, uint32 RecordIndex, FRHIRayTracingGeometry* Geometry, uint32 GeometrySegmentIndex,
		FRayTracingPipelineState* Pipeline, uint32 HitGroupIndex,
		uint32 NumUniformBuffers, FRHIUniformBuffer* const* UniformBuffers,
		uint32 LooseParameterDataSize, const void* LooseParameterData,
		uint32 UserData)
	{
		check(NumUniformBuffers <= UINT16_MAX);
		check(LooseParameterDataSize <= UINT16_MAX);

		FRayTracingLocalShaderBindings* InlineBindings = new(Alloc<FRayTracingLocalShaderBindings>()) FRayTracingLocalShaderBindings();
		InlineBindings->RecordIndex = RecordIndex;
		InlineBindings->Geometry = Geometry;
		InlineBindings->SegmentIndex = GeometrySegmentIndex;
		InlineBindings->ShaderIndexInPipeline = HitGroupIndex;
		InlineBindings->UserData = UserData;
		InlineBindings->NumUniformBuffers = (uint16)NumUniformBuffers;
		InlineBindings->LooseParameterDataSize = (uint16)LooseParameterDataSize;

		if (NumUniformBuffers)
		{
			InlineBindings->UniformBuffers = (FRHIUniformBuffer**)Alloc(sizeof(FRHIUniformBuffer*) * NumUniformBuffers, alignof(FRHIUniformBuffer*));
			for (uint32 Index = 0; Index < NumUniformBuffers; ++Index)
			{
				InlineBindings->UniformBuffers[Index] = UniformBuffers[Index];
			}
		}

		if (LooseParameterDataSize)
		{
			InlineBindings->LooseParameterData = (uint8*)Alloc(LooseParameterDataSize, 16);
			FMemory::Memcpy(InlineBindings->LooseParameterData, LooseParameterData, LooseParameterDataSize);
		}

		SetBindingsOnShaderBindingTable(SBT, Pipeline, 1, InlineBindings, ERayTracingBindingType::HitGroup, /*bCopyDataToInlineStorage*/ false);
	}

	FORCEINLINE_DEBUGGABLE void SetDefaultRayTracingHitGroup(
		FRHIShaderBindingTable* SBT, FRayTracingPipelineState* Pipeline, uint32 HitGroupIndex)
	{
		FRayTracingLocalShaderBindings* InlineBindings = new(Alloc<FRayTracingLocalShaderBindings>()) FRayTracingLocalShaderBindings();
		InlineBindings->ShaderIndexInPipeline = HitGroupIndex;
		InlineBindings->RecordIndex = 0; //< Default hit group always stored at index 0

		SetBindingsOnShaderBindingTable(SBT, Pipeline, 1, InlineBindings, ERayTracingBindingType::HitGroup, /*bCopyDataToInlineStorage*/ false);
	}

	UE_DEPRECATED(5.5, "Use FRHIShaderBindingTable instead.")
	FORCEINLINE_DEBUGGABLE void SetRayTracingCallableShader(
		FRHIRayTracingScene* Scene, uint32 ShaderSlotInScene,
		FRayTracingPipelineState* Pipeline, uint32 ShaderIndexInPipeline,
		uint32 NumUniformBuffers, FRHIUniformBuffer* const* UniformBuffers,
		uint32 UserData)
	{
		FRayTracingLocalShaderBindings* InlineBindings = new(Alloc<FRayTracingLocalShaderBindings>()) FRayTracingLocalShaderBindings();
		InlineBindings->RecordIndex = ShaderSlotInScene;
		InlineBindings->ShaderIndexInPipeline = ShaderIndexInPipeline;
		InlineBindings->UserData = UserData;
		InlineBindings->NumUniformBuffers = (uint16)NumUniformBuffers;

		if (NumUniformBuffers)
		{
			InlineBindings->UniformBuffers = (FRHIUniformBuffer**)Alloc(sizeof(FRHIUniformBuffer*) * NumUniformBuffers, alignof(FRHIUniformBuffer*));
			for (uint32 Index = 0; Index < NumUniformBuffers; ++Index)
			{
				InlineBindings->UniformBuffers[Index] = UniformBuffers[Index];
			}
		}

		PRAGMA_DISABLE_DEPRECATION_WARNINGS
		SetRayTracingBindings(Scene, Pipeline, 1, InlineBindings, ERayTracingBindingType::CallableShader, /*bCopyDataToInlineStorage*/ false);
		PRAGMA_ENABLE_DEPRECATION_WARNINGS
	}

	FORCEINLINE_DEBUGGABLE void SetRayTracingCallableShader(
		FRHIShaderBindingTable* SBT, uint32 RecordIndex,
		FRayTracingPipelineState* Pipeline, uint32 ShaderIndexInPipeline,
		uint32 NumUniformBuffers, FRHIUniformBuffer* const* UniformBuffers,
		uint32 UserData)
	{
		FRayTracingLocalShaderBindings* InlineBindings = new(Alloc<FRayTracingLocalShaderBindings>()) FRayTracingLocalShaderBindings();
		InlineBindings->RecordIndex = RecordIndex;
		InlineBindings->ShaderIndexInPipeline = ShaderIndexInPipeline;
		InlineBindings->UserData = UserData;
		InlineBindings->NumUniformBuffers = (uint16)NumUniformBuffers;

		if (NumUniformBuffers)
		{
			InlineBindings->UniformBuffers = (FRHIUniformBuffer**)Alloc(sizeof(FRHIUniformBuffer*) * NumUniformBuffers, alignof(FRHIUniformBuffer*));
			for (uint32 Index = 0; Index < NumUniformBuffers; ++Index)
			{
				InlineBindings->UniformBuffers[Index] = UniformBuffers[Index];
			}
		}

		SetBindingsOnShaderBindingTable(SBT, Pipeline, 1, InlineBindings, ERayTracingBindingType::CallableShader, /*bCopyDataToInlineStorage*/ false);
	}

	UE_DEPRECATED(5.5, "Use FRHIShaderBindingTable instead.")
	FORCEINLINE_DEBUGGABLE void SetRayTracingMissShader(
		FRHIRayTracingScene* Scene, uint32 ShaderSlotInScene,
		FRayTracingPipelineState* Pipeline, uint32 ShaderIndexInPipeline,
		uint32 NumUniformBuffers, FRHIUniformBuffer* const* UniformBuffers,
		uint32 UserData)
	{
		FRayTracingLocalShaderBindings* InlineBindings = new(Alloc<FRayTracingLocalShaderBindings>()) FRayTracingLocalShaderBindings();
		InlineBindings->RecordIndex = ShaderSlotInScene;
		InlineBindings->ShaderIndexInPipeline = ShaderIndexInPipeline;
		InlineBindings->UserData = UserData;
		InlineBindings->NumUniformBuffers = (uint16)NumUniformBuffers;

		if (NumUniformBuffers)
		{
			InlineBindings->UniformBuffers = (FRHIUniformBuffer**)Alloc(sizeof(FRHIUniformBuffer*) * NumUniformBuffers, alignof(FRHIUniformBuffer*));
			for (uint32 Index = 0; Index < NumUniformBuffers; ++Index)
			{
				InlineBindings->UniformBuffers[Index] = UniformBuffers[Index];
			}
		}

		PRAGMA_DISABLE_DEPRECATION_WARNINGS
		SetRayTracingBindings(Scene, Pipeline, 1, InlineBindings, ERayTracingBindingType::MissShader, /*bCopyDataToInlineStorage*/ false);
		PRAGMA_ENABLE_DEPRECATION_WARNINGS
	}

	FORCEINLINE_DEBUGGABLE void SetRayTracingMissShader(
		FRHIShaderBindingTable* SBT, uint32 RecordIndex,
		FRayTracingPipelineState* Pipeline, uint32 ShaderIndexInPipeline,
		uint32 NumUniformBuffers, FRHIUniformBuffer* const* UniformBuffers,
		uint32 UserData)
	{
		FRayTracingLocalShaderBindings* InlineBindings = new(Alloc<FRayTracingLocalShaderBindings>()) FRayTracingLocalShaderBindings();
		InlineBindings->RecordIndex = RecordIndex;
		InlineBindings->ShaderIndexInPipeline = ShaderIndexInPipeline;
		InlineBindings->UserData = UserData;
		InlineBindings->NumUniformBuffers = (uint16)NumUniformBuffers;

		if (NumUniformBuffers)
		{
			InlineBindings->UniformBuffers = (FRHIUniformBuffer**)Alloc(sizeof(FRHIUniformBuffer*) * NumUniformBuffers, alignof(FRHIUniformBuffer*));
			for (uint32 Index = 0; Index < NumUniformBuffers; ++Index)
			{
				InlineBindings->UniformBuffers[Index] = UniformBuffers[Index];
			}
		}

		SetBindingsOnShaderBindingTable(SBT, Pipeline, 1, InlineBindings, ERayTracingBindingType::MissShader, /*bCopyDataToInlineStorage*/ false);
	}
};

namespace EImmediateFlushType
{
	enum Type
	{ 
		WaitForOutstandingTasksOnly  = 0, 
		DispatchToRHIThread          = 1, 
		FlushRHIThread               = 2,
		FlushRHIThreadFlushResources = 3
	};
};

class FScopedRHIThreadStaller
{
	class FRHICommandListImmediate* Immed; // non-null if we need to unstall
public:
	FScopedRHIThreadStaller() = delete;
	FScopedRHIThreadStaller(class FRHICommandListImmediate& InImmed, bool bDoStall = true);
	~FScopedRHIThreadStaller();
};


// Forward declare RHI creation function so they can still be called from the deprecated immediate command list resource creation functions
FBufferRHIRef RHICreateIndexBuffer(uint32 Stride, uint32 Size, uint32 InUsage, FRHIResourceCreateInfo& CreateInfo);
FBufferRHIRef RHICreateVertexBuffer(uint32 Size, uint32 InUsage, FRHIResourceCreateInfo& CreateInfo);
FBufferRHIRef RHICreateStructuredBuffer(uint32 Stride, uint32 Size, uint32 InUsage, FRHIResourceCreateInfo& CreateInfo);

extern RHI_API ERHIAccess RHIGetDefaultResourceState(ETextureCreateFlags InUsage, bool bInHasInitialData);
extern RHI_API ERHIAccess RHIGetDefaultResourceState(EBufferUsageFlags InUsage, bool bInHasInitialData);

enum class ERHISubmitFlags
{
	None = 0,

	// All submitted work will be processed, and the resulting platform command lists will be submitted to the GPU.
	SubmitToGPU = 1 << 0,

	// Processes the delete queue until it is empty.
	DeleteResources = 1 << 1,

	// Indicates that the entire RHI thread pipeline will be flushed. 
	// If combined with DeleteResources, the pending deletes queue is processed in a loop until all released resources have been deleted.
	FlushRHIThread = 1 << 2,

	// Marks the end of an engine frame. Causes RHI draw stats etc to be accumulated,
	// and calls RHIEndFrame for platform RHIs to do various cleanup tasks.
	EndFrame = 1 << 3,

#if CAN_TOGGLE_COMMAND_LIST_BYPASS
	// Used when toggling RHI command bypass.
	EnableBypass  = 1 << 4,
	DisableBypass = 1 << 5,
#endif

#if WITH_RHI_BREADCRUMBS
	EnableDrawEvents = 1 << 6,
	DisableDrawEvents = 1 << 7
#endif
};

ENUM_CLASS_FLAGS(ERHISubmitFlags);

class FRHICommandListImmediate : public FRHICommandList
{
	friend class FRHICommandListExecutor;
	friend class FRHICommandListScopedExtendResourceLifetime;

	friend void RHI_API RHIResourceLifetimeReleaseRef(FRHICommandListImmediate&, int32);

	FRHICommandListImmediate()
		: FRHICommandList(FRHIGPUMask::All(), true)
	{
#if WITH_RHI_BREADCRUMBS
		PersistentState.LocalBreadcrumb = nullptr;
#endif

#if HAS_GPU_STATS
		PersistentState.CurrentDrawStatsCategory = nullptr;
#endif
	}

	~FRHICommandListImmediate()
	{
		FinishRecording();
	}

public:
	static inline FRHICommandListImmediate& Get();

	static inline FRHICommandListImmediate& Get(FRHICommandListBase& RHICmdList)
	{
		check(RHICmdList.IsImmediate());
		return static_cast<FRHICommandListImmediate&>(RHICmdList);
	}

	UE_DEPRECATED(5.5, "FRHICommandListImmediate::BeginScene() is deprecated and is no longer necessary. Remove any remaining calls to BeginScene(). There is no replacement.")
	void BeginScene() {}

	UE_DEPRECATED(5.5, "FRHICommandListImmediate::EndScene() is deprecated and is no longer necessary. Remove any remaining calls to EndScene(). There is no replacement.")
	void EndScene() {}

	RHI_API void BeginDrawingViewport(FRHIViewport* Viewport, FRHITexture* RenderTargetRHI);
	RHI_API void EndDrawingViewport(FRHIViewport* Viewport, bool bPresent, bool bLockToVsync);

	UE_DEPRECATED(5.5, "FRHICommandListImmediate::BeginFrame() is deprecated and is no longer necessary. Remove any remaining calls to BeginFrame(). There is no replacement.")
	void BeginFrame() {}

	RHI_API void EndFrame();

	struct FQueuedCommandList
	{
		// The command list to enqueue.
		FRHICommandListBase* CmdList = nullptr;

		FQueuedCommandList() = default;
		FQueuedCommandList(FRHICommandListBase* InCmdList)
			: CmdList(InCmdList)
		{}
	};

	enum class ETranslatePriority
	{
		Disabled, // Parallel translate is disabled. Command lists will be replayed by the RHI thread into the default context.
		Normal,   // Parallel translate is enabled, and runs on a normal priority task thread.
		High      // Parallel translate is enabled, and runs on a high priority task thread.
	};

	//
	// Chains together one or more RHI command lists into the immediate command list, allowing in-order submission of parallel rendering work.
	// The provided command lists are not dispatched until FinishRecording() is called on them, and their dispatch prerequisites have been completed.
	//

	// @todo dev-pr : deprecate
	RHI_API void QueueAsyncCommandListSubmit(TArrayView<FQueuedCommandList> CommandLists, ETranslatePriority ParallelTranslatePriority = ETranslatePriority::Disabled, int32 MinDrawsPerTranslate = 0);

	// @todo dev-pr : deprecate
	inline void QueueAsyncCommandListSubmit(FQueuedCommandList QueuedCommandList, ETranslatePriority ParallelTranslatePriority = ETranslatePriority::Disabled, int32 MinDrawsPerTranslate = 0)
	{
		QueueAsyncCommandListSubmit(MakeArrayView(&QueuedCommandList, 1), ParallelTranslatePriority, MinDrawsPerTranslate);
	}

	//
	// Dispatches work to the RHI thread and the GPU.
	// Also optionally waits for its completion on the RHI thread. Does not wait for the GPU.
	//
	RHI_API void ImmediateFlush(EImmediateFlushType::Type FlushType, ERHISubmitFlags SubmitFlags = ERHISubmitFlags::None);

	RHI_API bool StallRHIThread();
	RHI_API void UnStallRHIThread();
	RHI_API static bool IsStalled();

	RHI_API void InitializeImmediateContexts();

	template <typename LAMBDA>
	FORCEINLINE_DEBUGGABLE void EnqueueLambda(const TCHAR* LambdaName, LAMBDA&& Lambda)
	{
		if (IsBottomOfPipe())
		{
			Lambda(*this);
		}
		else
		{
			ALLOC_COMMAND(TRHILambdaCommand<FRHICommandListImmediate, LAMBDA>)(Forward<LAMBDA>(Lambda), LambdaName);
		}
	}

	template <typename LAMBDA>
	FORCEINLINE_DEBUGGABLE void EnqueueLambda(LAMBDA&& Lambda)
	{
		FRHICommandListImmediate::EnqueueLambda(TEXT("TRHILambdaCommand"), Forward<LAMBDA>(Lambda));
	}
	
	FORCEINLINE void* LockStagingBuffer(FRHIStagingBuffer* StagingBuffer, FRHIGPUFence* Fence, uint32 Offset, uint32 SizeRHI)
	{
		return GDynamicRHI->LockStagingBuffer_RenderThread(*this, StagingBuffer, Fence, Offset, SizeRHI);
	}
	
	FORCEINLINE void UnlockStagingBuffer(FRHIStagingBuffer* StagingBuffer)
	{
		GDynamicRHI->UnlockStagingBuffer_RenderThread(*this, StagingBuffer);
	}

	UE_DEPRECATED(5.5, "CopyBuffer is deprecated. Use CopyBufferRegion.")
	FORCEINLINE void CopyBuffer(FRHIBuffer* SourceBuffer, FRHIBuffer* DestBuffer)
	{
		uint64 Size = FMath::Min(SourceBuffer->GetSize(), DestBuffer->GetSize());
		CopyBufferRegion(DestBuffer, 0, SourceBuffer, 0, Size);
	}

	FORCEINLINE bool GetTextureMemoryVisualizeData(FColor* TextureData,int32 SizeX,int32 SizeY,int32 Pitch,int32 PixelSize)
	{
		QUICK_SCOPE_CYCLE_COUNTER(STAT_RHIMETHOD_GetTextureMemoryVisualizeData_Flush);
		ImmediateFlush(EImmediateFlushType::FlushRHIThread); 
		return GDynamicRHI->RHIGetTextureMemoryVisualizeData(TextureData,SizeX,SizeY,Pitch,PixelSize);
	}
	
	FORCEINLINE FTextureRHIRef AsyncReallocateTexture2D(FRHITexture* Texture2D, int32 NewMipCount, int32 NewSizeX, int32 NewSizeY, FThreadSafeCounter* RequestStatus)
	{
		LLM_SCOPE(ELLMTag::Textures);
		return GDynamicRHI->AsyncReallocateTexture2D_RenderThread(*this, Texture2D, NewMipCount, NewSizeX, NewSizeY, RequestStatus);
	}
	
	FORCEINLINE ETextureReallocationStatus FinalizeAsyncReallocateTexture2D(FRHITexture* Texture2D, bool bBlockUntilCompleted)
	{
		LLM_SCOPE(ELLMTag::Textures);
		return GDynamicRHI->FinalizeAsyncReallocateTexture2D_RenderThread(*this, Texture2D, bBlockUntilCompleted);
	}
	
	FORCEINLINE ETextureReallocationStatus CancelAsyncReallocateTexture2D(FRHITexture* Texture2D, bool bBlockUntilCompleted)
	{
		return GDynamicRHI->CancelAsyncReallocateTexture2D_RenderThread(*this, Texture2D, bBlockUntilCompleted);
	}
	
	FORCEINLINE void* LockTexture2D(FRHITexture* Texture, uint32 MipIndex, EResourceLockMode LockMode, uint32& DestStride, bool bLockWithinMiptail, bool bFlushRHIThread = true, uint64* OutLockedByteCount = nullptr)
	{
		LLM_SCOPE(ELLMTag::Textures);
		return GDynamicRHI->LockTexture2D_RenderThread(*this, Texture, MipIndex, LockMode, DestStride, bLockWithinMiptail, bFlushRHIThread, OutLockedByteCount);
	}
	
	FORCEINLINE void UnlockTexture2D(FRHITexture* Texture, uint32 MipIndex, bool bLockWithinMiptail, bool bFlushRHIThread = true)
	{		
		GDynamicRHI->UnlockTexture2D_RenderThread(*this, Texture, MipIndex, bLockWithinMiptail, bFlushRHIThread);
	}
	
	FORCEINLINE void* LockTexture2DArray(FRHITexture* Texture, uint32 TextureIndex, uint32 MipIndex, EResourceLockMode LockMode, uint32& DestStride, bool bLockWithinMiptail)
	{
		LLM_SCOPE(ELLMTag::Textures);
		return GDynamicRHI->LockTexture2DArray_RenderThread(*this, Texture, TextureIndex, MipIndex, LockMode, DestStride, bLockWithinMiptail);
	}
	
	FORCEINLINE void UnlockTexture2DArray(FRHITexture* Texture, uint32 TextureIndex, uint32 MipIndex, bool bLockWithinMiptail)
	{
		LLM_SCOPE(ELLMTag::Textures);
		GDynamicRHI->UnlockTexture2DArray_RenderThread(*this, Texture, TextureIndex, MipIndex, bLockWithinMiptail);
	}
	
	FORCEINLINE FUpdateTexture3DData BeginUpdateTexture3D(FRHITexture* Texture, uint32 MipIndex, const struct FUpdateTextureRegion3D& UpdateRegion)
	{
		checkf(UpdateRegion.DestX + UpdateRegion.Width <= Texture->GetSizeX(), TEXT("UpdateTexture3D out of bounds on X. Texture: %s, %i, %i, %i"), *Texture->GetName().ToString(), UpdateRegion.DestX, UpdateRegion.Width, Texture->GetSizeX());
		checkf(UpdateRegion.DestY + UpdateRegion.Height <= Texture->GetSizeY(), TEXT("UpdateTexture3D out of bounds on Y. Texture: %s, %i, %i, %i"), *Texture->GetName().ToString(), UpdateRegion.DestY, UpdateRegion.Height, Texture->GetSizeY());
		checkf(UpdateRegion.DestZ + UpdateRegion.Depth <= Texture->GetSizeZ(), TEXT("UpdateTexture3D out of bounds on Z. Texture: %s, %i, %i, %i"), *Texture->GetName().ToString(), UpdateRegion.DestZ, UpdateRegion.Depth, Texture->GetSizeZ());
		LLM_SCOPE(ELLMTag::Textures);
		return GDynamicRHI->RHIBeginUpdateTexture3D(*this, Texture, MipIndex, UpdateRegion);
	}

	FORCEINLINE void EndUpdateTexture3D(FUpdateTexture3DData& UpdateData)
	{
		LLM_SCOPE(ELLMTag::Textures);
		GDynamicRHI->RHIEndUpdateTexture3D(*this, UpdateData);
	}

	FORCEINLINE void EndMultiUpdateTexture3D(TArray<FUpdateTexture3DData>& UpdateDataArray)
	{
		LLM_SCOPE(ELLMTag::Textures);
		GDynamicRHI->RHIEndMultiUpdateTexture3D(*this, UpdateDataArray);
	}

	FORCEINLINE void* LockTextureCubeFace(FRHITexture* Texture, uint32 FaceIndex, uint32 ArrayIndex, uint32 MipIndex, EResourceLockMode LockMode, uint32& DestStride, bool bLockWithinMiptail)
	{
		LLM_SCOPE(ELLMTag::Textures);
		return GDynamicRHI->RHILockTextureCubeFace_RenderThread(*this, Texture, FaceIndex, ArrayIndex, MipIndex, LockMode, DestStride, bLockWithinMiptail);
	}
	
	FORCEINLINE void UnlockTextureCubeFace(FRHITexture* Texture, uint32 FaceIndex, uint32 ArrayIndex, uint32 MipIndex, bool bLockWithinMiptail)
	{
		LLM_SCOPE(ELLMTag::Textures);
		GDynamicRHI->RHIUnlockTextureCubeFace_RenderThread(*this, Texture, FaceIndex, ArrayIndex, MipIndex, bLockWithinMiptail);
	}
	
	// ReadSurfaceFloatData reads texture data into FColor
	//	pixels in other formats are converted to FColor
	FORCEINLINE void ReadSurfaceData(FRHITexture* Texture,FIntRect Rect,TArray<FColor>& OutData,FReadSurfaceDataFlags InFlags)
	{
		QUICK_SCOPE_CYCLE_COUNTER(STAT_RHIMETHOD_ReadSurfaceData_Flush);
		LLM_SCOPE(ELLMTag::Textures);
		ImmediateFlush(EImmediateFlushType::FlushRHIThread);  
		GDynamicRHI->RHIReadSurfaceData(Texture,Rect,OutData,InFlags);
	}
	
	// ReadSurfaceFloatData reads texture data into FLinearColor
	//	pixels in other formats are converted to FLinearColor
	// reading from float surfaces remaps the values into an interpolation of their {min,max} ; use RCM_MinMax to prevent that
	FORCEINLINE void ReadSurfaceData(FRHITexture* Texture, FIntRect Rect, TArray<FLinearColor>& OutData, FReadSurfaceDataFlags InFlags)
	{
		QUICK_SCOPE_CYCLE_COUNTER(STAT_RHIMETHOD_ReadSurfaceData_Flush);
		LLM_SCOPE(ELLMTag::Textures);
		ImmediateFlush(EImmediateFlushType::FlushRHIThread);
		GDynamicRHI->RHIReadSurfaceData(Texture, Rect, OutData, InFlags);
	}
	
	FORCEINLINE void MapStagingSurface(FRHITexture* Texture, void*& OutData, int32& OutWidth, int32& OutHeight, uint32 GPUIndex = INDEX_NONE)
	{
		LLM_SCOPE(ELLMTag::Textures);
		GDynamicRHI->RHIMapStagingSurface_RenderThread(*this, Texture, GPUIndex, nullptr, OutData, OutWidth, OutHeight);
	}

	FORCEINLINE void MapStagingSurface(FRHITexture* Texture, FRHIGPUFence* Fence, void*& OutData, int32& OutWidth, int32& OutHeight, uint32 GPUIndex = INDEX_NONE)
	{
		LLM_SCOPE(ELLMTag::Textures);
		GDynamicRHI->RHIMapStagingSurface_RenderThread(*this, Texture, GPUIndex, Fence, OutData, OutWidth, OutHeight);
	}
	
	FORCEINLINE void UnmapStagingSurface(FRHITexture* Texture, uint32 GPUIndex = INDEX_NONE)
	{
		LLM_SCOPE(ELLMTag::Textures);
		GDynamicRHI->RHIUnmapStagingSurface_RenderThread(*this, Texture, GPUIndex);
	}
	
	// ReadSurfaceFloatData reads texture data into FFloat16Color
	//	it only works if Texture is exactly PF_FloatRGBA (RGBA16F) !
	//	no conversion is done
	FORCEINLINE void ReadSurfaceFloatData(FRHITexture* Texture,FIntRect Rect,TArray<FFloat16Color>& OutData,ECubeFace CubeFace,int32 ArrayIndex,int32 MipIndex)
	{
		LLM_SCOPE(ELLMTag::Textures);
		GDynamicRHI->RHIReadSurfaceFloatData_RenderThread(*this, Texture,Rect,OutData,CubeFace,ArrayIndex,MipIndex);
	}

	FORCEINLINE void ReadSurfaceFloatData(FRHITexture* Texture,FIntRect Rect,TArray<FFloat16Color>& OutData,FReadSurfaceDataFlags Flags)
	{
		LLM_SCOPE(ELLMTag::Textures);
		GDynamicRHI->RHIReadSurfaceFloatData_RenderThread(*this, Texture,Rect,OutData,Flags);
	}

	FORCEINLINE void Read3DSurfaceFloatData(FRHITexture* Texture,FIntRect Rect,FIntPoint ZMinMax,TArray<FFloat16Color>& OutData, FReadSurfaceDataFlags Flags = FReadSurfaceDataFlags())
	{
		QUICK_SCOPE_CYCLE_COUNTER(STAT_RHIMETHOD_Read3DSurfaceFloatData_Flush);
		LLM_SCOPE(ELLMTag::Textures);
		ImmediateFlush(EImmediateFlushType::FlushRHIThread);  
		GDynamicRHI->RHIRead3DSurfaceFloatData(Texture,Rect,ZMinMax,OutData,Flags);
	}
	
	UE_DEPRECATED(5.5, "FRHICommandListImmediate::AcquireThreadOwnership() is deprecated. Thread ownership of the RHI is automatic, so this function is redundant.")
	FORCEINLINE void AcquireThreadOwnership()
	{}
	
	UE_DEPRECATED(5.5, "FRHICommandListImmediate::ReleaseThreadOwnership() is deprecated. Thread ownership of the RHI is automatic, so this function is redundant.")
	FORCEINLINE void ReleaseThreadOwnership()
	{}
	
	FORCEINLINE void FlushResources()
	{
		QUICK_SCOPE_CYCLE_COUNTER(STAT_RHIMETHOD_FlushResources_Flush);
		ImmediateFlush(EImmediateFlushType::FlushRHIThread); 
		 
		return GDynamicRHI->RHIFlushResources();
	}

	UE_DEPRECATED(5.5, "FlushPendingDeletes is deprecated and removed. Use RHICmdList.ImmediateFlush(EImmediateFlushType::FlushRHIThreadFlushResources)")
	inline int32 FlushPendingDeletes() { return 0; }
	
	FORCEINLINE uint32 GetGPUFrameCycles()
	{
		return RHIGetGPUFrameCycles(GetGPUMask().ToIndex());
	}

	FORCEINLINE void SubmitAndBlockUntilGPUIdle()
	{
		QUICK_SCOPE_CYCLE_COUNTER(STAT_RHIMETHOD_SubmitAndBlockUntilGPUIdle_Flush);

		// Ensure all prior work is submitted down to the GPU, and the RHI thread is idle.
		ImmediateFlush(EImmediateFlushType::FlushRHIThread);

		// Block the calling thread (the render thread) until the GPU completes all work.
		GDynamicRHI->RHIBlockUntilGPUIdle();
	}
	
	//UE_DEPRECATED(5.3, "BlockUntilGPUIdle() is deprecated. Call SubmitAndBlockUntilGPUIdle() instead.")
	FORCEINLINE void BlockUntilGPUIdle()
	{
		this->SubmitAndBlockUntilGPUIdle();
	}

	//UE_DEPRECATED(5.3, "SubmitCommandsAndFlushGPU() is deprecated. Call SubmitAndBlockUntilGPUIdle() instead.")
	FORCEINLINE_DEBUGGABLE void SubmitCommandsAndFlushGPU()
	{
		this->SubmitAndBlockUntilGPUIdle();
	}
	
	FORCEINLINE bool IsRenderingSuspended()
	{
		QUICK_SCOPE_CYCLE_COUNTER(STAT_RHIMETHOD_IsRenderingSuspended_Flush);
		ImmediateFlush(EImmediateFlushType::FlushRHIThread); 
		return GDynamicRHI->RHIIsRenderingSuspended();
	}
	
	FORCEINLINE void VirtualTextureSetFirstMipInMemory(FRHITexture* Texture, uint32 FirstMip)
	{
		GDynamicRHI->RHIVirtualTextureSetFirstMipInMemory(*this, Texture, FirstMip);
	}
	
	FORCEINLINE void VirtualTextureSetFirstMipVisible(FRHITexture* Texture, uint32 FirstMip)
	{
		GDynamicRHI->RHIVirtualTextureSetFirstMipVisible(*this, Texture, FirstMip);
	}
	
	FORCEINLINE void* GetNativeDevice()
	{
		QUICK_SCOPE_CYCLE_COUNTER(STAT_RHIMETHOD_GetNativeDevice_Flush);
		ImmediateFlush(EImmediateFlushType::FlushRHIThread); 
		 
		return GDynamicRHI->RHIGetNativeDevice();
	}
	
	FORCEINLINE void* GetNativePhysicalDevice()
	{
		QUICK_SCOPE_CYCLE_COUNTER(STAT_RHIMETHOD_GetNativePhysicalDevice_Flush);
		ImmediateFlush(EImmediateFlushType::FlushRHIThread); 
		 
		return GDynamicRHI->RHIGetNativePhysicalDevice();
	}
	
	FORCEINLINE void* GetNativeGraphicsQueue()
	{
		QUICK_SCOPE_CYCLE_COUNTER(STAT_RHIMETHOD_GetNativeGraphicsQueue_Flush);
		ImmediateFlush(EImmediateFlushType::FlushRHIThread); 
		 
		return GDynamicRHI->RHIGetNativeGraphicsQueue();
	}
	
	FORCEINLINE void* GetNativeComputeQueue()
	{
		QUICK_SCOPE_CYCLE_COUNTER(STAT_RHIMETHOD_GetNativeComputeQueue_Flush);
		ImmediateFlush(EImmediateFlushType::FlushRHIThread); 
		 
		return GDynamicRHI->RHIGetNativeComputeQueue();
	}
	
	FORCEINLINE void* GetNativeInstance()
	{
		QUICK_SCOPE_CYCLE_COUNTER(STAT_RHIMETHOD_GetNativeInstance_Flush);
		ImmediateFlush(EImmediateFlushType::FlushRHIThread);

		return GDynamicRHI->RHIGetNativeInstance();
	}
	
	FORCEINLINE void* GetNativeCommandBuffer()
	{
		return GDynamicRHI->RHIGetNativeCommandBuffer();
	}

	UE_DEPRECATED(5.5, "RHIPollRenderQueryResults is deprecated. Platform RHIs that require query polling now do this automatically as part of RHI command list submission.")
	FORCEINLINE void PollRenderQueryResults() {}

	//UE_DEPRECATED(5.1, "SubmitCommandsHint is deprecated. Consider calling ImmediateFlush(EImmediateFlushType::DispatchToRHIThread) instead.")
	FORCEINLINE_DEBUGGABLE void SubmitCommandsHint()
	{
		ImmediateFlush(EImmediateFlushType::DispatchToRHIThread);
	}
};

// All command list members should be contained within FRHICommandListBase. The Immediate/Compute/regular types are just interfaces.
static_assert(sizeof(FRHICommandListImmediate) == sizeof(FRHICommandListBase), "FRHICommandListImmediate should not contain additional members.");
static_assert(sizeof(FRHIComputeCommandList  ) == sizeof(FRHICommandListBase), "FRHIComputeCommandList should not contain additional members.");
static_assert(sizeof(FRHICommandList         ) == sizeof(FRHICommandListBase), "FRHICommandList should not contain additional members.");

class FRHICommandListScopedFlushAndExecute
{
	FRHICommandListImmediate& RHICmdList;

public:
	FRHICommandListScopedFlushAndExecute(FRHICommandListImmediate& InRHICmdList)
		: RHICmdList(InRHICmdList)
	{
		check(RHICmdList.IsTopOfPipe());
		RHICmdList.ImmediateFlush(EImmediateFlushType::FlushRHIThread);
		RHICmdList.bExecuting = true;
	}
	~FRHICommandListScopedFlushAndExecute()
	{
		RHICmdList.bExecuting = false;
	}
};

/** Takes a reference to defer deletion of RHI resources. */
void RHI_API RHIResourceLifetimeAddRef(int32 NumRefs = 1);

/** Releases a reference to defer deletion of RHI resources. If the reference count hits zero, resources are queued for deletion. */
void RHI_API RHIResourceLifetimeReleaseRef(FRHICommandListImmediate& RHICmdList, int32 NumRefs = 1);

class FRHICommandListScopedExtendResourceLifetime
{
public:
	FRHICommandListScopedExtendResourceLifetime(FRHICommandListImmediate& InRHICmdList)
		: RHICmdList(InRHICmdList)
	{
		RHIResourceLifetimeAddRef();
	}

	~FRHICommandListScopedExtendResourceLifetime()
	{
		RHIResourceLifetimeReleaseRef(RHICmdList);
	}

private:
	FRHICommandListImmediate& RHICmdList;
};

//
// Helper to activate a specific RHI pipeline within a block of renderer code.
// Allows command list recording code to switch between graphics / async compute etc.
// Restores the previous active pipeline when the scope is ended.
//
class FRHICommandListScopedPipeline
{
	FRHICommandListBase& RHICmdList;
	ERHIPipeline PreviousPipeline;

public:
	FRHICommandListScopedPipeline(FRHICommandListBase& RHICmdList, ERHIPipeline Pipeline)
		: RHICmdList(RHICmdList)
		, PreviousPipeline(RHICmdList.SwitchPipeline(Pipeline))
	{
	}

	~FRHICommandListScopedPipeline()
	{
		RHICmdList.SwitchPipeline(PreviousPipeline);
	}
};

struct FRHIScopedGPUMask
{
	FRHIComputeCommandList& RHICmdList;
	FRHIGPUMask PrevGPUMask;

	FORCEINLINE FRHIScopedGPUMask(FRHIComputeCommandList& InRHICmdList, FRHIGPUMask InGPUMask)
		: RHICmdList(InRHICmdList)
		, PrevGPUMask(InRHICmdList.GetGPUMask())
	{
		InRHICmdList.SetGPUMask(InGPUMask);
	}

	FORCEINLINE ~FRHIScopedGPUMask()
	{
		RHICmdList.SetGPUMask(PrevGPUMask);
	}

	FRHIScopedGPUMask(FRHIScopedGPUMask const&) = delete;
	FRHIScopedGPUMask(FRHIScopedGPUMask&&) = delete;
};

#if WITH_MGPU
	#define SCOPED_GPU_MASK(RHICmdList, GPUMask) FRHIScopedGPUMask PREPROCESSOR_JOIN(ScopedGPUMask, __LINE__){ RHICmdList, GPUMask }
#else
	#define SCOPED_GPU_MASK(RHICmdList, GPUMask)
#endif // WITH_MGPU

struct FScopedUniformBufferStaticBindings
{
	FScopedUniformBufferStaticBindings(FRHIComputeCommandList& InRHICmdList, FUniformBufferStaticBindings UniformBuffers)
		: RHICmdList(InRHICmdList)
	{
#if VALIDATE_UNIFORM_BUFFER_STATIC_BINDINGS
		OnScopeEnter();
#endif

		RHICmdList.SetStaticUniformBuffers(UniformBuffers);
	}

	template <typename... TArgs>
	FScopedUniformBufferStaticBindings(FRHIComputeCommandList& InRHICmdList, TArgs... Args)
		: FScopedUniformBufferStaticBindings(InRHICmdList, FUniformBufferStaticBindings{ Args... })
	{}

	~FScopedUniformBufferStaticBindings()
	{
		RHICmdList.SetStaticUniformBuffers(FUniformBufferStaticBindings());

#if VALIDATE_UNIFORM_BUFFER_STATIC_BINDINGS
		OnScopeExit();
#endif
	}

	FRHIComputeCommandList& RHICmdList;

private:
#if VALIDATE_UNIFORM_BUFFER_STATIC_BINDINGS
	RHI_API static void OnScopeEnter();
	RHI_API static void OnScopeExit();
#endif
};

#define SCOPED_UNIFORM_BUFFER_STATIC_BINDINGS(RHICmdList, UniformBuffers) FScopedUniformBufferStaticBindings PREPROCESSOR_JOIN(UniformBuffers, __LINE__){ RHICmdList, UniformBuffers }

// Helper to enable the use of graphics RHI command lists from within platform RHI implementations.
// Recorded commands are dispatched when the command list is destructed. Intended for use on the stack / in a scope block.
class FRHICommandList_RecursiveHazardous : public FRHICommandList
{
public:
	RHI_API FRHICommandList_RecursiveHazardous(IRHICommandContext* Context);
	RHI_API ~FRHICommandList_RecursiveHazardous();
};

// Helper class used internally by RHIs to make use of FRHICommandList_RecursiveHazardous safer.
// Access to the underlying context is exposed via RunOnContext() to ensure correct ordering of commands.
template <typename ContextType>
class TRHICommandList_RecursiveHazardous : public FRHICommandList_RecursiveHazardous
{
	template <typename LAMBDA>
	struct TRHILambdaCommand final : public FRHICommandBase
	{
		LAMBDA Lambda;

		TRHILambdaCommand(LAMBDA&& InLambda)
			: Lambda(Forward<LAMBDA>(InLambda))
		{}

		void ExecuteAndDestruct(FRHICommandListBase& CmdList) override final
		{
			// RunOnContext always requires the lowest level (platform) context, not the validation RHI context.
			ContextType& Context = static_cast<ContextType&>(CmdList.GetContext().GetLowestLevelContext());
			Context.BeginRecursiveCommand();

			Lambda(Context);
			Lambda.~LAMBDA();
		}
	};

public:
	TRHICommandList_RecursiveHazardous(ContextType* Context)
		: FRHICommandList_RecursiveHazardous(Context)
	{}

	template <typename LAMBDA>
	FORCEINLINE_DEBUGGABLE void RunOnContext(LAMBDA&& Lambda)
	{
		if (Bypass())
		{
			// RunOnContext always requires the lowest level (platform) context, not the validation RHI context.
			ContextType& Context = static_cast<ContextType&>(GetContext().GetLowestLevelContext());
			Context.BeginRecursiveCommand();

			Lambda(Context);
		}
		else
		{
			ALLOC_COMMAND(TRHILambdaCommand<LAMBDA>)(Forward<LAMBDA>(Lambda));
		}
	}
};

// Helper to enable the use of compute RHI command lists from within platform RHI implementations.
// Recorded commands are dispatched when the command list is destructed. Intended for use on the stack / in a scope block.
class FRHIComputeCommandList_RecursiveHazardous : public FRHIComputeCommandList
{
public:
	RHI_API FRHIComputeCommandList_RecursiveHazardous(IRHIComputeContext* Context);
	RHI_API ~FRHIComputeCommandList_RecursiveHazardous();
};

// Helper class used internally by RHIs to make use of FRHIComputeCommandList_RecursiveHazardous safer.
// Access to the underlying context is exposed via RunOnContext() to ensure correct ordering of commands.
template <typename ContextType>
class TRHIComputeCommandList_RecursiveHazardous : public FRHIComputeCommandList_RecursiveHazardous
{
	template <typename LAMBDA>
	struct TRHILambdaCommand final : public FRHICommandBase
	{
		LAMBDA Lambda;

		TRHILambdaCommand(LAMBDA&& InLambda)
			: Lambda(Forward<LAMBDA>(InLambda))
		{}

		void ExecuteAndDestruct(FRHICommandListBase& CmdList) override final
		{
			// RunOnContext always requires the lowest level (platform) context, not the validation RHI context.
			ContextType& Context = static_cast<ContextType&>(CmdList.GetComputeContext().GetLowestLevelContext());
			Context.BeginRecursiveCommand();

			Lambda(Context);
			Lambda.~LAMBDA();
		}
	};

public:
	TRHIComputeCommandList_RecursiveHazardous(ContextType* Context)
		: FRHIComputeCommandList_RecursiveHazardous(Context)
	{}

	template <typename LAMBDA>
	FORCEINLINE_DEBUGGABLE void RunOnContext(LAMBDA&& Lambda)
	{
		if (Bypass())
		{
			// RunOnContext always requires the lowest level (platform) context, not the validation RHI context.
			ContextType& Context = static_cast<ContextType&>(GetComputeContext().GetLowestLevelContext());
			Context.BeginRecursiveCommand();

			Lambda(Context);
		}
		else
		{
			ALLOC_COMMAND(TRHILambdaCommand<LAMBDA>)(Forward<LAMBDA>(Lambda));
		}
	}
};

class FRHICommandListExecutor
{
public:
	static inline FRHICommandListImmediate& GetImmediateCommandList();
	RHI_API void LatchBypass();

	RHI_API void Submit(TConstArrayView<FRHICommandListBase*> AdditionalCommandLists, ERHISubmitFlags SubmitFlags);

	RHI_API static void WaitOnRHIThreadFence(FGraphEventRef& Fence);

	//
	// Blocks the calling thread until all dispatch prerequisites of enqueued parallel command lists are completed.
	//
	RHI_API void WaitForTasks()
	{
		WaitForTasks(WaitOutstandingTasks);
	}

	//
	// Blocks the calling thread until all specified tasks are completed.
	//
	RHI_API void WaitForTasks(FGraphEventArray& OutstandingTasks);

	//
	// Blocks the calling thread until the RHI thread is idle.
	//
	UE_DEPRECATED(5.5, "FRHICommandListExecutor::WaitForRHIThreadTasks() is deprecated. Call FRHICommandListImmediate::ImmediateFlush(EImmediateFlushType::FlushRHIThread) instead.")
	inline void WaitForRHIThreadTasks()
	{
		FRHICommandListImmediate::Get().ImmediateFlush(EImmediateFlushType::FlushRHIThread);
	}

	// Global graph events must be destroyed explicitly to avoid undefined order of static destruction, as they can be destroyed after their allocator.
	void CleanupGraphEvents();

	FORCEINLINE_DEBUGGABLE bool Bypass() const
	{
#if CAN_TOGGLE_COMMAND_LIST_BYPASS
		return bLatchedBypass;
#else
		return false;
#endif
	}

	FORCEINLINE_DEBUGGABLE bool UseParallelAlgorithms() const
	{
#if CAN_TOGGLE_COMMAND_LIST_BYPASS
		return bLatchedUseParallelAlgorithms;
#else
		return  FApp::ShouldUseThreadingForPerformance() && !Bypass() && (GSupportsParallelRenderingTasksWithSeparateRHIThread || !IsRunningRHIInSeparateThread());
#endif
	}

	//
	// Returns true if any RHI dispatch, translate or submission tasks are currently running.
	// This works regardless of engine threading mode (i.e. with or without an RHI thread and parallel translate).
	// 
	// When this function returns false, we can be sure there are no threads active within the platform RHI, besides the render thread.
	//
	RHI_API static bool AreRHITasksActive();

	UE_DEPRECATED(5.5, "FRHICommandListExecutor::IsRHIThreadActive() is deprecated. Use FRHICommandListExecutor::AreRHITasksActive() instead.")
	static inline bool IsRHIThreadActive()
	{
		return AreRHITasksActive();
	}

	UE_DEPRECATED(5.5, "FRHICommandListExecutor::IsRHIThreadCompletelyFlushed() is deprecated. Use FRHICommandListExecutor::AreRHITasksActive() instead.")
	static inline bool IsRHIThreadCompletelyFlushed()
	{
		return !AreRHITasksActive();
	}

	//
	// Adds a prerequisite for subsequent Submit dispatch tasks.
	// 
	// This function should only be called from the render thread.
	//
	RHI_API void AddNextDispatchPrerequisite(FGraphEventRef Prereq);

	//
	// Gets the CompletionEvent for the most recent submit to GPU
	// 
	// This function should only be called from the render thread.
	//
	const FGraphEventRef& GetCompletionEvent() const
	{
		return CompletionEvent;
	}

	FGraphEventArray WaitOutstandingTasks;

private:
	bool bLatchedBypass = false;
	bool bLatchedUseParallelAlgorithms = false;
#if WITH_RHI_BREADCRUMBS
	bool bEmitBreadcrumbs = false;
#endif

	friend class FRHICommandListBase;
	friend class FRHICommandListImmediate;
	FRHICommandListImmediate CommandListImmediate;

	//
	// Helper for efficiently enqueuing work to TaskGraph threads. Work items within a single pipe are always executed in-order (FIFO) even if they have no prerequisites.
	// Uses an atomic compare-and-swap mechanism to append new tasks to the end of existing ones, avoiding the overhead of having the TaskGraph itself do the task scheduling.
	//
	class FTaskPipe
	{
		struct FTask;

		FTask* Current = nullptr;
		FGraphEventRef LastEvent = nullptr;
		TOptional<ENamedThreads::Type> LastThread {};

		FGraphEventRef LaunchTask(FTask* Task) const;
		void Execute(FTask* Task, FGraphEventRef const& CurrentEvent) const;

	public:	
		// Enqueues the given lambda to run on the named thread.
		void Enqueue(ENamedThreads::Type NamedThread, FGraphEventArray&& Prereqs, TFunction<void()>&& Lambda);

		// Returns a graph event that will be signalled once all work submitted prior to calling Close() has completed.
		FGraphEventRef Close();

		void CleanupGraphEvents()
		{
			LastEvent = nullptr;
		}
	};

	FTaskPipe DispatchPipe;
	FTaskPipe RHIThreadPipe;

	// One per RHI context array, multiple RHICmdLists replayed into it
	struct FTranslateState
	{
		struct FPipelineState
		{
#if WITH_RHI_BREADCRUMBS
			FRHIBreadcrumbRange Range {};
#endif
			IRHIComputeContext* Context = nullptr;
			IRHIPlatformCommandList* FinalizedCmdList = nullptr;
		};
		TRHIPipelineArray<FPipelineState> PipelineStates {};
		IRHIUploadContext* UploadContextState = nullptr;
		

#if WITH_RHI_BREADCRUMBS
		FRHIBreadcrumbAllocatorArray BreadcrumbAllocatorRefs {};
#endif

		FTaskPipe TranslatePipe;
		uint32 NumCommands = 0;
		bool bParallel = false;

		FRHIDrawStats DrawStats{};

		FTaskPipe* EnqueueTranslateTask(FGraphEventArray&& Prereqs, TFunction<void()>&& Lambda);

		void Translate(FRHICommandListBase* CmdList);
		FGraphEventRef Finalize();
	};

	// One per call to RHISubmitCommandLists
	struct FSubmitState
	{
		FGraphEventRef CompletionEvent;

		TArray<TUniquePtr<FTranslateState>> TranslateJobs;
		FGraphEventArray TranslateEvents;
		FTranslateState* CurrentTranslateJob = nullptr;

		int32 MaxCommandsPerTranslate = 0;
		bool bAllowSingleParallelCombine = false;
		bool bAllowParallelTranslate = true;

#if WITH_RHI_BREADCRUMBS
		bool bEmitBreadcrumbs = false;
#endif

		FRHIDrawStats DrawStats {};

		ERHISubmitFlags SubmitFlags = ERHISubmitFlags::None;
		TArray<FRHIResource*> ResourcesToDelete {};
		bool bIncludeExtendedLifetimeResources = false;

		void Dispatch(FRHICommandListBase* CmdList);

		struct FSubmitArgs
		{
#if WITH_RHI_BREADCRUMBS
			TRHIPipelineArray<FRHIBreadcrumbNode*> GPUBreadcrumbs;
#endif
		};
		void Submit(const FSubmitArgs& Args);
		void FinalizeCurrent();
	} *SubmitState = nullptr;

	FGraphEventRef LastMutate;
	FGraphEventRef LastSubmit;
	FGraphEventRef CompletionEvent;

	FTaskPipe* EnqueueDispatchTask(FGraphEventArray&& Prereqs, TFunction<void()>&& Lambda);
	FTaskPipe* EnqueueSubmitTask  (FGraphEventArray&& Prereqs, TFunction<void()>&& Lambda);
	FGraphEventArray NextDispatchTaskPrerequisites;

#if WITH_RHI_BREADCRUMBS

	struct FBreadcrumbState
	{
		FRHIBreadcrumbNodeRef Current{}; // Used by dispatch thread
		FRHIBreadcrumbNodeRef Last   {}; // Used by submit thread
	};

	struct
	{
		FBreadcrumbState CPU {};
		TRHIPipelineArray<FBreadcrumbState> GPU { InPlace };
	} Breadcrumbs {};
	
#endif

#if HAS_GPU_STATS
	FRHIDrawStatsCategory const* CurrentDrawStatsCategory = nullptr;
#endif
	FRHIDrawStats FrameDrawStats;

	// Counts the number of calls to RHIEndFrame, and is used in GPU profiler frame boundary events.
	uint32 FrameNumber = 0;

	bool AllowParallel() const;
};

extern RHI_API FRHICommandListExecutor GRHICommandList;

extern RHI_API FAutoConsoleTaskPriority CPrio_SceneRenderingTask;

/** Used to separate which command list is used for ray tracing operations. */
UE_DEPRECATED(5.5, "Use FRHICommandList instead.")
typedef FRHICommandListImmediate FRHIRayTracingCommandList;

class FRenderTask
{
public:
	FORCEINLINE static ENamedThreads::Type GetDesiredThread()
	{
		return CPrio_SceneRenderingTask.Get();
	}
};

FORCEINLINE FRHICommandListImmediate& FRHICommandListImmediate::Get()
{
	check(IsInRenderingThread());
	return FRHICommandListExecutor::GetImmediateCommandList();
}

FORCEINLINE_DEBUGGABLE FRHICommandListImmediate& FRHICommandListExecutor::GetImmediateCommandList()
{
	// @todo - fix remaining use of the immediate command list on other threads, then uncomment this check.
	//check(IsInRenderingThread());
	return GRHICommandList.CommandListImmediate;
}

FORCEINLINE FTextureReferenceRHIRef RHICreateTextureReference(FRHITexture* InReferencedTexture = nullptr)
{
	return FRHICommandListImmediate::Get().CreateTextureReference(InReferencedTexture);
}

FORCEINLINE void RHIUpdateTextureReference(FRHITextureReference* TextureRef, FRHITexture* NewTexture)
{
	FRHICommandListImmediate::Get().UpdateTextureReference(TextureRef, NewTexture);
}

FORCEINLINE FTextureRHIRef RHICreateTexture(const FRHITextureCreateDesc& CreateDesc)
{
	return FRHICommandListImmediate::Get().CreateTexture(CreateDesc);
}

UE_DEPRECATED(5.4, "Use the RHIAsyncCreateTexture2D function that takes an DebugName.")
FORCEINLINE FTextureRHIRef RHIAsyncCreateTexture2D(uint32 SizeX, uint32 SizeY, uint8 Format, uint32 NumMips, ETextureCreateFlags Flags, ERHIAccess InResourceState, void** InitialMipData, uint32 NumInitialMips, FGraphEventRef& OutCompletionEvent)
{
	LLM_SCOPE(EnumHasAnyFlags(Flags, TexCreate_RenderTargetable | TexCreate_DepthStencilTargetable) ? ELLMTag::RenderTargets : ELLMTag::Textures);
	const ERHIAccess ResourceState = InResourceState == ERHIAccess::Unknown ? RHIGetDefaultResourceState((ETextureCreateFlags)Flags, InitialMipData != nullptr) : InResourceState;
	return GDynamicRHI->RHIAsyncCreateTexture2D(SizeX, SizeY, Format, NumMips, Flags, ResourceState, InitialMipData, NumInitialMips, TEXT("RHIAsyncCreateTexture2D"), OutCompletionEvent);
}

FORCEINLINE FTextureRHIRef RHIAsyncCreateTexture2D(uint32 SizeX, uint32 SizeY, uint8 Format, uint32 NumMips, ETextureCreateFlags Flags, ERHIAccess InResourceState, void** InitialMipData, uint32 NumInitialMips, const TCHAR* DebugName, FGraphEventRef& OutCompletionEvent)
{
	LLM_SCOPE(EnumHasAnyFlags(Flags, TexCreate_RenderTargetable | TexCreate_DepthStencilTargetable) ? ELLMTag::RenderTargets : ELLMTag::Textures);
	const ERHIAccess ResourceState = InResourceState == ERHIAccess::Unknown ? RHIGetDefaultResourceState((ETextureCreateFlags)Flags, InitialMipData != nullptr) : InResourceState;
	return GDynamicRHI->RHIAsyncCreateTexture2D(SizeX, SizeY, Format, NumMips, Flags, ResourceState, InitialMipData, NumInitialMips, DebugName, OutCompletionEvent);
}

UE_DEPRECATED(5.4, "Use the RHIAsyncCreateTexture2D function that takes an InResourceState and DebugName.")
FORCEINLINE FTextureRHIRef RHIAsyncCreateTexture2D(uint32 SizeX, uint32 SizeY, uint8 Format, uint32 NumMips, ETextureCreateFlags Flags, void** InitialMipData, uint32 NumInitialMips, FGraphEventRef& OutCompletionEvent)
{
PRAGMA_DISABLE_DEPRECATION_WARNINGS
	return RHIAsyncCreateTexture2D(SizeX, SizeY, Format, NumMips, Flags, ERHIAccess::Unknown, InitialMipData, NumInitialMips, OutCompletionEvent);
PRAGMA_ENABLE_DEPRECATION_WARNINGS
}

FORCEINLINE FTextureRHIRef RHIAsyncReallocateTexture2D(FRHITexture* Texture2D, int32 NewMipCount, int32 NewSizeX, int32 NewSizeY, FThreadSafeCounter* RequestStatus)
{
	return FRHICommandListExecutor::GetImmediateCommandList().AsyncReallocateTexture2D(Texture2D, NewMipCount, NewSizeX, NewSizeY, RequestStatus);
}

FORCEINLINE ETextureReallocationStatus RHIFinalizeAsyncReallocateTexture2D(FRHITexture* Texture2D, bool bBlockUntilCompleted)
{
	return FRHICommandListExecutor::GetImmediateCommandList().FinalizeAsyncReallocateTexture2D(Texture2D, bBlockUntilCompleted);
}

FORCEINLINE ETextureReallocationStatus RHICancelAsyncReallocateTexture2D(FRHITexture* Texture2D, bool bBlockUntilCompleted)
{
	return FRHICommandListExecutor::GetImmediateCommandList().CancelAsyncReallocateTexture2D(Texture2D, bBlockUntilCompleted);
}

FORCEINLINE void* RHILockTexture2D(FRHITexture* Texture, uint32 MipIndex, EResourceLockMode LockMode, uint32& DestStride, bool bLockWithinMiptail, bool bFlushRHIThread = true, uint64* OutLockedByteCount = nullptr)
{
	return FRHICommandListExecutor::GetImmediateCommandList().LockTexture2D(Texture, MipIndex, LockMode, DestStride, bLockWithinMiptail, bFlushRHIThread, OutLockedByteCount);
}

FORCEINLINE void RHIUnlockTexture2D(FRHITexture* Texture, uint32 MipIndex, bool bLockWithinMiptail, bool bFlushRHIThread = true)
{
	 FRHICommandListExecutor::GetImmediateCommandList().UnlockTexture2D(Texture, MipIndex, bLockWithinMiptail, bFlushRHIThread);
}

FORCEINLINE void* RHILockTexture2DArray(FRHITexture* Texture, uint32 TextureIndex, uint32 MipIndex, EResourceLockMode LockMode, uint32& DestStride, bool bLockWithinMiptail)
{
	return FRHICommandListExecutor::GetImmediateCommandList().LockTexture2DArray(Texture, TextureIndex, MipIndex, LockMode, DestStride, bLockWithinMiptail);
}

FORCEINLINE void RHIUnlockTexture2DArray(FRHITexture* Texture, uint32 TextureIndex, uint32 MipIndex, bool bLockWithinMiptail)
{
	 FRHICommandListExecutor::GetImmediateCommandList().UnlockTexture2DArray(Texture, TextureIndex, MipIndex, bLockWithinMiptail);
}

FORCEINLINE void RHIUpdateTexture2D(FRHITexture* Texture, uint32 MipIndex, const struct FUpdateTextureRegion2D& UpdateRegion, uint32 SourcePitch, const uint8* SourceData)
{
	 FRHICommandListExecutor::GetImmediateCommandList().UpdateTexture2D(Texture, MipIndex, UpdateRegion, SourcePitch, SourceData);
}

FORCEINLINE FUpdateTexture3DData RHIBeginUpdateTexture3D(FRHITexture* Texture, uint32 MipIndex, const struct FUpdateTextureRegion3D& UpdateRegion)
{
	return FRHICommandListExecutor::GetImmediateCommandList().BeginUpdateTexture3D(Texture, MipIndex, UpdateRegion);
}

FORCEINLINE void RHIEndUpdateTexture3D(FUpdateTexture3DData& UpdateData)
{
	FRHICommandListExecutor::GetImmediateCommandList().EndUpdateTexture3D(UpdateData);
}

FORCEINLINE void RHIEndMultiUpdateTexture3D(TArray<FUpdateTexture3DData>& UpdateDataArray)
{
	FRHICommandListExecutor::GetImmediateCommandList().EndMultiUpdateTexture3D(UpdateDataArray);
}

FORCEINLINE void RHIUpdateTexture3D(FRHITexture* Texture, uint32 MipIndex, const struct FUpdateTextureRegion3D& UpdateRegion, uint32 SourceRowPitch, uint32 SourceDepthPitch, const uint8* SourceData)
{
	 FRHICommandListExecutor::GetImmediateCommandList().UpdateTexture3D(Texture, MipIndex, UpdateRegion, SourceRowPitch, SourceDepthPitch, SourceData);
}

FORCEINLINE void* RHILockTextureCubeFace(FRHITexture* Texture, uint32 FaceIndex, uint32 ArrayIndex, uint32 MipIndex, EResourceLockMode LockMode, uint32& DestStride, bool bLockWithinMiptail)
{
	return FRHICommandListExecutor::GetImmediateCommandList().LockTextureCubeFace(Texture, FaceIndex, ArrayIndex, MipIndex, LockMode, DestStride, bLockWithinMiptail);
}

FORCEINLINE void RHIUnlockTextureCubeFace(FRHITexture* Texture, uint32 FaceIndex, uint32 ArrayIndex, uint32 MipIndex, bool bLockWithinMiptail)
{
	 FRHICommandListExecutor::GetImmediateCommandList().UnlockTextureCubeFace(Texture, FaceIndex, ArrayIndex, MipIndex, bLockWithinMiptail);
}

UE_DEPRECATED(5.5, "RHIAcquireThreadOwnership() is deprecated. Thread ownership of the RHI is automatic, so this function is redundant.")
FORCEINLINE void RHIAcquireThreadOwnership()
{}

UE_DEPRECATED(5.5, "RHIReleaseThreadOwnership() is deprecated. Thread ownership of the RHI is automatic, so this function is redundant.")
FORCEINLINE void RHIReleaseThreadOwnership()
{}

FORCEINLINE void RHIFlushResources()
{
	return FRHICommandListExecutor::GetImmediateCommandList().FlushResources();
}

FORCEINLINE void RHIVirtualTextureSetFirstMipInMemory(FRHITexture* Texture, uint32 FirstMip)
{
	 FRHICommandListExecutor::GetImmediateCommandList().VirtualTextureSetFirstMipInMemory(Texture, FirstMip);
}

FORCEINLINE void RHIVirtualTextureSetFirstMipVisible(FRHITexture* Texture, uint32 FirstMip)
{
	 FRHICommandListExecutor::GetImmediateCommandList().VirtualTextureSetFirstMipVisible(Texture, FirstMip);
}

FORCEINLINE void* RHIGetNativeDevice()
{
	return FRHICommandListExecutor::GetImmediateCommandList().GetNativeDevice();
}

FORCEINLINE void* RHIGetNativePhysicalDevice()
{
	return FRHICommandListExecutor::GetImmediateCommandList().GetNativePhysicalDevice();
}

FORCEINLINE void* RHIGetNativeGraphicsQueue()
{
	return FRHICommandListExecutor::GetImmediateCommandList().GetNativeGraphicsQueue();
}

FORCEINLINE void* RHIGetNativeComputeQueue()
{
	return FRHICommandListExecutor::GetImmediateCommandList().GetNativeComputeQueue();
}

FORCEINLINE void* RHIGetNativeInstance()
{
	return FRHICommandListExecutor::GetImmediateCommandList().GetNativeInstance();
}

FORCEINLINE void* RHIGetNativeCommandBuffer()
{
	return FRHICommandListExecutor::GetImmediateCommandList().GetNativeCommandBuffer();
}

FORCEINLINE FRHIShaderLibraryRef RHICreateShaderLibrary(EShaderPlatform Platform, FString const& FilePath, FString const& Name)
{
    return GDynamicRHI->RHICreateShaderLibrary(Platform, FilePath, Name);
}

FORCEINLINE void* RHILockStagingBuffer(FRHIStagingBuffer* StagingBuffer, uint32 Offset, uint32 Size)
{
	return FRHICommandListExecutor::GetImmediateCommandList().LockStagingBuffer(StagingBuffer, nullptr, Offset, Size);
}

FORCEINLINE void* RHILockStagingBuffer(FRHIStagingBuffer* StagingBuffer, FRHIGPUFence* Fence, uint32 Offset, uint32 Size)
{
	return FRHICommandListExecutor::GetImmediateCommandList().LockStagingBuffer(StagingBuffer, Fence, Offset, Size);
}

FORCEINLINE void RHIUnlockStagingBuffer(FRHIStagingBuffer* StagingBuffer)
{
	 FRHICommandListExecutor::GetImmediateCommandList().UnlockStagingBuffer(StagingBuffer);
}

FORCEINLINE FRayTracingGeometryRHIRef RHICreateRayTracingGeometry(const FRayTracingGeometryInitializer& Initializer)
{
	return FRHICommandListExecutor::GetImmediateCommandList().CreateRayTracingGeometry(Initializer);
}

FORCEINLINE FRayTracingAccelerationStructureSize RHICalcRayTracingGeometrySize(const FRayTracingGeometryInitializer& Initializer)
{
	return GDynamicRHI->RHICalcRayTracingGeometrySize(Initializer);
}

FORCEINLINE void RHIBindDebugLabelName(FRHITexture* Texture, const TCHAR* Name)
{
	FRHICommandListImmediate::Get().BindDebugLabelName(Texture, Name);
}

FORCEINLINE void RHIBindDebugLabelName(FRHIBuffer* Buffer, const TCHAR* Name)
{
	FRHICommandListImmediate::Get().BindDebugLabelName(Buffer, Name);
}

FORCEINLINE void RHIBindDebugLabelName(FRHIUnorderedAccessView* UnorderedAccessViewRHI, const TCHAR* Name)
{
	FRHICommandListImmediate::Get().BindDebugLabelName(UnorderedAccessViewRHI, Name);
}

namespace UE::RHI
{

	//
	// Copies shared mip levels from one texture to another.
	// Both textures must have full mip chains, share the same format, and have the same aspect ratio.
	// The source texture must be in the CopySrc state, and the destination texture must be in the CopyDest state.
	// 
	RHI_API void CopySharedMips(FRHICommandList& RHICmdList, FRHITexture* SrcTexture, FRHITexture* DstTexture);

	//
	// Same as CopySharedMips(), but assumes both source and destination textures are in the SRVMask state.
	// Adds transitions to move the textures to/from the CopySrc/CopyDest states, restoring SRVMask when done.
	//
	// Provided for backwards compatibility. Caller should prefer CopySharedMips() with optimally batched transitions.
	//
	RHI_API void CopySharedMips_AssumeSRVMaskState(FRHICommandList& RHICmdList, FRHITexture* SrcTexture, FRHITexture* DstTexture);

	// Backwards compatibility adaptor to convert new FRHIBatchedShaderParameters to legacy FRayTracingShaderBindings.
	// This function will be deprecated in a future release, once legacy FRayTracingShaderBindings is removed.
	RHI_API FRayTracingShaderBindings ConvertRayTracingShaderBindings(const FRHIBatchedShaderParameters& BatchedParameters);

} //! UE::RHI

#undef RHICOMMAND_CALLSTACK

#include "RHICommandList.inl"
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreTypes.h"
#include "Misc/AssertionMacros.h"
#include "HAL/UnrealMemory.h"
#include "Containers/Array.h"
#include "Misc/Crc.h"
#include "Containers/UnrealString.h"
#include "UObject/NameTypes.h"
#include "Math/Color.h"
#include "Containers/StaticArray.h"
#include "HAL/ThreadSafeCounter.h"
#include "Templates/RefCounting.h"
#include "PixelFormat.h"
#include "Async/TaskGraphFwd.h"
#include "RHIFwd.h"
#include "RHIImmutableSamplerState.h"
#include "RHITransition.h"
#include "MultiGPU.h"
#include "Math/IntPoint.h"
#include "Math/IntRect.h"
#include "Math/IntVector.h"
#include "Misc/SecureHash.h"

#include <atomic>

class FHazardPointerCollection;
class FRHIComputeCommandList;
class FRHICommandListImmediate;
class FRHITextureReference;
class FRHIShaderBindingLayout;
class FResourceBulkDataInterface;
class FResourceArrayInterface;
struct FResourceArrayUploadInterface;

struct FClearValueBinding;
struct FRHIResourceInfo;
struct FGenerateMipsStruct;
enum class EClearBinding;

typedef TArray<FGraphEventRef, TInlineAllocator<4> > FGraphEventArray;

/** The base type of RHI resources. */
class FRHIResource
{
public:
	RHI_API FRHIResource(ERHIResourceType InResourceType);

protected:
	// RHI resources should only be destructed via the deletion queue,
	// so this is protected to prevent others from 'delete'ing these directly.
	RHI_API virtual ~FRHIResource();

private:
	// Separate function to avoid force inlining this everywhere. Helps both for code size and performance.
	RHI_API void MarkForDelete() const;

	friend class FDynamicRHI;
	friend class FRHICommandListExecutor;
	static RHI_API void DeleteResources(TArray<FRHIResource*> const& Resources);
	static RHI_API void GatherResourcesToDelete(TArray<FRHIResource*>& OutResources, bool bIncludeExtendedLifetimeResources);

public:
	FORCEINLINE_DEBUGGABLE uint32 AddRef() const
	{
		int32 NewValue = AtomicFlags.AddRef(std::memory_order_acquire);
		checkSlow(NewValue > 0); 
		return uint32(NewValue);
	}

	FORCEINLINE_DEBUGGABLE uint32 Release() const
	{
		int32 NewValue = AtomicFlags.Release(std::memory_order_release);
		check(NewValue >= 0);

		if (NewValue == 0)
		{
			MarkForDelete();
		}
		checkSlow(NewValue >= 0);
		return uint32(NewValue);
	}

	FORCEINLINE_DEBUGGABLE uint32 GetRefCount() const
	{
		int32 CurrentValue = AtomicFlags.GetNumRefs(std::memory_order_relaxed);
		checkSlow(CurrentValue >= 0); 
		return uint32(CurrentValue);
	}

	UE_DEPRECATED(5.5, "Don't call Bypass() on an FRHIResource. Use the Bypass() function on an FRHICommandList instance, or the FRHICommmandListExecutor.")
	RHI_API static bool Bypass();

	bool IsValid() const
	{
		return AtomicFlags.IsValid(std::memory_order_relaxed);
	}

	void DisableLifetimeExtension()
	{
		ensureMsgf(IsValid(), TEXT("Resource is already marked for deletion. This call is a no-op. DisableLifetimeExtension must be called while still holding a live reference."));
		bAllowExtendLifetime = false;
	}

	inline ERHIResourceType GetType() const { return ResourceType; }

	RHI_API FName GetOwnerName() const;
	RHI_API void SetOwnerName(const FName& InOwnerName);

#if RHI_ENABLE_RESOURCE_INFO
	// Get resource info if available.
	// Should return true if the ResourceInfo was filled with data.
	RHI_API virtual bool GetResourceInfo(FRHIResourceInfo& OutResourceInfo) const;

	static void BeginTrackingResource(FRHIResource* InResource);
	static void EndTrackingResource(FRHIResource* InResource);
	static void StartTrackingAllResources();
	static void StopTrackingAllResources();
#endif

private:
	class FAtomicFlags
	{
		static constexpr uint32 MarkedForDeleteBit    = 1 << 30;
		static constexpr uint32 DeletingBit           = 1 << 31;
		static constexpr uint32 NumRefsMask           = ~(MarkedForDeleteBit | DeletingBit);

		std::atomic_uint Packed = { 0 };

	public:
		int32 AddRef(std::memory_order MemoryOrder)
		{
			uint32 OldPacked = Packed.fetch_add(1, MemoryOrder);
			checkf((OldPacked & DeletingBit) == 0, TEXT("Resource is being deleted."));
			int32  NumRefs = (OldPacked & NumRefsMask) + 1;
			checkf(NumRefs < NumRefsMask, TEXT("Reference count has overflowed."));
			return NumRefs;
		}

		int32 Release(std::memory_order MemoryOrder)
		{
			uint32 OldPacked = Packed.fetch_sub(1, MemoryOrder);
			checkf((OldPacked & DeletingBit) == 0, TEXT("Resource is being deleted."));
			int32  NumRefs = (OldPacked & NumRefsMask) - 1;
			checkf(NumRefs >= 0, TEXT("Reference count has underflowed."));
			return NumRefs;
		}

		bool MarkForDelete(std::memory_order MemoryOrder)
		{
			uint32 OldPacked = Packed.fetch_or(MarkedForDeleteBit, MemoryOrder);
			check((OldPacked & DeletingBit) == 0);
			return (OldPacked & MarkedForDeleteBit) != 0;
		}

		bool UnmarkForDelete(std::memory_order MemoryOrder)
		{
			uint32 OldPacked = Packed.fetch_xor(MarkedForDeleteBit, MemoryOrder);
			check((OldPacked & DeletingBit) == 0);
			bool  OldMarkedForDelete = (OldPacked & MarkedForDeleteBit) != 0;
			check(OldMarkedForDelete == true);
			return OldMarkedForDelete;
		}

		bool Deleting()
		{
			uint32 LocalPacked = Packed.load(std::memory_order_acquire);
			check((LocalPacked & MarkedForDeleteBit) != 0);
			check((LocalPacked & DeletingBit) == 0);
			uint32 NumRefs = LocalPacked & NumRefsMask;

			if (NumRefs == 0) // caches can bring dead objects back to life
			{
#if DO_CHECK
				Packed.fetch_or(DeletingBit, std::memory_order_acquire);
#endif
				return true;
			}
			else
			{
				UnmarkForDelete(std::memory_order_release);
				return false;
			}
		}

		bool IsValid(std::memory_order MemoryOrder)
		{
			uint32 LocalPacked = Packed.load(MemoryOrder);
			return (LocalPacked & MarkedForDeleteBit) == 0 && (LocalPacked & NumRefsMask) != 0;
		}

		bool IsMarkedForDelete(std::memory_order MemoryOrder)
		{
			return (Packed.load(MemoryOrder) & MarkedForDeleteBit) != 0;
		}

		int32 GetNumRefs(std::memory_order MemoryOrder)
		{
			return Packed.load(MemoryOrder) & NumRefsMask;
		}
	};
	mutable FAtomicFlags AtomicFlags;

	const ERHIResourceType ResourceType;
	uint8 bCommitted : 1;
	uint8 bAllowExtendLifetime : 1;
#if RHI_ENABLE_RESOURCE_INFO
	uint8 bBeingTracked : 1;
	FName OwnerName;
#endif

#if DO_CHECK
	static thread_local FRHIResource const* CurrentlyDeleting;
#endif

	friend FRHICommandListImmediate;
};

enum class EClearBinding
{
	ENoneBound, //no clear color associated with this target.  Target will not do hardware clears on most platforms
	EColorBound, //target has a clear color bound.  Clears will use the bound color, and do hardware clears.
	EDepthStencilBound, //target has a depthstencil value bound.  Clears will use the bound values and do hardware clears.
};

struct FClearValueBinding
{
	struct DSVAlue
	{
		float Depth;
		uint32 Stencil;
	};

	FClearValueBinding()
		: ColorBinding(EClearBinding::EColorBound)
	{
		Value.Color[0] = 0.0f;
		Value.Color[1] = 0.0f;
		Value.Color[2] = 0.0f;
		Value.Color[3] = 0.0f;
	}

	FClearValueBinding(EClearBinding NoBinding)
		: ColorBinding(NoBinding)
	{
		check(ColorBinding == EClearBinding::ENoneBound);

		Value.Color[0] = 0.0f;
		Value.Color[1] = 0.0f;
		Value.Color[2] = 0.0f;
		Value.Color[3] = 0.0f;

		Value.DSValue.Depth = 0.0f;
		Value.DSValue.Stencil = 0;
	}

	explicit FClearValueBinding(const FLinearColor& InClearColor)
		: ColorBinding(EClearBinding::EColorBound)
	{
		Value.Color[0] = InClearColor.R;
		Value.Color[1] = InClearColor.G;
		Value.Color[2] = InClearColor.B;
		Value.Color[3] = InClearColor.A;
	}

	explicit FClearValueBinding(float DepthClearValue, uint32 StencilClearValue = 0)
		: ColorBinding(EClearBinding::EDepthStencilBound)
	{
		Value.DSValue.Depth = DepthClearValue;
		Value.DSValue.Stencil = StencilClearValue;
	}

	FLinearColor GetClearColor() const
	{
		ensure(ColorBinding == EClearBinding::EColorBound);
		return FLinearColor(Value.Color[0], Value.Color[1], Value.Color[2], Value.Color[3]);
	}

	void GetDepthStencil(float& OutDepth, uint32& OutStencil) const
	{
		ensure(ColorBinding == EClearBinding::EDepthStencilBound);
		OutDepth = Value.DSValue.Depth;
		OutStencil = Value.DSValue.Stencil;
	}

	bool operator==(const FClearValueBinding& Other) const
	{
		if (ColorBinding == Other.ColorBinding)
		{
			if (ColorBinding == EClearBinding::EColorBound)
			{
				return
					Value.Color[0] == Other.Value.Color[0] &&
					Value.Color[1] == Other.Value.Color[1] &&
					Value.Color[2] == Other.Value.Color[2] &&
					Value.Color[3] == Other.Value.Color[3];

			}
			if (ColorBinding == EClearBinding::EDepthStencilBound)
			{
				return
					Value.DSValue.Depth == Other.Value.DSValue.Depth &&
					Value.DSValue.Stencil == Other.Value.DSValue.Stencil;
			}
			return true;
		}
		return false;
	}

	friend inline uint32 GetTypeHash(FClearValueBinding const& Binding)
	{
		uint32 Hash = GetTypeHash(Binding.ColorBinding);

		if (Binding.ColorBinding == EClearBinding::EColorBound)
		{
			Hash = HashCombine(Hash, GetTypeHash(Binding.Value.Color[0]));
			Hash = HashCombine(Hash, GetTypeHash(Binding.Value.Color[1]));
			Hash = HashCombine(Hash, GetTypeHash(Binding.Value.Color[2]));
			Hash = HashCombine(Hash, GetTypeHash(Binding.Value.Color[3]));
		}
		else if (Binding.ColorBinding == EClearBinding::EDepthStencilBound)
		{
			Hash = HashCombine(Hash, GetTypeHash(Binding.Value.DSValue.Depth  ));
			Hash = HashCombine(Hash, GetTypeHash(Binding.Value.DSValue.Stencil));
		}

		return Hash;
	}

	EClearBinding ColorBinding;

	union ClearValueType
	{
		float Color[4];
		DSVAlue DSValue;
	} Value;

	// common clear values
	static RHI_API const FClearValueBinding None;
	static RHI_API const FClearValueBinding Black;
	static RHI_API const FClearValueBinding BlackMaxAlpha;
	static RHI_API const FClearValueBinding White;
	static RHI_API const FClearValueBinding Transparent;
	static RHI_API const FClearValueBinding DepthOne;
	static RHI_API const FClearValueBinding DepthZero;
	static RHI_API const FClearValueBinding DepthNear;
	static RHI_API const FClearValueBinding DepthFar;	
	static RHI_API const FClearValueBinding Green;
	static RHI_API const FClearValueBinding DefaultNormal8Bit;
};

struct FRHIResourceCreateInfo
{
	FRHIResourceCreateInfo(const TCHAR* InDebugName)
		: DebugName(InDebugName)
	{
		check(InDebugName);
	}

	// for CreateTexture calls
	UE_DEPRECATED(5.5, "Please use FRHITextureCreateDesc for creating Textures with Bulk Data")
	FRHIResourceCreateInfo(const TCHAR* InDebugName, FResourceBulkDataInterface* InBulkData)
		: FRHIResourceCreateInfo(InDebugName)
	{
PRAGMA_DISABLE_DEPRECATION_WARNINGS
		BulkData = InBulkData;
PRAGMA_ENABLE_DEPRECATION_WARNINGS
	}

	// for CreateBuffer calls
	FRHIResourceCreateInfo(const TCHAR* InDebugName, FResourceArrayUploadInterface* InResourceArray)
		: FRHIResourceCreateInfo(InDebugName)
	{
		ResourceArray = InResourceArray;
	}

	UE_DEPRECATED(5.5, "Please use FRHITextureCreateDesc for creating Textures with a Clear Value Binding")
	FRHIResourceCreateInfo(const TCHAR* InDebugName, const FClearValueBinding& InClearValueBinding)
		: FRHIResourceCreateInfo(InDebugName)
	{
PRAGMA_DISABLE_DEPRECATION_WARNINGS
		ClearValueBinding = InClearValueBinding;
PRAGMA_ENABLE_DEPRECATION_WARNINGS
	}

	UE_DEPRECATED(5.5, "Please use FRHITextureCreateDesc for creating Textures with Ext Data")
	FRHIResourceCreateInfo(uint32 InExtData)
		: FRHIResourceCreateInfo(TEXT(""))
	{
PRAGMA_DISABLE_DEPRECATION_WARNINGS
		ExtData = InExtData;
PRAGMA_ENABLE_DEPRECATION_WARNINGS
	}

	FName GetTraceClassName() const									{ const static FLazyName FRHIBufferName(TEXT("FRHIBuffer")); return (ClassName == NAME_None) ? FRHIBufferName : ClassName; }

	// for CreateTexture calls
	UE_DEPRECATED(5.5, "Please use FRHITextureCreateDesc for creating Textures with Bulk Data")
	FResourceBulkDataInterface* BulkData = nullptr;

	// for CreateBuffer calls
	FResourceArrayUploadInterface* ResourceArray = nullptr;

	// for binding clear colors to render targets.
	UE_DEPRECATED(5.5, "Please use FRHITextureCreateDesc for creating Textures with a Clear Value Binding")
	FClearValueBinding ClearValueBinding = FClearValueBinding(FLinearColor::Transparent);

	// set of GPUs on which to create the resource
	FRHIGPUMask GPUMask = FRHIGPUMask::All();

	// whether to create an RHI object with no underlying resource
	bool bWithoutNativeResource = false;

	// optional data that would have come from an offline cooker or whatever - general purpose
	UE_DEPRECATED(5.5, "Please use FRHITextureCreateDesc for creating Textures with Ext Data")
	uint32 ExtData = 0;

	const TCHAR* DebugName;

	FName ClassName = NAME_None;	// The owner class of FRHIBuffer used for Insight asset metadata tracing
	FName OwnerName = NAME_None;	// The owner name used for Insight asset metadata tracing
};

class FExclusiveDepthStencil
{
public:
	enum Type
	{
		// don't use those directly, use the combined versions below
		// 4 bits are used for depth and 4 for stencil to make the hex value readable and non overlapping
		DepthNop = 0x00,
		DepthRead = 0x01,
		DepthWrite = 0x02,
		DepthMask = 0x0f,
		StencilNop = 0x00,
		StencilRead = 0x10,
		StencilWrite = 0x20,
		StencilMask = 0xf0,

		// use those:
		DepthNop_StencilNop = DepthNop + StencilNop,
		DepthRead_StencilNop = DepthRead + StencilNop,
		DepthWrite_StencilNop = DepthWrite + StencilNop,
		DepthNop_StencilRead = DepthNop + StencilRead,
		DepthRead_StencilRead = DepthRead + StencilRead,
		DepthWrite_StencilRead = DepthWrite + StencilRead,
		DepthNop_StencilWrite = DepthNop + StencilWrite,
		DepthRead_StencilWrite = DepthRead + StencilWrite,
		DepthWrite_StencilWrite = DepthWrite + StencilWrite,
	};

private:
	Type Value;

public:
	// constructor
	FExclusiveDepthStencil(Type InValue = DepthNop_StencilNop)
		: Value(InValue)
	{
	}

	inline bool IsUsingDepthStencil() const
	{
		return Value != DepthNop_StencilNop;
	}
	inline bool IsUsingDepth() const
	{
		return (ExtractDepth() != DepthNop);
	}
	inline bool IsUsingStencil() const
	{
		return (ExtractStencil() != StencilNop);
	}
	inline bool IsDepthWrite() const
	{
		return ExtractDepth() == DepthWrite;
	}
	inline bool IsDepthRead() const
	{
		return ExtractDepth() == DepthRead;
	}
	inline bool IsStencilWrite() const
	{
		return ExtractStencil() == StencilWrite;
	}
	inline bool IsStencilRead() const
	{
		return ExtractStencil() == StencilRead;
	}

	inline bool IsAnyWrite() const
	{
		return IsDepthWrite() || IsStencilWrite();
	}

	inline void SetDepthWrite()
	{
		Value = (Type)(ExtractStencil() | DepthWrite);
	}
	inline void SetStencilWrite()
	{
		Value = (Type)(ExtractDepth() | StencilWrite);
	}
	inline void SetDepthStencilWrite(bool bDepth, bool bStencil)
	{
		Value = DepthNop_StencilNop;

		if (bDepth)
		{
			SetDepthWrite();
		}
		if (bStencil)
		{
			SetStencilWrite();
		}
	}
	bool operator==(const FExclusiveDepthStencil& rhs) const
	{
		return Value == rhs.Value;
	}

	bool operator != (const FExclusiveDepthStencil& RHS) const
	{
		return Value != RHS.Value;
	}

	inline bool IsValid(FExclusiveDepthStencil& Current) const
	{
		Type Depth = ExtractDepth();

		if (Depth != DepthNop && Depth != Current.ExtractDepth())
		{
			return false;
		}

		Type Stencil = ExtractStencil();

		if (Stencil != StencilNop && Stencil != Current.ExtractStencil())
		{
			return false;
		}

		return true;
	}

	inline void GetAccess(ERHIAccess& DepthAccess, ERHIAccess& StencilAccess) const
	{
		DepthAccess = ERHIAccess::None;

		// SRV access is allowed whilst a depth stencil target is "readable".
		constexpr ERHIAccess DSVReadOnlyMask =
			ERHIAccess::DSVRead;

		// If write access is required, only the depth block can access the resource.
		constexpr ERHIAccess DSVReadWriteMask =
			ERHIAccess::DSVRead |
			ERHIAccess::DSVWrite;

		if (IsUsingDepth())
		{
			DepthAccess = IsDepthWrite() ? DSVReadWriteMask : DSVReadOnlyMask;
		}

		StencilAccess = ERHIAccess::None;

		if (IsUsingStencil())
		{
			StencilAccess = IsStencilWrite() ? DSVReadWriteMask : DSVReadOnlyMask;
		}
	}

	template <typename TFunction>
	inline void EnumerateSubresources(TFunction Function) const
	{
		if (!IsUsingDepthStencil())
		{
			return;
		}

		ERHIAccess DepthAccess = ERHIAccess::None;
		ERHIAccess StencilAccess = ERHIAccess::None;
		GetAccess(DepthAccess, StencilAccess);

		// Same depth / stencil state; single subresource.
		if (DepthAccess == StencilAccess)
		{
			Function(DepthAccess, FRHITransitionInfo::kAllSubresources);
		}
		// Separate subresources for depth / stencil.
		else
		{
			if (DepthAccess != ERHIAccess::None)
			{
				Function(DepthAccess, FRHITransitionInfo::kDepthPlaneSlice);
			}
			if (StencilAccess != ERHIAccess::None)
			{
				Function(StencilAccess, FRHITransitionInfo::kStencilPlaneSlice);
			}
		}
	}

	/**
	* Returns a new FExclusiveDepthStencil to be used to transition a depth stencil resource to readable.
	* If the depth or stencil is already in a readable state, that particular component is returned as Nop,
	* to avoid unnecessary subresource transitions.
	*/
	inline FExclusiveDepthStencil GetReadableTransition() const
	{
		FExclusiveDepthStencil::Type NewDepthState = IsDepthWrite()
			? FExclusiveDepthStencil::DepthRead
			: FExclusiveDepthStencil::DepthNop;

		FExclusiveDepthStencil::Type NewStencilState = IsStencilWrite()
			? FExclusiveDepthStencil::StencilRead
			: FExclusiveDepthStencil::StencilNop;

		return (FExclusiveDepthStencil::Type)(NewDepthState | NewStencilState);
	}

	/**
	* Returns a new FExclusiveDepthStencil to be used to transition a depth stencil resource to readable.
	* If the depth or stencil is already in a readable state, that particular component is returned as Nop,
	* to avoid unnecessary subresource transitions.
	*/
	inline FExclusiveDepthStencil GetWritableTransition() const
	{
		FExclusiveDepthStencil::Type NewDepthState = IsDepthRead()
			? FExclusiveDepthStencil::DepthWrite
			: FExclusiveDepthStencil::DepthNop;

		FExclusiveDepthStencil::Type NewStencilState = IsStencilRead()
			? FExclusiveDepthStencil::StencilWrite
			: FExclusiveDepthStencil::StencilNop;

		return (FExclusiveDepthStencil::Type)(NewDepthState | NewStencilState);
	}

	uint32 GetIndex() const
	{
		// Note: The array to index has views created in that specific order.

		// we don't care about the Nop versions so less views are needed
		// we combine Nop and Write
		switch (Value)
		{
		case DepthWrite_StencilNop:
		case DepthNop_StencilWrite:
		case DepthWrite_StencilWrite:
		case DepthNop_StencilNop:
			return 0; // old DSAT_Writable

		case DepthRead_StencilNop:
		case DepthRead_StencilWrite:
			return 1; // old DSAT_ReadOnlyDepth

		case DepthNop_StencilRead:
		case DepthWrite_StencilRead:
			return 2; // old DSAT_ReadOnlyStencil

		case DepthRead_StencilRead:
			return 3; // old DSAT_ReadOnlyDepthAndStencil
		}
		// should never happen
		check(0);
		return -1;
	}
	static const uint32 MaxIndex = 4;

private:
	inline Type ExtractDepth() const
	{
		return (Type)(Value & DepthMask);
	}
	inline Type ExtractStencil() const
	{
		return (Type)(Value & StencilMask);
	}
	friend uint32 GetTypeHash(const FExclusiveDepthStencil& Ds);
};

//
// State blocks
//

class FRHISamplerState : public FRHIResource 
{
public:
	FRHISamplerState() : FRHIResource(RRT_SamplerState) {}
	virtual bool IsImmutable() const { return false; }
	virtual FRHIDescriptorHandle GetBindlessHandle() const { return FRHIDescriptorHandle(); }
};

class FRHIRasterizerState : public FRHIResource
{
public:
	FRHIRasterizerState() : FRHIResource(RRT_RasterizerState) {}
	virtual bool GetInitializer(struct FRasterizerStateInitializerRHI& Init) { return false; }
};

class FRHIDepthStencilState : public FRHIResource
{
public:
	FRHIDepthStencilState() : FRHIResource(RRT_DepthStencilState) {}
#if ENABLE_RHI_VALIDATION
	FExclusiveDepthStencil ActualDSMode;
#endif
	virtual bool GetInitializer(struct FDepthStencilStateInitializerRHI& Init) { return false; }
};

class FRHIBlendState : public FRHIResource
{
public:
	FRHIBlendState() : FRHIResource(RRT_BlendState) {}
	virtual bool GetInitializer(class FBlendStateInitializerRHI& Init) { return false; }
};

template <typename RHIState, typename RHIStateInitializer>
static bool MatchRHIState(RHIState* LHSState, RHIState* RHSState)
{
	RHIStateInitializer LHSStateInitializerRHI;
	RHIStateInitializer RHSStateInitializerRHI;
	if (LHSState)
	{
		LHSState->GetInitializer(LHSStateInitializerRHI);
	}
	if (RHSState)
	{
		RHSState->GetInitializer(RHSStateInitializerRHI);
	}
	return LHSStateInitializerRHI == RHSStateInitializerRHI;
}

//
// Shader bindings
//

typedef TArray<struct FVertexElement,TFixedAllocator<MaxVertexElementCount> > FVertexDeclarationElementList;

class FRHIVertexDeclaration : public FRHIResource
{
public:
	FRHIVertexDeclaration() : FRHIResource(RRT_VertexDeclaration) {}
	virtual bool GetInitializer(FVertexDeclarationElementList& Init) { return false; }
	virtual uint32 GetPrecachePSOHash() const { return 0; }
};

class FRHIBoundShaderState : public FRHIResource
{
public:
	FRHIBoundShaderState() : FRHIResource(RRT_BoundShaderState) {}
};

//
// Shaders
//

#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
	#define RHI_INCLUDE_SHADER_DEBUG_DATA 1
#else
	#define RHI_INCLUDE_SHADER_DEBUG_DATA 0
#endif

#if RHI_INCLUDE_SHADER_DEBUG_DATA
	#define RHI_IF_SHADER_DEBUG_DATA(...)	__VA_ARGS__
#else
	#define RHI_IF_SHADER_DEBUG_DATA(...)
#endif

struct FShaderResourceTable
{
	/** Bits indicating which resource tables contain resources bound to this shader. */
	uint32 ResourceTableBits = 0;

	/** Mapping of bound SRVs to their location in resource tables. */
	TArray<uint32> ShaderResourceViewMap;

	/** Mapping of bound sampler states to their location in resource tables. */
	TArray<uint32> SamplerMap;

	/** Mapping of bound UAVs to their location in resource tables. */
	TArray<uint32> UnorderedAccessViewMap;

	/** Hash of the layouts of resource tables at compile time, used for runtime validation. */
	TArray<uint32> ResourceTableLayoutHashes;

	/** Mapping of bound Textures to their location in resource tables. */
	TArray<uint32> TextureMap;

	/** Mapping of bound Resource Collections to their location in resource tables. */
	TArray<uint32> ResourceCollectionMap;

	friend bool operator == (const FShaderResourceTable& A, const FShaderResourceTable& B)
	{
		bool bEqual = true;
		bEqual &= (A.ResourceTableBits == B.ResourceTableBits);
		bEqual &= (A.ShaderResourceViewMap    .Num() == B.ShaderResourceViewMap    .Num());
		bEqual &= (A.SamplerMap               .Num() == B.SamplerMap               .Num());
		bEqual &= (A.UnorderedAccessViewMap   .Num() == B.UnorderedAccessViewMap   .Num());
		bEqual &= (A.ResourceTableLayoutHashes.Num() == B.ResourceTableLayoutHashes.Num());
		bEqual &= (A.TextureMap               .Num() == B.TextureMap               .Num());
		bEqual &= (A.ResourceCollectionMap    .Num() == B.ResourceCollectionMap    .Num());

		if (!bEqual)
		{
			return false;
		}

		bEqual &= (FMemory::Memcmp(A.ShaderResourceViewMap    .GetData(), B.ShaderResourceViewMap    .GetData(), A.ShaderResourceViewMap    .GetTypeSize() * A.ShaderResourceViewMap    .Num()) == 0);
		bEqual &= (FMemory::Memcmp(A.SamplerMap               .GetData(), B.SamplerMap               .GetData(), A.SamplerMap               .GetTypeSize() * A.SamplerMap               .Num()) == 0);
		bEqual &= (FMemory::Memcmp(A.UnorderedAccessViewMap   .GetData(), B.UnorderedAccessViewMap   .GetData(), A.UnorderedAccessViewMap   .GetTypeSize() * A.UnorderedAccessViewMap   .Num()) == 0);
		bEqual &= (FMemory::Memcmp(A.ResourceTableLayoutHashes.GetData(), B.ResourceTableLayoutHashes.GetData(), A.ResourceTableLayoutHashes.GetTypeSize() * A.ResourceTableLayoutHashes.Num()) == 0);
		bEqual &= (FMemory::Memcmp(A.TextureMap               .GetData(), B.TextureMap               .GetData(), A.TextureMap               .GetTypeSize() * A.TextureMap               .Num()) == 0);
		bEqual &= (FMemory::Memcmp(A.ResourceCollectionMap    .GetData(), B.ResourceCollectionMap    .GetData(), A.ResourceCollectionMap    .GetTypeSize() * A.ResourceCollectionMap    .Num()) == 0);
		return bEqual;
	}

	friend FArchive& operator << (FArchive& Ar, FShaderResourceTable& SRT)
	{
		Ar << SRT.ResourceTableBits;
		Ar << SRT.ShaderResourceViewMap;
		Ar << SRT.SamplerMap;
		Ar << SRT.UnorderedAccessViewMap;
		Ar << SRT.ResourceTableLayoutHashes;
		Ar << SRT.TextureMap;
		Ar << SRT.ResourceCollectionMap;
	
		return Ar;
	}
};

namespace UE
{
	namespace RHICore
	{
		// Workaround for layering issue. FShaderParametersMetadata is in RenderCore,
		// so we can't move the logic for initializing the StaticSlots array to the RHI module.
		void InitStaticUniformBufferSlots(FRHIShaderData* ShaderData);
	}
}

class FRHIShaderData
{
public:
	const FShaderResourceTable& GetShaderResourceTable() const
	{
		return ShaderResourceTable;
	}

	const TArray<FUniformBufferStaticSlot>& GetStaticSlots() const
	{
		return StaticSlots;
	}

	void SerializeShaderResourceTable(FArchive& Ar)
	{
		Ar << ShaderResourceTable;
	}

protected:
	FShaderResourceTable ShaderResourceTable;
	TArray<FUniformBufferStaticSlot> StaticSlots;

	// Workaround for layering issue. FShaderParametersMetadata is in RenderCore,
	// so we can't move the logic for initializing the StaticSlots array to the RHI module.
	friend void UE::RHICore::InitStaticUniformBufferSlots(FRHIShaderData* ShaderData);
};

class FRHIShader : public FRHIResource, public FRHIShaderData
{
public:
	void SetHash(const FSHAHash& InHash) { Hash = InHash; }
	const FSHAHash& GetHash() const { return Hash; }

#if RHI_INCLUDE_SHADER_DEBUG_DATA

	// for debugging only e.g. MaterialName:ShaderFile.usf or ShaderFile.usf/EntryFunc
	struct
	{
		FString ShaderName;
		TArray<FName> UniformBufferNames;
	} Debug;

	const TCHAR* GetShaderName() const
	{
		return Debug.ShaderName.Len()
			? *Debug.ShaderName
			: TEXT("<unknown>");
	}

	FString GetUniformBufferName(uint32 Index) const
	{
		return Debug.UniformBufferNames.IsValidIndex(Index)
			? Debug.UniformBufferNames[Index].ToString()
			: TEXT("<unknown>");
	}

	TArray<FShaderCodeValidationStride> DebugStrideValidationData;
	TArray<FShaderCodeValidationType> DebugSRVTypeValidationData;
	TArray<FShaderCodeValidationType> DebugUAVTypeValidationData;
	TArray<FShaderCodeValidationUBSize> DebugUBSizeValidationData;

#else

	const TCHAR* GetShaderName() const { return TEXT("<unknown>"); }
	FString GetUniformBufferName(uint32 Index) const { return TEXT("<unknown>"); }

#endif

	FRHIShader() = delete;
	FRHIShader(ERHIResourceType InResourceType, EShaderFrequency InFrequency)
		: FRHIResource(InResourceType)
		, Frequency(InFrequency)
		, bNoDerivativeOps(false)
		, bHasShaderBundleUsage(false)
	{
	}

#if PLATFORM_WINDOWS
	RHI_API virtual ~FRHIShader();	
	RHI_API void SetInUseByPSOCompilation(bool bInUse);
#endif // PLATFORM_WINDOWS

	inline EShaderFrequency GetFrequency() const
	{
		return Frequency;
	}

	inline void SetNoDerivativeOps(bool bValue)
	{
		bNoDerivativeOps = bValue;
	}

	inline bool HasNoDerivativeOps() const
	{
		return bNoDerivativeOps;
	}

	inline void SetShaderBundleUsage(bool bValue)
	{
		bHasShaderBundleUsage = bValue;
	}

	inline bool HasShaderBundleUsage() const
	{
		return bHasShaderBundleUsage;
	}

private:
	FSHAHash Hash;
	EShaderFrequency Frequency;
	uint8 bNoDerivativeOps : 1;
	uint8 bHasShaderBundleUsage : 1;
#if PLATFORM_WINDOWS
	volatile int16 InUseByPSOCompilation = 0;
#endif // PLATFORM_WINDOWS
};

class FRHIGraphicsShader : public FRHIShader
{
public:
	explicit FRHIGraphicsShader(ERHIResourceType InResourceType, EShaderFrequency InFrequency)
		: FRHIShader(InResourceType, InFrequency) {}
};

class FRHIVertexShader : public FRHIGraphicsShader
{
public:
	FRHIVertexShader() : FRHIGraphicsShader(RRT_VertexShader, SF_Vertex) {}
};

class FRHIMeshShader : public FRHIGraphicsShader
{
public:
	FRHIMeshShader() : FRHIGraphicsShader(RRT_MeshShader, SF_Mesh) {}
};

class FRHIAmplificationShader : public FRHIGraphicsShader
{
public:
	FRHIAmplificationShader() : FRHIGraphicsShader(RRT_AmplificationShader, SF_Amplification) {}
};

class FRHIPixelShader : public FRHIGraphicsShader
{
public:
	FRHIPixelShader() : FRHIGraphicsShader(RRT_PixelShader, SF_Pixel) {}
};

class FRHIGeometryShader : public FRHIGraphicsShader
{
public:
	FRHIGeometryShader() : FRHIGraphicsShader(RRT_GeometryShader, SF_Geometry) {}
};

class FRHIRayTracingShader : public FRHIShader
{
public:
	explicit FRHIRayTracingShader(EShaderFrequency InFrequency) : FRHIShader(RRT_RayTracingShader, InFrequency) {}

	uint32 RayTracingPayloadType = 0; // This corresponds to the ERayTracingPayloadType enum associated with the shader
	uint32 RayTracingPayloadSize = 0; // The (maximum) size of the payload associated with this shader
	uint32 LocalBindingDataSize = 0; // Size of the local shader binding data needed for this shader
};

class FRHIRayGenShader : public FRHIRayTracingShader
{
public:
	FRHIRayGenShader() : FRHIRayTracingShader(SF_RayGen) {}
};

class FRHIRayMissShader : public FRHIRayTracingShader
{
public:
	FRHIRayMissShader() : FRHIRayTracingShader(SF_RayMiss) {}
};

class FRHIRayCallableShader : public FRHIRayTracingShader
{
public:
	FRHIRayCallableShader() : FRHIRayTracingShader(SF_RayCallable) {}
};

class FRHIRayHitGroupShader : public FRHIRayTracingShader
{
public:
	FRHIRayHitGroupShader() : FRHIRayTracingShader(SF_RayHitGroup) {}
};

class FRHIComputeShader : public FRHIShader
{
public:
	FRHIComputeShader() : FRHIShader(RRT_ComputeShader, SF_Compute)
	, Stats(nullptr)
	{
	}
	
	inline void SetStats(struct FPipelineStateStats* Ptr) { Stats = Ptr; }
	RHI_API void UpdateStats();

private:
	struct FPipelineStateStats* Stats;
};

class FRHIWorkGraphShader : public FRHIShader
{
public:
	explicit FRHIWorkGraphShader(EShaderFrequency InFrequency)
		: FRHIShader(RRT_WorkGraphShader, InFrequency)
	{
	}
};

class FRHIWorkGraphRootShader : public FRHIWorkGraphShader
{
public:
	FRHIWorkGraphRootShader() : FRHIWorkGraphShader(SF_WorkGraphRoot) {}
};

class FRHIWorkGraphComputeNodeShader : public FRHIWorkGraphShader
{
public:
	FRHIWorkGraphComputeNodeShader() : FRHIWorkGraphShader(SF_WorkGraphComputeNode) {}
};

//
// Pipeline States
//

class FRHIGraphicsPipelineState : public FRHIResource 
{
public:
	FRHIGraphicsPipelineState() : FRHIResource(RRT_GraphicsPipelineState) {}

	inline void SetSortKey(uint64 InSortKey) { SortKey = InSortKey; }
	inline uint64 GetSortKey() const { return SortKey; }

	virtual FRHIGraphicsShader* GetShader(EShaderFrequency Frequency) const = 0;

private:
	uint64 SortKey = 0;

#if ENABLE_RHI_VALIDATION
	friend class FValidationContext;
	friend class FValidationRHI;
	FExclusiveDepthStencil DSMode;
#endif
};

class FRHIComputePipelineState : public FRHIResource
{
public:
	FRHIComputePipelineState(FRHIComputeShader* InComputeShader) :
		FRHIResource(RRT_ComputePipelineState)
		, ComputeShader(InComputeShader)
	{
		check(InComputeShader);
	}

	inline void SetValid(bool InIsValid) { bIsValid = InIsValid; }
	inline bool IsValid() const { return bIsValid; }

	FORCEINLINE FRHIComputeShader* GetComputeShader() const
	{
		return ComputeShader;
	}

protected:
	TRefCountPtr<FRHIComputeShader> ComputeShader;

private:
	bool bIsValid = true;
};

class FRHIWorkGraphPipelineState : public FRHIResource
{
public:
	FRHIWorkGraphPipelineState() : FRHIResource(RRT_WorkGraphPipelineState) {}
};

class FRHIRayTracingPipelineState : public FRHIResource
{
public:
	FRHIRayTracingPipelineState() : FRHIResource(RRT_RayTracingPipelineState) {}
};

//
// Buffers
//

// Whether to assert in cases where the layout is released before uniform buffers created with that layout
#define VALIDATE_UNIFORM_BUFFER_LAYOUT_LIFETIME 0

// Whether to assert when a uniform buffer is being deleted while still referenced by a mesh draw command
// Enabling this requires -norhithread to work correctly since FRHIResource lifetime is managed by both the RT and RHIThread
#define VALIDATE_UNIFORM_BUFFER_LIFETIME 0

struct FRHIUniformBufferResource
{
	/** Byte offset to each resource in the uniform buffer memory. */
	uint16 MemberOffset;

	/** Type of the member that allow (). */
	EUniformBufferBaseType MemberType;

	/** Compare two uniform buffer layout resources. */
	friend inline bool operator==(const FRHIUniformBufferResource& A, const FRHIUniformBufferResource& B)
	{
		return A.MemberOffset == B.MemberOffset
			&& A.MemberType == B.MemberType;
	}
};

inline constexpr uint16 kUniformBufferInvalidOffset = TNumericLimits<uint16>::Max();

struct FRHIUniformBufferLayoutInitializer;

/** The layout of a uniform buffer in memory. */
struct FRHIUniformBufferLayout : public FRHIResource
{
	FRHIUniformBufferLayout() = delete;

	RHI_API explicit FRHIUniformBufferLayout(const FRHIUniformBufferLayoutInitializer& Initializer);

	inline const FString& GetDebugName() const
	{
		return Name;
	}

	inline uint32 GetHash() const
	{
		checkSlow(Hash != 0);
		return Hash;
	}

	inline bool HasRenderTargets() const
	{
		return RenderTargetsOffset != kUniformBufferInvalidOffset;
	}

	inline bool HasExternalOutputs() const
	{
		return EnumHasAnyFlags(Flags, ERHIUniformBufferFlags::HasNonGraphOutputs);
	}

	inline bool HasStaticSlot() const
	{
		return IsUniformBufferStaticSlotValid(StaticSlot);
	}

	const FString Name;

	/** The list of all resource inlined into the shader parameter structure. */
	const TArray<FRHIUniformBufferResource> Resources;

	/** The list of all RDG resource references inlined into the shader parameter structure. */
	const TArray<FRHIUniformBufferResource> GraphResources;

	/** The list of all RDG texture references inlined into the shader parameter structure. */
	const TArray<FRHIUniformBufferResource> GraphTextures;

	/** The list of all RDG buffer references inlined into the shader parameter structure. */
	const TArray<FRHIUniformBufferResource> GraphBuffers;

	/** The list of all RDG uniform buffer references inlined into the shader parameter structure. */
	const TArray<FRHIUniformBufferResource> GraphUniformBuffers;

	/** The list of all non-RDG uniform buffer references inlined into the shader parameter structure. */
	const TArray<FRHIUniformBufferResource> UniformBuffers;

	const uint32 Hash;

	/** The size of the constant buffer in bytes. */
	const uint32 ConstantBufferSize;

	/** The render target binding slots offset, if it exists. */
	const uint16 RenderTargetsOffset;

	/** The static slot (if applicable). */
	const FUniformBufferStaticSlot StaticSlot;

	/** The binding flags describing how this resource can be bound to the RHI. */
	const EUniformBufferBindingFlags BindingFlags;

	/** Flags to signal different Uniform Buffer states. */
	const ERHIUniformBufferFlags Flags;

	/** Compare two uniform buffer layouts. */
	friend inline bool operator==(const FRHIUniformBufferLayout& A, const FRHIUniformBufferLayout& B)
	{
		return A.ConstantBufferSize == B.ConstantBufferSize
			&& A.StaticSlot == B.StaticSlot
			&& A.BindingFlags == B.BindingFlags
			&& A.Resources == B.Resources;
	}
};

class FRHIUniformBuffer : public FRHIResource
#if ENABLE_RHI_VALIDATION
	, public RHIValidation::FUniformBufferResource
#endif
{
public:
	FRHIUniformBuffer() = delete;

	/** Initialization constructor. */
	FRHIUniformBuffer(const FRHIUniformBufferLayout* InLayout)
	: FRHIResource(RRT_UniformBuffer)
	, Layout(InLayout)
	, LayoutConstantBufferSize(InLayout->ConstantBufferSize)
	{}

	FORCEINLINE_DEBUGGABLE uint32 Release() const
	{
		const FRHIUniformBufferLayout* LocalLayout = Layout;

#if VALIDATE_UNIFORM_BUFFER_LIFETIME
		int32 LocalNumMeshCommandReferencesForDebugging = NumMeshCommandReferencesForDebugging;
#endif

		uint32 NewRefCount = FRHIResource::Release();

		if (NewRefCount == 0)
		{
#if VALIDATE_UNIFORM_BUFFER_LIFETIME
			check(LocalNumMeshCommandReferencesForDebugging == 0 || IsEngineExitRequested());
#endif
		}

		return NewRefCount;
	}

	/** @return The number of bytes in the uniform buffer. */
	uint32 GetSize() const
	{
		check(LayoutConstantBufferSize == Layout->ConstantBufferSize);
		return LayoutConstantBufferSize;
	}
	const FRHIUniformBufferLayout& GetLayout() const { return *Layout; }
	const FRHIUniformBufferLayout* GetLayoutPtr() const { return Layout; }

#if VALIDATE_UNIFORM_BUFFER_LIFETIME
	mutable std::atomic<int32> NumMeshCommandReferencesForDebugging = 0;
#endif

	const TArray<TRefCountPtr<FRHIResource>>& GetResourceTable() const { return ResourceTable; }

protected:
	TArray<TRefCountPtr<FRHIResource>> ResourceTable;

private:
	/** Layout of the uniform buffer. */
	TRefCountPtr<const FRHIUniformBufferLayout> Layout;

	uint32 LayoutConstantBufferSize;
};

class FRHIViewableResource : public FRHIResource
{
public:
	// TODO (RemoveUnknowns) remove once FRHIBufferCreateDesc contains initial access.
	void SetTrackedAccess_Unsafe(ERHIAccess Access)
	{
		TrackedAccess = Access;
	}

	FName GetName() const
	{
		return Name;
	}

#if ENABLE_RHI_VALIDATION
	virtual RHIValidation::FResource* GetValidationTrackerResource() = 0;
#endif

protected:
	FRHIViewableResource(ERHIResourceType InResourceType, ERHIAccess InAccess)
		: FRHIResource(InResourceType)
		, TrackedAccess(InAccess)
	{}

	void TakeOwnership(FRHIViewableResource& Other)
	{
		TrackedAccess = Other.TrackedAccess;
	}

	void ReleaseOwnership()
	{
		TrackedAccess = ERHIAccess::Unknown;
	}

	FName Name;

private:
	ERHIAccess TrackedAccess;

	friend class FRHIComputeCommandList;
	friend class IRHIComputeContext;
};

struct FRHIBufferDesc
{
	uint32 Size{};
	uint32 Stride{};
	EBufferUsageFlags Usage{};

	FRHIBufferDesc() = default;
	FRHIBufferDesc(uint32 InSize, uint32 InStride, EBufferUsageFlags InUsage)
		: Size  (InSize)
		, Stride(InStride)
		, Usage (InUsage)
	{}

	static FRHIBufferDesc Null()
	{
		return FRHIBufferDesc(0, 0, BUF_NullResource);
	}

	bool IsNull() const
	{
		if (EnumHasAnyFlags(Usage, BUF_NullResource))
		{
			// The null resource descriptor should have its other fields zeroed, and no additional flags.
			check(Size == 0 && Stride == 0 && Usage == BUF_NullResource);
			return true;
		}

		return false;
	}
};

class FRHIBuffer : public FRHIViewableResource
#if ENABLE_RHI_VALIDATION
	, public RHIValidation::FBufferResource
#endif
{
public:
	/** Initialization constructor. */
	FRHIBuffer(FRHIBufferDesc const& InDesc)
		: FRHIViewableResource(RRT_Buffer, ERHIAccess::Unknown /* TODO (RemoveUnknowns): Use InitialAccess from descriptor after refactor. */)
		, Desc(InDesc)
	{}

	FRHIBufferDesc const& GetDesc() const { return Desc; }

	/** @return The number of bytes in the buffer. */
	uint32 GetSize() const { return Desc.Size; }

	/** @return The stride in bytes of the buffer. */
	uint32 GetStride() const { return Desc.Stride; }

	/** @return The usage flags used to create the buffer. */
	EBufferUsageFlags GetUsage() const { return Desc.Usage; }

	void SetName(const FName& InName) { Name = InName; }

	virtual uint32 GetParentGPUIndex() const { return 0; }

#if ENABLE_RHI_VALIDATION
	virtual RHIValidation::FResource* GetValidationTrackerResource() final override
	{
		return this;
	}
#endif

protected:
	// Used by RHI implementations that may adjust internal usage flags during object construction.
	void SetUsage(EBufferUsageFlags InUsage)
	{
		Desc.Usage = InUsage;
	}

	void TakeOwnership(FRHIBuffer& Other)
	{
		FRHIViewableResource::TakeOwnership(Other);
		Desc = Other.Desc;
	}

	void ReleaseOwnership()
	{
		FRHIViewableResource::ReleaseOwnership();
		Desc = FRHIBufferDesc::Null();
	}

private:
	FRHIBufferDesc Desc;
};

/** Represents a simple indirection to a vertex buffer to bind to a source stream. The underlying vertex buffer can be updated dynamically using an RHI command list. */
class FRHIStreamSourceSlot : public FRHIResource
{
	friend FRHICommandListBase;
	friend FRHICommandList;
public:
	static TRefCountPtr<FRHIStreamSourceSlot> Create(FRHIBuffer* InBuffer)
	{
		return new FRHIStreamSourceSlot(InBuffer);
	}

private:
	FRHIStreamSourceSlot(FRHIBuffer* InBuffer)
		: FRHIResource(RRT_StreamSourceSlot)
		, Buffer(InBuffer)
	{}

	TRefCountPtr<FRHIBuffer> Buffer;
};

//
// Textures
//

class FLastRenderTimeContainer
{
public:
	FLastRenderTimeContainer() : LastRenderTime(-FLT_MAX) {}

	double GetLastRenderTime() const { return LastRenderTime; }

	void SetLastRenderTime(double InLastRenderTime) 
	{ 
		// avoid dirty caches from redundant writes
		if (LastRenderTime != InLastRenderTime)
		{
			LastRenderTime = InLastRenderTime;
		}
	}

private:
	/** The last time the resource was rendered. */
	double LastRenderTime;
};


/** Descriptor used to create a texture resource */
struct FRHITextureDesc
{
	FRHITextureDesc() = default;

	FRHITextureDesc(const FRHITextureDesc& Other)
	{
		*this = Other;
	}

	FRHITextureDesc(ETextureDimension InDimension)
		: Dimension(InDimension)
	{}

	FRHITextureDesc(
		  ETextureDimension   InDimension
		, ETextureCreateFlags InFlags
		, EPixelFormat        InFormat
		, FClearValueBinding  InClearValue
		, FIntPoint           InExtent
		, uint16              InDepth
		, uint16              InArraySize
		, uint8               InNumMips
		, uint8               InNumSamples
		, uint32              InExtData
		)
		: Flags     (InFlags     )
		, ClearValue(InClearValue)
		, ExtData   (InExtData   )
		, Extent    (InExtent    )
		, Depth     (InDepth     )
		, ArraySize (InArraySize )
		, NumMips   (InNumMips   )
		, NumSamples(InNumSamples)
		, Dimension (InDimension )
		, Format    (InFormat    )
	{}

	friend uint32 GetTypeHash(const FRHITextureDesc& Desc)
	{
		uint32 Hash = GetTypeHash(Desc.Dimension);
		Hash = HashCombine(Hash, GetTypeHash(Desc.Flags		));
		Hash = HashCombine(Hash, GetTypeHash(Desc.Format	));
		Hash = HashCombine(Hash, GetTypeHash(Desc.UAVFormat	));
		Hash = HashCombine(Hash, GetTypeHash(Desc.Extent	));
		Hash = HashCombine(Hash, GetTypeHash(Desc.Depth		));
		Hash = HashCombine(Hash, GetTypeHash(Desc.ArraySize	));
		Hash = HashCombine(Hash, GetTypeHash(Desc.NumMips	));
		Hash = HashCombine(Hash, GetTypeHash(Desc.NumSamples));
		Hash = HashCombine(Hash, GetTypeHash(Desc.FastVRAMPercentage));
		Hash = HashCombine(Hash, GetTypeHash(Desc.ClearValue));
		Hash = HashCombine(Hash, GetTypeHash(Desc.ExtData   ));
		Hash = HashCombine(Hash, GetTypeHash(Desc.GPUMask.GetNative()));
		return Hash;
	}

	bool operator == (const FRHITextureDesc& Other) const
	{
		return Dimension  == Other.Dimension
			&& Flags      == Other.Flags
			&& Format     == Other.Format
			&& UAVFormat  == Other.UAVFormat
			&& Extent     == Other.Extent
			&& Depth      == Other.Depth
			&& ArraySize  == Other.ArraySize
			&& NumMips    == Other.NumMips
			&& NumSamples == Other.NumSamples
			&& FastVRAMPercentage == Other.FastVRAMPercentage
			&& ClearValue == Other.ClearValue
			&& ExtData    == Other.ExtData
			&& GPUMask    == Other.GPUMask;
	}

	bool operator != (const FRHITextureDesc& Other) const
	{
		return !(*this == Other);
	}

	FRHITextureDesc& operator=(const FRHITextureDesc& Other)
	{
		Dimension			= Other.Dimension;
		Flags				= Other.Flags;
		Format				= Other.Format;
		UAVFormat			= Other.UAVFormat;
		Extent				= Other.Extent;
		Depth				= Other.Depth;
		ArraySize			= Other.ArraySize;
		NumMips				= Other.NumMips;
		NumSamples			= Other.NumSamples;
		ClearValue			= Other.ClearValue;
		ExtData				= Other.ExtData;
		FastVRAMPercentage	= Other.FastVRAMPercentage;
		GPUMask				= Other.GPUMask;

		return *this;
	}

	bool IsTexture2D() const
	{
		return Dimension == ETextureDimension::Texture2D || Dimension == ETextureDimension::Texture2DArray;
	}

	bool IsTexture3D() const
	{
		return Dimension == ETextureDimension::Texture3D;
	}

	bool IsTextureCube() const
	{
		return Dimension == ETextureDimension::TextureCube || Dimension == ETextureDimension::TextureCubeArray;
	}

	bool IsTextureArray() const
	{
		return Dimension == ETextureDimension::Texture2DArray || Dimension == ETextureDimension::TextureCubeArray;
	}

	bool IsMipChain() const
	{
		return NumMips > 1;
	}

	bool IsMultisample() const
	{
		return NumSamples > 1;
	}

	FIntVector GetSize() const
	{
		return FIntVector(Extent.X, Extent.Y, Depth);
	}

	void Reset()
	{
		// Usually we don't want to propagate MSAA samples.
		NumSamples = 1;

		// Remove UAV flag for textures that don't need it (some formats are incompatible).
		Flags |= TexCreate_RenderTargetable;
		Flags &= ~(TexCreate_UAV | TexCreate_ResolveTargetable | TexCreate_DepthStencilResolveTarget | TexCreate_Memoryless);
	}

	/** Returns whether this descriptor conforms to requirements. */
	bool IsValid() const
	{
		return FRHITextureDesc::Validate(*this, /* Name = */ TEXT(""), /* bFatal = */ false);
	}

	/** Texture flags passed on to RHI texture. */
	ETextureCreateFlags Flags = TexCreate_None;

	/** Clear value to use when fast-clearing the texture. */
	FClearValueBinding ClearValue;

	/* A mask representing which GPUs to create the resource on, in a multi-GPU system. */
	FRHIGPUMask GPUMask = FRHIGPUMask::All();

	/** Platform-specific additional data. Used for offline processed textures on some platforms. */
	uint32 ExtData = 0;

	/** Extent of the texture in x and y. */
	FIntPoint Extent = FIntPoint(1, 1);

	/** Depth of the texture if the dimension is 3D. */
	uint16 Depth = 1;

	/** The number of array elements in the texture. (Keep at 1 if dimension is 3D). */
	uint16 ArraySize = 1;

	/** Number of mips in the texture mip-map chain. */
	uint8 NumMips = 1;

	/** Number of samples in the texture. >1 for MSAA. */
	uint8 NumSamples = 1;

	/** Texture dimension to use when creating the RHI texture. */
	ETextureDimension Dimension = ETextureDimension::Texture2D;

	/** Pixel format used to create RHI texture. */
	EPixelFormat Format = PF_Unknown;

	/** Texture format used when creating the UAV. PF_Unknown means to use the default one (same as Format). */
	EPixelFormat UAVFormat = PF_Unknown;

	/** Resource memory percentage which should be allocated onto fast VRAM (hint-only). (encoding into 8bits, 0..255 -> 0%..100%) */
	uint8 FastVRAMPercentage = 0xFF;

	/** Check the validity. */
	static bool CheckValidity(const FRHITextureDesc& Desc, const TCHAR* Name)
	{
		return FRHITextureDesc::Validate(Desc, Name, /* bFatal = */ true);
	}

	/**
	 * Returns an estimated total memory size the described texture will occupy in GPU memory.
	 * This is an estimate because it only considers the dimensions / format etc of the texture, 
	 * not any specifics about platform texture layout.
	 * 
	 * To get a true measure of a texture resource for the current running platform RHI, use RHICalcTexturePlatformSize().
	 * 
	 * @param FirstMipIndex - the index of the most detailed mip to consider in the memory size calculation. Must be < NumMips and <= LastMipIndex.
	 * @param LastMipIndex  - the index of the least detailed mip to consider in the memory size calculation. Must be < NumMips and >= FirstMipIndex.
	 */
	RHI_API uint64 CalcMemorySizeEstimate(uint32 FirstMipIndex, uint32 LastMipIndex) const;

	uint64 CalcMemorySizeEstimate(uint32 FirstMipIndex = 0) const
	{
		return CalcMemorySizeEstimate(FirstMipIndex, NumMips - 1);
	}

private:
	RHI_API static bool Validate(const FRHITextureDesc& Desc, const TCHAR* Name, bool bFatal);
};

// @todo deprecate
using FRHITextureCreateInfo = FRHITextureDesc;

extern RHI_API ERHIAccess RHIGetDefaultResourceState(ETextureCreateFlags InUsage, bool bInHasInitialData);

struct FRHITextureCreateDesc : public FRHITextureDesc
{
	static FRHITextureCreateDesc Create(const TCHAR* InDebugName, ETextureDimension InDimension)
	{
		return FRHITextureCreateDesc(InDebugName, InDimension);
	}

	static FRHITextureCreateDesc Create2D(const TCHAR* InDebugName)
	{
		return FRHITextureCreateDesc(InDebugName, ETextureDimension::Texture2D);
	}

	static FRHITextureCreateDesc Create2DArray(const TCHAR* InDebugName)
	{
		return FRHITextureCreateDesc(InDebugName, ETextureDimension::Texture2DArray);
	}

	static FRHITextureCreateDesc Create3D(const TCHAR* InDebugName)
	{
		return FRHITextureCreateDesc(InDebugName, ETextureDimension::Texture3D);
	}

	static FRHITextureCreateDesc CreateCube(const TCHAR* InDebugName)
	{
		return FRHITextureCreateDesc(InDebugName, ETextureDimension::TextureCube);
	}

	static FRHITextureCreateDesc CreateCubeArray(const TCHAR* InDebugName)
	{
		return FRHITextureCreateDesc(InDebugName, ETextureDimension::TextureCubeArray);
	}

	static FRHITextureCreateDesc Create2D(const TCHAR* DebugName, FIntPoint Size, EPixelFormat Format)
	{
		return Create2D(DebugName)
			.SetExtent(Size)
			.SetFormat(Format);
	}

	static FRHITextureCreateDesc Create2D(const TCHAR* DebugName, int32 SizeX, int32 SizeY, EPixelFormat Format)
	{
		return Create2D(DebugName)
			.SetExtent(SizeX, SizeY)
			.SetFormat(Format);
	}

	static FRHITextureCreateDesc Create2DArray(const TCHAR* DebugName, FIntPoint Size, uint16 ArraySize, EPixelFormat Format)
	{
		return Create2DArray(DebugName)
			.SetExtent(Size)
			.SetFormat(Format)
			.SetArraySize((uint16)ArraySize);
	}

	static FRHITextureCreateDesc Create2DArray(const TCHAR* DebugName, int32 SizeX, int32 SizeY, int32 ArraySize, EPixelFormat Format)
	{
		return Create2DArray(DebugName)
			.SetExtent(SizeX, SizeY)
			.SetFormat(Format)
			.SetArraySize((uint16)ArraySize);
	}

	static FRHITextureCreateDesc Create3D(const TCHAR* DebugName, FIntVector Size, EPixelFormat Format)
	{
		return Create3D(DebugName)
			.SetExtent(Size.X, Size.Y)
			.SetDepth((uint16)Size.Z)
			.SetFormat(Format);
	}

	static FRHITextureCreateDesc Create3D(const TCHAR* DebugName, int32 SizeX, int32 SizeY, int32 SizeZ, EPixelFormat Format)
	{
		return Create3D(DebugName)
			.SetExtent(SizeX, SizeY)
			.SetDepth((uint16)SizeZ)
			.SetFormat(Format);
	}

	static FRHITextureCreateDesc CreateCube(const TCHAR* DebugName, uint32 Size, EPixelFormat Format)
	{
		return CreateCube(DebugName)
			.SetExtent(Size)
			.SetFormat(Format);
	}

	static FRHITextureCreateDesc CreateCubeArray(const TCHAR* DebugName, uint32 Size, uint16 ArraySize, EPixelFormat Format)
	{
		return CreateCubeArray(DebugName)
			.SetExtent(Size)
			.SetFormat(Format)
			.SetArraySize((uint16)ArraySize);
	}

	FRHITextureCreateDesc() = default;

	// Constructor with minimal argument set. Name and dimension are always required.
	FRHITextureCreateDesc(const TCHAR* InDebugName, ETextureDimension InDimension)
		: FRHITextureDesc(InDimension)
		, DebugName(InDebugName)
	{
	}

	// Constructor for when you already have an FRHITextureDesc
	FRHITextureCreateDesc(
		  FRHITextureDesc const&      InDesc
		, ERHIAccess                  InInitialState
		, TCHAR const*                InDebugName
		, FResourceBulkDataInterface* InBulkData     = nullptr
		)
		: FRHITextureDesc(InDesc)
		, InitialState   (InInitialState)
		, DebugName      (InDebugName)
		, BulkData       (InBulkData)
	{}

	void CheckValidity() const
	{
		FRHITextureDesc::CheckValidity(*this, DebugName);

		ensureMsgf(InitialState != ERHIAccess::Unknown, TEXT("Resource %s cannot be created in an unknown state."), DebugName);
	}

	FRHITextureCreateDesc& SetFlags(ETextureCreateFlags InFlags)               { Flags = InFlags;                          return *this; }
	FRHITextureCreateDesc& AddFlags(ETextureCreateFlags InFlags)               { Flags |= InFlags;                         return *this; }
	FRHITextureCreateDesc& SetClearValue(FClearValueBinding InClearValue)      { ClearValue = InClearValue;                return *this; }
	FRHITextureCreateDesc& SetExtData(uint32 InExtData)                        { ExtData = InExtData;                      return *this; }
	FRHITextureCreateDesc& SetExtent(const FIntPoint& InExtent)                { Extent = InExtent;                        return *this; }
	FRHITextureCreateDesc& SetExtent(int32 InExtentX, int32 InExtentY)         { Extent = FIntPoint(InExtentX, InExtentY); return *this; }
	FRHITextureCreateDesc& SetExtent(uint32 InExtent)                          { Extent = FIntPoint(InExtent);             return *this; }
	FRHITextureCreateDesc& SetDepth(uint16 InDepth)                            { Depth = InDepth;                          return *this; }
	FRHITextureCreateDesc& SetArraySize(uint16 InArraySize)                    { ArraySize = InArraySize;                  return *this; }
	FRHITextureCreateDesc& SetNumMips(uint8 InNumMips)                         { NumMips = InNumMips;                      return *this; }
	FRHITextureCreateDesc& SetNumSamples(uint8 InNumSamples)                   { NumSamples = InNumSamples;                return *this; }
	FRHITextureCreateDesc& SetDimension(ETextureDimension InDimension)         { Dimension = InDimension;                  return *this; }
	FRHITextureCreateDesc& SetFormat(EPixelFormat InFormat)                    { Format = InFormat;                        return *this; }
	FRHITextureCreateDesc& SetUAVFormat(EPixelFormat InUAVFormat)              { UAVFormat = InUAVFormat;                  return *this; }
	FRHITextureCreateDesc& SetInitialState(ERHIAccess InInitialState)          { InitialState = InInitialState;            return *this; }
	FRHITextureCreateDesc& SetDebugName(const TCHAR* InDebugName)              { DebugName = InDebugName;                  return *this; }
	FRHITextureCreateDesc& SetGPUMask(FRHIGPUMask InGPUMask)                   { GPUMask = InGPUMask;                      return *this; }
	FRHITextureCreateDesc& SetBulkData(FResourceBulkDataInterface* InBulkData) { BulkData = InBulkData;                    return *this; }
	FRHITextureCreateDesc& DetermineInititialState()                           { if (InitialState == ERHIAccess::Unknown) InitialState = RHIGetDefaultResourceState(Flags, BulkData != nullptr); return *this; }
	FRHITextureCreateDesc& SetFastVRAMPercentage(float In)                     { FastVRAMPercentage = uint8(FMath::Clamp(In, 0.f, 1.0f) * 0xFF); return *this; }
	FRHITextureCreateDesc& SetClassName(const FName& InClassName)			   { ClassName = InClassName;				   return *this; }
	FRHITextureCreateDesc& SetOwnerName(const FName& InOwnerName)			   { OwnerName = InOwnerName;                  return *this; }
	FName GetTraceClassName() const											   { const static FLazyName FRHITextureName(TEXT("FRHITexture")); return (ClassName == NAME_None) ? FRHITextureName : ClassName; }

	/* The RHI access state that the resource will be created in. */
	ERHIAccess InitialState = ERHIAccess::Unknown;

	/* A friendly name for the resource. */
	const TCHAR* DebugName = nullptr;

	/* Optional initial data to fill the resource with. */
	FResourceBulkDataInterface* BulkData = nullptr;

	FName ClassName = NAME_None;	// The owner class of FRHITexture used for Insight asset metadata tracing
	FName OwnerName = NAME_None;	// The owner name used for Insight asset metadata tracing
};

class FRHITexture : public FRHIViewableResource
#if ENABLE_RHI_VALIDATION
	, public RHIValidation::FTextureResource
#endif
{
protected:
	/** Initialization constructor. Should only be called by platform RHI implementations. */
	RHI_API FRHITexture(const FRHITextureCreateDesc& InDesc);

public:
	/**
	 * Get the texture description used to create the texture
	 * Still virtual because FRHITextureReference can override this function - remove virtual when FRHITextureReference is deprecated
	 *
	 * @return TextureDesc used to create the texture
	 */
	virtual const FRHITextureDesc& GetDesc() const { return TextureDesc; }
	
	///
	/// Virtual functions implemented per RHI
	/// 
	
	virtual class FRHITextureReference* GetTextureReference() { return NULL; }
	virtual FRHIDescriptorHandle GetDefaultBindlessHandle() const { return FRHIDescriptorHandle(); }

	/**
	 * Returns access to the platform-specific native resource pointer.  This is designed to be used to provide plugins with access
	 * to the underlying resource and should be used very carefully or not at all.
	 *
	 * @return	The pointer to the native resource or NULL if it not initialized or not supported for this resource type for some reason
	 */
	virtual void* GetNativeResource() const
	{
		// Override this in derived classes to expose access to the native texture resource
		return nullptr;
	}

	/**
	 * Returns access to the platform-specific native shader resource view pointer.  This is designed to be used to provide plugins with access
	 * to the underlying resource and should be used very carefully or not at all.
	 *
	 * @return	The pointer to the native resource or NULL if it not initialized or not supported for this resource type for some reason
	 */
	virtual void* GetNativeShaderResourceView() const
	{
		// Override this in derived classes to expose access to the native texture resource
		return nullptr;
	}

	/**
	 * Returns access to the platform-specific RHI texture baseclass.  This is designed to provide the RHI with fast access to its base classes in the face of multiple inheritance.
	 * @return	The pointer to the platform-specific RHI texture baseclass or NULL if it not initialized or not supported for this RHI
	 */
	virtual void* GetTextureBaseRHI()
	{
		// Override this in derived classes to expose access to the native texture resource
		return nullptr;
	}

	virtual void GetWriteMaskProperties(void*& OutData, uint32& OutSize)
	{
		OutData = nullptr;
		OutSize = 0;
	}

	///
	/// Helper getter functions - non virtual
	/// 

	/**
	 * Returns the x, y & z dimensions if the texture
	 * The Z component will always be 1 for 2D/cube resources and will contain depth for volume textures & array size for array textures
	 */
	FIntVector GetSizeXYZ() const
	{
		const FRHITextureDesc& Desc = GetDesc();
		switch (Desc.Dimension)
		{
		case ETextureDimension::Texture2D:		  return FIntVector(Desc.Extent.X, Desc.Extent.Y, 1);
		case ETextureDimension::Texture2DArray:	  return FIntVector(Desc.Extent.X, Desc.Extent.Y, Desc.ArraySize);
		case ETextureDimension::Texture3D:		  return FIntVector(Desc.Extent.X, Desc.Extent.Y, Desc.Depth);
		case ETextureDimension::TextureCube:	  return FIntVector(Desc.Extent.X, Desc.Extent.Y, 1);
		case ETextureDimension::TextureCubeArray: return FIntVector(Desc.Extent.X, Desc.Extent.Y, Desc.ArraySize);
		}
		return FIntVector(0, 0, 0);
	}

	/**
	 * Returns the dimensions (i.e. the actual number of texels in each dimension) of the specified mip. ArraySize is ignored.
	 * The Z component will always be 1 for 2D/cube resources and will contain depth for volume textures.
	 * This differs from GetSizeXYZ() which returns ArraySize in Z for 2D arrays.
	 */
	FIntVector GetMipDimensions(uint8 MipIndex) const
	{
		const FRHITextureDesc& Desc = GetDesc();
		return FIntVector(
			FMath::Max<int32>(Desc.Extent.X >> MipIndex, 1),
			FMath::Max<int32>(Desc.Extent.Y >> MipIndex, 1),
			FMath::Max<int32>(Desc.Depth    >> MipIndex, 1)
		);
	}

	/** @return Whether the texture is multi sampled. */
	bool IsMultisampled() const { return GetDesc().NumSamples > 1; }

	/** @return Whether the texture has a clear color defined */
	bool HasClearValue() const
	{
		return GetDesc().ClearValue.ColorBinding != EClearBinding::ENoneBound;
	}

	/** @return the clear color value if set */
	FLinearColor GetClearColor() const
	{
		return GetDesc().ClearValue.GetClearColor();
	}

	/** @return the depth & stencil clear value if set */
	void GetDepthStencilClearValue(float& OutDepth, uint32& OutStencil) const
	{
		return GetDesc().ClearValue.GetDepthStencil(OutDepth, OutStencil);
	}

	/** @return the depth clear value if set */
	float GetDepthClearValue() const
	{
		float Depth;
		uint32 Stencil;
		GetDesc().ClearValue.GetDepthStencil(Depth, Stencil);
		return Depth;
	}

	/** @return the stencil clear value if set */
	uint32 GetStencilClearValue() const
	{
		float Depth;
		uint32 Stencil;
		GetDesc().ClearValue.GetDepthStencil(Depth, Stencil);
		return Stencil;
	}

	///
	/// RenderTime & Name functions - non virtual
	/// 

	/** sets the last time this texture was cached in a resource table. */
	FORCEINLINE_DEBUGGABLE void SetLastRenderTime(float InLastRenderTime)
	{
		LastRenderTime.SetLastRenderTime(InLastRenderTime);
	}

	double GetLastRenderTime() const
	{
		return LastRenderTime.GetLastRenderTime();
	}

	RHI_API void SetName(const FName& InName);

	///
	/// Deprecated functions
	/// 

	//UE_DEPRECATED(5.1, "FRHITexture2D is deprecated, please use FRHITexture directly")
	inline FRHITexture* GetTexture2D() { return TextureDesc.Dimension == ETextureDimension::Texture2D ? this : nullptr; }
	//UE_DEPRECATED(5.1, "FRHITexture2DArray is deprecated, please use FRHITexture directly")
	inline FRHITexture* GetTexture2DArray() { return TextureDesc.Dimension == ETextureDimension::Texture2DArray ? this : nullptr; }
	//UE_DEPRECATED(5.1, "FRHITexture3D is deprecated, please use FRHITexture directly")
	inline FRHITexture* GetTexture3D() { return TextureDesc.Dimension == ETextureDimension::Texture3D ? this : nullptr; }
	//UE_DEPRECATED(5.1, "FRHITextureCube is deprecated, please use FRHITexture directly")
	inline FRHITexture* GetTextureCube() { return TextureDesc.IsTextureCube() ? this : nullptr; }

	//UE_DEPRECATED(5.1, "GetSizeX() is deprecated, please use GetDesc().Extent.X instead")
	uint32 GetSizeX() const { return GetDesc().Extent.X; }

	//UE_DEPRECATED(5.1, "GetSizeY() is deprecated, please use GetDesc().Extent.Y instead")
	uint32 GetSizeY() const { return GetDesc().Extent.Y; }

	//UE_DEPRECATED(5.1, "GetSizeXY() is deprecated, please use GetDesc().Extent.X or GetDesc().Extent.Y instead")
	FIntPoint GetSizeXY() const { return FIntPoint(GetDesc().Extent.X, GetDesc().Extent.Y); }

	//UE_DEPRECATED(5.1, "GetSizeZ() is deprecated, please use GetDesc().ArraySize instead for TextureArrays and GetDesc().Depth for 3D textures")
	uint32 GetSizeZ() const { return GetSizeXYZ().Z; }

	//UE_DEPRECATED(5.1, "GetNumMips() is deprecated, please use GetDesc().NumMips instead")
	uint32 GetNumMips() const { return GetDesc().NumMips; }

	//UE_DEPRECATED(5.1, "GetFormat() is deprecated, please use GetDesc().Format instead")
	EPixelFormat GetFormat() const { return GetDesc().Format; }

	//UE_DEPRECATED(5.1, "GetFlags() is deprecated, please use GetDesc().Flags instead")
	ETextureCreateFlags GetFlags() const { return GetDesc().Flags; }

	//UE_DEPRECATED(5.1, "GetNumSamples() is deprecated, please use GetDesc().NumSamples instead")
	uint32 GetNumSamples() const { return GetDesc().NumSamples; }

	//UE_DEPRECATED(5.1, "GetClearBinding() is deprecated, please use GetDesc().ClearValue instead")
	const FClearValueBinding GetClearBinding() const { return GetDesc().ClearValue; }

	//UE_DEPRECATED(5.1, "GetSize() is deprecated, please use GetDesc().Extent.X instead")
	uint32 GetSize() const { check(GetDesc().IsTextureCube()); return GetDesc().Extent.X; }

#if ENABLE_RHI_VALIDATION
	virtual RHIValidation::FResource* GetValidationTrackerResource() override
	{
		// Use the method inherited from RHIValidation::FTextureResource, as that's already a virtual overridden
		// by subclasses such as FRHITextureReference to return the correct storage for the tracker information.
		return GetTrackerResource();
	}
#endif

private:

	friend class FRHITextureReference;
	/** Constructor for texture references */
	FRHITexture(ERHIResourceType InResourceType)
		: FRHIViewableResource(InResourceType, ERHIAccess::Unknown)
	{
		check(InResourceType == RRT_TextureReference);
	}

	FRHITextureDesc TextureDesc;

	FLastRenderTimeContainer LastRenderTime;
};

//
// Misc
//

class FRHITimestampCalibrationQuery : public FRHIResource
{
public:
	FRHITimestampCalibrationQuery() : FRHIResource(RRT_TimestampCalibrationQuery) {}
	uint64 GPUMicroseconds[MAX_NUM_GPUS] = {};
	uint64 CPUMicroseconds[MAX_NUM_GPUS] = {};
};

/*
* Generic GPU fence class.
* Granularity differs depending on backing RHI - ie it may only represent command buffer granularity.
* RHI specific fences derive from this to implement real GPU->CPU fencing.
* The default implementation always returns false for Poll until the next frame from the frame the fence was inserted
* because not all APIs have a GPU/CPU sync object, we need to fake it.
*/
class FRHIGPUFence : public FRHIResource
{
public:
	FRHIGPUFence(FName InName) : FRHIResource(RRT_GPUFence), FenceName(InName) {}
	virtual ~FRHIGPUFence() {}

	virtual void Clear() = 0;

	/**
	 * Poll the fence to see if the GPU has signaled it.
	 * @returns True if and only if the GPU fence has been inserted and the GPU has signaled the fence.
	 */
	virtual bool Poll() const = 0;

	/**
	 * Poll on a subset of the GPUs that this fence supports.
	 */
	virtual bool Poll(FRHIGPUMask GPUMask) const { return Poll(); }

	const FName& GetFName() const { return FenceName; }

	FThreadSafeCounter NumPendingWriteCommands;

protected:
	FName FenceName;
};

// Generic implementation of FRHIGPUFence
class FGenericRHIGPUFence : public FRHIGPUFence
{
public:
	RHI_API FGenericRHIGPUFence(FName InName);

	RHI_API virtual void Clear() final override;

	/** @discussion RHI implementations must be thread-safe and must correctly handle being called before RHIInsertFence if an RHI thread is active. */
	RHI_API virtual bool Poll() const final override;

	RHI_API void WriteInternal();

private:
	uint32 InsertedFrameNumber;
};

class FRHIRenderQuery : public FRHIResource
{
public:
	FRHIRenderQuery() : FRHIResource(RRT_RenderQuery) {}
};

class FRHIRenderQueryPool;

class FRHIPooledRenderQuery
{
	TRefCountPtr<FRHIRenderQuery> Query;
	FRHIRenderQueryPool* QueryPool = nullptr;

public:
	FRHIPooledRenderQuery() = default;
	FRHIPooledRenderQuery(FRHIRenderQueryPool* InQueryPool, TRefCountPtr<FRHIRenderQuery>&& InQuery);
	~FRHIPooledRenderQuery();

	FRHIPooledRenderQuery(const FRHIPooledRenderQuery&) = delete;
	FRHIPooledRenderQuery& operator=(const FRHIPooledRenderQuery&) = delete;
	FRHIPooledRenderQuery(FRHIPooledRenderQuery&&) = default;
	FRHIPooledRenderQuery& operator=(FRHIPooledRenderQuery&&) = default;

	bool IsValid() const
	{
		return Query.IsValid();
	}

	FRHIRenderQuery* GetQuery() const
	{
		return Query;
	}

	void ReleaseQuery();
};

class FRHIRenderQueryPool : public FRHIResource
{
public:
	FRHIRenderQueryPool() : FRHIResource(RRT_RenderQueryPool) {}
	virtual ~FRHIRenderQueryPool() {};
	virtual FRHIPooledRenderQuery AllocateQuery() = 0;

private:
	friend class FRHIPooledRenderQuery;
	virtual void ReleaseQuery(TRefCountPtr<FRHIRenderQuery>&& Query) = 0;
};

inline FRHIPooledRenderQuery::FRHIPooledRenderQuery(FRHIRenderQueryPool* InQueryPool, TRefCountPtr<FRHIRenderQuery>&& InQuery) 
	: Query(MoveTemp(InQuery))
	, QueryPool(InQueryPool)
{
	check(IsInParallelRenderingThread());
}

inline void FRHIPooledRenderQuery::ReleaseQuery()
{
	if (QueryPool && Query.IsValid())
	{
		QueryPool->ReleaseQuery(MoveTemp(Query));
		QueryPool = nullptr;
	}
	check(!Query.IsValid());
}

inline FRHIPooledRenderQuery::~FRHIPooledRenderQuery()
{
	check(IsInParallelRenderingThread());
	ReleaseQuery();
}

class FRHIViewport : public FRHIResource 
{
public:
	FRHIViewport() : FRHIResource(RRT_Viewport) {}

	/**
	 * Returns access to the platform-specific native resource pointer.  This is designed to be used to provide plugins with access
	 * to the underlying resource and should be used very carefully or not at all.
	 *
	 * @return	The pointer to the native resource or NULL if it not initialized or not supported for this resource type for some reason
	 */
	virtual void* GetNativeSwapChain() const { return nullptr; }
	/**
	 * Returns access to the platform-specific native resource pointer to a backbuffer texture.  This is designed to be used to provide plugins with access
	 * to the underlying resource and should be used very carefully or not at all.
	 *
	 * @return	The pointer to the native resource or NULL if it not initialized or not supported for this resource type for some reason
	 */
	virtual void* GetNativeBackBufferTexture() const { return nullptr; }
	/**
	 * Returns access to the platform-specific native resource pointer to a backbuffer rendertarget. This is designed to be used to provide plugins with access
	 * to the underlying resource and should be used very carefully or not at all.
	 *
	 * @return	The pointer to the native resource or NULL if it not initialized or not supported for this resource type for some reason
	 */
	virtual void* GetNativeBackBufferRT() const { return nullptr; }

	/**
	 * Returns access to the platform-specific native window. This is designed to be used to provide plugins with access
	 * to the underlying resource and should be used very carefully or not at all. 
	 *
	 * @return	The pointer to the native resource or NULL if it not initialized or not supported for this resource type for some reason.
	 * AddParam could represent any additional platform-specific data (could be null).
	 */
	virtual void* GetNativeWindow(void** AddParam = nullptr) const { return nullptr; }

	/**
	 * Sets custom Present handler on the viewport
	 */
	virtual void SetCustomPresent(class FRHICustomPresent*) {}

	/**
	 * Returns currently set custom present handler.
	 */
	virtual class FRHICustomPresent* GetCustomPresent() const { return nullptr; }


	/**
	 * Ticks the viewport on the Game thread
	 */
	virtual void Tick(float DeltaTime) {}

	virtual void WaitForFrameEventCompletion() { }

	virtual void IssueFrameEvent() { }
};

/** Used to specify a texture metadata plane when creating a view. */
enum class ERHITexturePlane : uint8
{
	// The primary plane is used with default compression behavior.
	Primary = 0,

	// The primary plane is used without decompressing it.
	PrimaryCompressed = 1,

	// The depth plane is used with default compression behavior.
	Depth = 2,

	// The stencil plane is used with default compression behavior.
	Stencil = 3,

	// The HTile plane is used.
	HTile = 4,

	// the FMask plane is used.
	FMask = 5,

	// the CMask plane is used.
	CMask = 6,

	// This enum is packed into various structures. Avoid adding new 
	// members without verifying structure sizes aren't increased.
	Num,
	NumBits = 3,

	// @todo deprecate
	None = Primary,
	CompressedSurface = PrimaryCompressed,
};
static_assert((1u << uint32(ERHITexturePlane::NumBits)) >= uint32(ERHITexturePlane::Num), "Not enough bits in the ERHITexturePlane enum");

//UE_DEPRECATED(5.3, "Use ERHITexturePlane.")
using ERHITextureMetaDataAccess = ERHITexturePlane;

//
// Views
//

template <typename TType>
struct TRHIRange
{
	TType First = 0;
	TType Num = 0;

	TRHIRange() = default;
	TRHIRange(uint32 InFirst, uint32 InNum)
		: First(InFirst)
		, Num  (InNum)
	{
		check( InFirst < TNumericLimits<TType>::Max()
			&& InNum   < TNumericLimits<TType>::Max()
			&& (InFirst + InNum) < TNumericLimits<TType>::Max());
	}

	TType ExclusiveLast() const { return First + Num; }
	TType InclusiveLast() const { return First + Num - 1; }

	bool IsInRange(uint32 Value) const
	{
		check(Value < TNumericLimits<TType>::Max());
		return Value >= First && Value < ExclusiveLast();
	}
};

using FRHIRange8  = TRHIRange<uint8>;
using FRHIRange16 = TRHIRange<uint16>;

//
// The unified RHI view descriptor. These are stored in the base FRHIView type, and packed to minimize memory usage.
// Platform RHI implementations use the GetViewInfo() functions to convert an FRHIViewDesc into the required info to make a view / descriptor for the GPU.
//
struct FRHIViewDesc
{
	enum class EViewType : uint8
	{
		BufferSRV,
		BufferUAV,
		TextureSRV,
		TextureUAV
	};

	enum class EBufferType : uint8
	{
		Unknown               = 0,

		Typed                 = 1,
		Structured            = 2,
		AccelerationStructure = 3,
		Raw                   = 4
	};

	enum class EDimension : uint8
	{
		Unknown          = 0,

		Texture2D        = 1,
		Texture2DArray   = 2,
		TextureCube      = 3,
		TextureCubeArray = 4,
		Texture3D        = 5,

		NumBits          = 3
	};

	// Properties that apply to all views.
	struct FCommon
	{
		EViewType    ViewType;
		EPixelFormat Format;
	};

	// Properties shared by buffer views. Some fields are SRV or UAV specific.
	struct FBuffer : public FCommon
	{
		EBufferType BufferType;
		uint8       bAtomicCounter : 1; // UAV only
		uint8       bAppendBuffer  : 1; // UAV only
		uint8       /* padding */  : 6;
		uint32      OffsetInBytes;
		union
		{
			struct
			{
				uint32 NumElements;
				uint32 Stride;
			};
			FRHIRayTracingScene* RayTracingScene; // only if BufferType == AccelerationStructure
		};

		struct FViewInfo;
	protected:
		FViewInfo GetViewInfo(FRHIBuffer* TargetBuffer) const;
	};

	// Properties shared by texture views. Some fields are SRV or UAV specific.
	struct FTexture : public FCommon
	{
		ERHITexturePlane Plane        : uint32(ERHITexturePlane::NumBits);
		uint8            bDisableSRGB : 1; // SRV only
		EDimension       Dimension    : uint32(EDimension::NumBits);
		FRHIRange8       MipRange;    // UAVs only support 1 mip
		FRHIRange16      ArrayRange;

		struct FViewInfo;
	protected:
		FViewInfo GetViewInfo(FRHITexture* TargetTexture) const;
	};

	struct FBufferSRV : public FBuffer
	{
		struct FInitializer;
		struct FViewInfo;
		RHI_API FViewInfo GetViewInfo(FRHIBuffer* TargetBuffer) const;
	};

	struct FBufferUAV : public FBuffer
	{
		struct FInitializer;
		struct FViewInfo;
		RHI_API FViewInfo GetViewInfo(FRHIBuffer* TargetBuffer) const;
	};

	struct FTextureSRV : public FTexture
	{
		struct FInitializer;
		struct FViewInfo;
		RHI_API FViewInfo GetViewInfo(FRHITexture* TargetTexture) const;
	};

	struct FTextureUAV : public FTexture
	{
		struct FInitializer;
		struct FViewInfo;
		RHI_API FViewInfo GetViewInfo(FRHITexture* TargetTexture) const;
	};

	union
	{
		FCommon Common;
		union
		{
			FBufferSRV SRV;
			FBufferUAV UAV;
		} Buffer;
		union
		{
			FTextureSRV SRV;
			FTextureUAV UAV;
		} Texture;
	};

	static inline FBufferSRV::FInitializer CreateBufferSRV();
	static inline FBufferUAV::FInitializer CreateBufferUAV();

	static inline FTextureSRV::FInitializer CreateTextureSRV();
	static inline FTextureUAV::FInitializer CreateTextureUAV();

	bool IsSRV() const { return Common.ViewType == EViewType::BufferSRV || Common.ViewType == EViewType::TextureSRV; }
	bool IsUAV() const { return !IsSRV(); }

	bool IsBuffer () const { return Common.ViewType == EViewType::BufferSRV || Common.ViewType == EViewType::BufferUAV; }
	bool IsTexture() const { return !IsBuffer(); }

	bool operator == (FRHIViewDesc const& RHS) const
	{
		return FMemory::Memcmp(this, &RHS, sizeof(*this)) == 0;
	}

	bool operator != (FRHIViewDesc const& RHS) const
	{
		return !(*this == RHS);
	}

	FRHIViewDesc()
		: FRHIViewDesc(EViewType::BufferSRV)
	{
		FMemory::Memzero(*this);
	}

	static const TCHAR* GetBufferTypeString(EBufferType BufferType);
	static const TCHAR* GetTextureDimensionString(EDimension Dimension);

protected:
	FRHIViewDesc(EViewType ViewType)
	{
		FMemory::Memzero(*this);
		Common.ViewType = ViewType;
	}
};

// These static asserts are to ensure the descriptor is minimal in size and can be copied around by-value.
// If they fail, consider re-packing the struct.
static_assert(sizeof(FRHIViewDesc) == 16, "Packing of FRHIViewDesc is unexpected.");
static_assert(TIsTrivial<FRHIViewDesc>::Value, "FRHIViewDesc must be a trivial type.");

struct FRHIViewDesc::FBufferSRV::FInitializer : private FRHIViewDesc
{
	friend FRHIViewDesc;
	friend FRHICommandListBase;
	friend struct FShaderResourceViewInitializer;
	friend struct FRawBufferShaderResourceViewInitializer;

protected:
	FInitializer()
		: FRHIViewDesc(EViewType::BufferSRV)
	{}

public:
	FInitializer& SetType(EBufferType Type)
	{
		check(Type != EBufferType::Unknown);
		Buffer.SRV.BufferType = Type;
		return *this;
	}

	//
	// Provided for back-compat with existing code. Consider using SetType() instead for more direct control over the view.
	// For example, it is possible to create a typed view of a BUF_ByteAddress buffer, but not using this function which always choses raw access.
	//
	FInitializer& SetTypeFromBuffer(FRHIBuffer* TargetBuffer)
	{
		check(TargetBuffer);
		checkf(!TargetBuffer->GetDesc().IsNull(), TEXT("Null buffer resources are placeholders for the streaming system. They do not contain a valid descriptor for this function to use. Call SetType() instead."));

		Buffer.SRV.BufferType =
			EnumHasAnyFlags(TargetBuffer->GetUsage(), BUF_ByteAddressBuffer    ) ? EBufferType::Raw                   :
			EnumHasAnyFlags(TargetBuffer->GetUsage(), BUF_StructuredBuffer     ) ? EBufferType::Structured            :
			EnumHasAnyFlags(TargetBuffer->GetUsage(), BUF_AccelerationStructure) ? EBufferType::AccelerationStructure :
			EBufferType::Typed;
		return *this;
	}

	FInitializer& SetFormat(EPixelFormat InFormat)
	{
		Buffer.SRV.Format = InFormat;
		return *this;
	}

	FInitializer& SetOffsetInBytes(uint32 InOffsetBytes)
	{
		Buffer.SRV.OffsetInBytes = InOffsetBytes;
		return *this;
	}

	FInitializer& SetStride(uint32 InStride)
	{
		check(Buffer.SRV.BufferType != EBufferType::Unknown && Buffer.SRV.BufferType != EBufferType::AccelerationStructure);
		Buffer.SRV.Stride = InStride;
		return *this;
	}

	FInitializer& SetNumElements(uint32 InNumElements)
	{
		check(Buffer.SRV.BufferType != EBufferType::Unknown && Buffer.SRV.BufferType != EBufferType::AccelerationStructure);
		Buffer.SRV.NumElements = InNumElements;
		return *this;
	}

	FInitializer& SetRayTracingScene(FRHIRayTracingScene* InRayTracingScene)
	{
		check(Buffer.SRV.BufferType == EBufferType::AccelerationStructure);
		Buffer.SRV.RayTracingScene = InRayTracingScene;
		return *this;
	}
};

struct FRHIViewDesc::FBufferUAV::FInitializer : private FRHIViewDesc
{
	friend FRHIViewDesc;
	friend FRHICommandListBase;

protected:
	FInitializer()
		: FRHIViewDesc(EViewType::BufferUAV)
	{}

public:
	FInitializer& SetType(EBufferType Type)
	{
		check(Type != EBufferType::Unknown);
		Buffer.UAV.BufferType = Type;
		return *this;
	}

	//
	// Provided for back-compat with existing code. Consider using SetType() instead for more direct control over the view.
	// For example, it is possible to create a typed view of a BUF_ByteAddress buffer, but not using this function which always choses raw access.
	//
	FInitializer& SetTypeFromBuffer(FRHIBuffer* TargetBuffer)
	{
		check(TargetBuffer);
		checkf(!TargetBuffer->GetDesc().IsNull(), TEXT("Null buffer resources are placeholders for the streaming system. They do not contain a valid descriptor for this function to use. Call SetType() instead."));

		Buffer.UAV.BufferType =
			EnumHasAnyFlags(TargetBuffer->GetUsage(), BUF_ByteAddressBuffer    ) ? EBufferType::Raw                   :
			EnumHasAnyFlags(TargetBuffer->GetUsage(), BUF_StructuredBuffer     ) ? EBufferType::Structured            :
			EnumHasAnyFlags(TargetBuffer->GetUsage(), BUF_AccelerationStructure) ? EBufferType::AccelerationStructure :
			EBufferType::Typed;
		return *this;
	}

	FInitializer& SetFormat(EPixelFormat InFormat)
	{
		Buffer.UAV.Format = InFormat;
		return *this;
	}

	FInitializer& SetOffsetInBytes(uint32 InOffsetBytes)
	{
		Buffer.UAV.OffsetInBytes = InOffsetBytes;
		return *this;
	}

	FInitializer& SetStride(uint32 InStride)
	{
		Buffer.UAV.Stride = InStride;
		return *this;
	}

	FInitializer& SetNumElements(uint32 InNumElements)
	{
		Buffer.UAV.NumElements = InNumElements;
		return *this;
	}

	FInitializer& SetAtomicCounter(bool InAtomicCounter)
	{
		Buffer.UAV.bAtomicCounter = InAtomicCounter;
		return *this;
	}

	FInitializer& SetAppendBuffer(bool InAppendBuffer)
	{
		Buffer.UAV.bAppendBuffer = InAppendBuffer;
		return *this;
	}
};

struct FRHIViewDesc::FTextureSRV::FInitializer : private FRHIViewDesc
{
	friend FRHIViewDesc;
	friend FRHICommandListBase;

protected:
	FInitializer()
		: FRHIViewDesc(EViewType::TextureSRV)
	{}

public:
	//
	// Specifies the type of view to create. Must match the shader parameter this view will be bound to.
	// 
	// The dimension is allowed to differ from the underlying resource's dimensions, e.g. to create a view
	// compatible with a Texture2D<> shader parameter, but where the underlying resource is a texture 2D array.
	//
	// Some combinations are not valid, e.g. 3D textures can only have 3D views.
	//
	FInitializer& SetDimension(ETextureDimension InDimension)
	{
		switch (InDimension)
		{
		default: checkNoEntry(); break;
		case ETextureDimension::Texture2D       : Texture.SRV.Dimension = EDimension::Texture2D       ; break;
		case ETextureDimension::Texture2DArray  : Texture.SRV.Dimension = EDimension::Texture2DArray  ; break;
		case ETextureDimension::Texture3D       : Texture.SRV.Dimension = EDimension::Texture3D       ; break;
		case ETextureDimension::TextureCube     : Texture.SRV.Dimension = EDimension::TextureCube     ; break;
		case ETextureDimension::TextureCubeArray: Texture.SRV.Dimension = EDimension::TextureCubeArray; break;
		}
		return *this;
	}

	//
	// Provided for back-compat with existing code. Consider using SetDimension() instead for more direct control over the view.
	// For example, it is possible to create a 2D view of a 2DArray texture, but not using this function which always choses 2DArray dimension.
	//
	FInitializer& SetDimensionFromTexture(FRHITexture* TargetTexture)
	{
		check(TargetTexture);
		SetDimension(TargetTexture->GetDesc().Dimension);
		return *this;
	}

	FInitializer& SetFormat(EPixelFormat InFormat)
	{
		Texture.SRV.Format = InFormat;
		return *this;
	}

	FInitializer& SetPlane(ERHITexturePlane InPlane)
	{
		Texture.SRV.Plane = InPlane;
		return *this;
	}

	FInitializer& SetMipRange(uint8 InFirstMip, uint8 InNumMips)
	{
		Texture.SRV.MipRange.First = InFirstMip;
		Texture.SRV.MipRange.Num = InNumMips;
		return *this;
	}

	//
	// The meaning of array "elements" is given by the dimension of the underlying resource.
	// I.e. a view of a TextureCubeArray resource indexes the array in whole cubes.
	// 
	//     [0] = the first cube (2D slices 0 to 5)
	//     [1] = the second cube (2D slices 6 to 11)
	// 
	// If the view dimension is smaller than the resource dimension, the array range will be further limited.
	// E.g. creating a Texture2D dimension view of a TextureCubeArray resource
	//
	FInitializer& SetArrayRange(uint16 InFirstElement, uint16 InNumElements)
	{
		Texture.SRV.ArrayRange.First = InFirstElement;
		Texture.SRV.ArrayRange.Num = InNumElements;
		return *this;
	}

	FInitializer& SetDisableSRGB(bool InDisableSRGB)
	{
		Texture.SRV.bDisableSRGB = InDisableSRGB;
		return *this;
	}
};

struct FRHIViewDesc::FTextureUAV::FInitializer : private FRHIViewDesc
{
	friend FRHIViewDesc;
	friend FRHICommandListBase;

protected:
	FInitializer()
		: FRHIViewDesc(EViewType::TextureUAV)
	{
		// Texture UAVs only support 1 mip
		Texture.UAV.MipRange.Num = 1;
	}

public:
	//
	// Specifies the type of view to create. Must match the shader parameter this view will be bound to.
	// 
	// The dimension is allowed to differ from the underlying resource's dimensions, e.g. to create a view
	// compatible with an RWTexture2D<> shader parameter, but where the underlying resource is a texture 2D array.
	//
	// Some combinations are not valid, e.g. 3D textures can only have 3D views.
	//
	FInitializer& SetDimension(ETextureDimension InDimension)
	{
		switch (InDimension)
		{
		default: checkNoEntry(); break;
		case ETextureDimension::Texture2D       : Texture.UAV.Dimension = EDimension::Texture2D       ; break;
		case ETextureDimension::Texture2DArray  : Texture.UAV.Dimension = EDimension::Texture2DArray  ; break;
		case ETextureDimension::Texture3D       : Texture.UAV.Dimension = EDimension::Texture3D       ; break;
		case ETextureDimension::TextureCube     : Texture.UAV.Dimension = EDimension::TextureCube     ; break;
		case ETextureDimension::TextureCubeArray: Texture.UAV.Dimension = EDimension::TextureCubeArray; break;
		}
		return *this;
	}

	//
	// Provided for back-compat with existing code. Consider using SetDimension() instead for more direct control over the view.
	// For example, it is possible to create a 2D view of a 2DArray texture, but not using this function which always choses 2DArray dimension.
	//
	FInitializer& SetDimensionFromTexture(FRHITexture* TargetTexture)
	{
		check(TargetTexture);
		SetDimension(TargetTexture->GetDesc().Dimension);
		return *this;
	}

	FInitializer& SetFormat(EPixelFormat InFormat)
	{
		Texture.UAV.Format = InFormat;
		return *this;
	}

	FInitializer& SetPlane(ERHITexturePlane InPlane)
	{
		Texture.UAV.Plane = InPlane;
		return *this;
	}

	FInitializer& SetMipLevel(uint8 InMipLevel)
	{
		Texture.UAV.MipRange.First = InMipLevel;
		return *this;
	}

	//
	// The meaning of array "elements" is given by the dimension of the underlying resource.
	// I.e. a view of a TextureCubeArray resource indexes the array in whole cubes.
	// 
	//     [0] = the first cube (2D slices 0 to 5)
	//     [1] = the second cube (2D slices 6 to 11)
	// 
	// If the view dimension is smaller than the resource dimension, the array range will be further limited.
	// E.g. creating a Texture2D dimension view of a TextureCubeArray resource
	//
	FInitializer& SetArrayRange(uint16 InFirstElement, uint16 InNumElements)
	{
		Texture.UAV.ArrayRange.First = InFirstElement;
		Texture.UAV.ArrayRange.Num = InNumElements;
		return *this;
	}
};

inline FRHIViewDesc::FBufferSRV::FInitializer FRHIViewDesc::CreateBufferSRV()
{
	return FRHIViewDesc::FBufferSRV::FInitializer();
}

inline FRHIViewDesc::FBufferUAV::FInitializer FRHIViewDesc::CreateBufferUAV()
{
	return FRHIViewDesc::FBufferUAV::FInitializer();
}

inline FRHIViewDesc::FTextureSRV::FInitializer FRHIViewDesc::CreateTextureSRV()
{
	return FRHIViewDesc::FTextureSRV::FInitializer();
}

inline FRHIViewDesc::FTextureUAV::FInitializer FRHIViewDesc::CreateTextureUAV()
{
	return FRHIViewDesc::FTextureUAV::FInitializer();
}

//
// Used by platform RHIs to create views of buffers. The data in this structure is computed in GetViewInfo(),
// and is specific to a particular buffer resource. It is not intended to be stored in a view instance.
//
struct FRHIViewDesc::FBuffer::FViewInfo
{
	// The offset in bytes from the beginning of the viewed buffer resource.
	uint32 OffsetInBytes;

	// The size in bytes of a single element in the view.
	uint32 StrideInBytes;

	// The number of elements visible in the view.
	uint32 NumElements;

	// The total number of bytes the data visible in the view covers (i.e. stride * numelements).
	uint32 SizeInBytes;

	// Whether this is a typed / structured / raw view etc.
	EBufferType BufferType;

	// The format of the data exposed by this view. PF_Unknown for all buffer types except typed buffer views.
	EPixelFormat Format;

	// When true, the view is referring to a BUF_NullResource, so a null descriptor should be created.
	bool bNullView;
};

// Buffer SRV specific info
struct FRHIViewDesc::FBufferSRV::FViewInfo : public FRHIViewDesc::FBuffer::FViewInfo
{};

// Buffer UAV specific info
struct FRHIViewDesc::FBufferUAV::FViewInfo : public FRHIViewDesc::FBuffer::FViewInfo
{
	bool bAtomicCounter = false;
	bool bAppendBuffer = false;
};

//
// Used by platform RHIs to create views of textures. The data in this structure is computed in GetViewInfo(),
// and is specific to a particular texture resource. It is not intended to be stored in a view instance.
//
struct FRHIViewDesc::FTexture::FViewInfo
{
	//
	// The range of array "elements" the view covers.
	// 
	// The meaning of "elements" is given by the view dimension.
	// I.e. a view with "Dimension == CubeArray" indexes the array in whole cubes.
	// 
	//		- [0]: the first cube (2D slices 0 to 5)
	//		- [1]: the second cube (2D slices 6 to 11)
	// 
	// 3D textures always have ArrayRange.Num == 1 because there are no "3D texture arrays".
	//
	FRHIRange16 ArrayRange;

	// Which plane of a texture to access (i.e. color, depth, stencil etc). 
	ERHITexturePlane Plane;

	// The typed format to use when reading / writing data in the viewed texture.
	EPixelFormat Format;

	// Specifies how to treat the texture resource when creating the view.
	// E.g. it is possible to create a 2DArray view of a 2D or Cube texture.
	EDimension Dimension : uint32(EDimension::NumBits);

	// True when the view covers every mip of the resource.
	uint8 bAllMips : 1;

	// True when the view covers every array slice of the resource.
	// This includes depth slices for 3D textures, and faces of texture cubes.
	uint8 bAllSlices : 1;
};

// Texture SRV specific info
struct FRHIViewDesc::FTextureSRV::FViewInfo : public FRHIViewDesc::FTexture::FViewInfo
{
	// The range of texture mips the view covers.
	FRHIRange8 MipRange;

	// Indicates if this view should use an sRGB variant of the typed format.
	uint8 bSRGB : 1;
};


// Texture UAV specific info
struct FRHIViewDesc::FTextureUAV::FViewInfo : public FRHIViewDesc::FTexture::FViewInfo
{
	// The single mip level covered by this view.
	uint8 MipLevel;
};

class FRHIView : public FRHIResource
{
public:
	FRHIView(ERHIResourceType InResourceType, FRHIViewableResource* InResource, FRHIViewDesc const& InViewDesc)
		: FRHIResource(InResourceType)
		, Resource(InResource)
		, ViewDesc(InViewDesc)
	{
		checkf(InResource, TEXT("Cannot create a view of a nullptr resource."));
	}

	virtual FRHIDescriptorHandle GetBindlessHandle() const
	{
		return FRHIDescriptorHandle();
	}

	FRHIViewableResource* GetResource() const
	{
		return Resource;
	}

	FRHIBuffer* GetBuffer() const
	{
		check(ViewDesc.IsBuffer());
		return static_cast<FRHIBuffer*>(Resource.GetReference());
	}

	FRHITexture* GetTexture() const
	{
		check(ViewDesc.IsTexture());
		return static_cast<FRHITexture*>(Resource.GetReference());
	}

	bool IsBuffer () const { return ViewDesc.IsBuffer (); }
	bool IsTexture() const { return ViewDesc.IsTexture(); }

#if ENABLE_RHI_VALIDATION
	RHIValidation::FViewIdentity GetViewIdentity() const
	{
		return RHIValidation::FViewIdentity(Resource, ViewDesc);
	}
#endif

	FRHIViewDesc const& GetDesc() const
	{
		return ViewDesc;
	}

private:
	TRefCountPtr<FRHIViewableResource> Resource;

protected:
	FRHIViewDesc const ViewDesc;
};

class FRHIUnorderedAccessView : public FRHIView
{
public:
	explicit FRHIUnorderedAccessView(FRHIViewableResource* InResource, FRHIViewDesc const& InViewDesc)
		: FRHIView(RRT_UnorderedAccessView, InResource, InViewDesc)
	{
		check(ViewDesc.IsUAV());
	}
};

class FRHIShaderResourceView : public FRHIView
{
public:
	explicit FRHIShaderResourceView(FRHIViewableResource* InResource, FRHIViewDesc const& InViewDesc)
		: FRHIView(RRT_ShaderResourceView, InResource, InViewDesc)
	{
		check(ViewDesc.IsSRV());
	}
};

//
// Ray tracing resources
//

enum class ERayTracingInstanceFlags : uint8
{
	None = 0,
	TriangleCullDisable = 1 << 1, // No back face culling. Triangle is visible from both sides.
	TriangleCullReverse = 1 << 2, // Makes triangle front-facing if its vertices are counterclockwise from ray origin.
	ForceOpaque = 1 << 3, // Disable any-hit shader invocation for this instance.
	ForceNonOpaque = 1 << 4, // Force any-hit shader invocation even if geometries inside the instance were marked opaque.
};
ENUM_CLASS_FLAGS(ERayTracingInstanceFlags);

class FRHIRayTracingGeometry;
/**
* High level descriptor of one or more instances of a mesh in a ray tracing scene.
* All instances covered by this descriptor will share shader bindings, but may have different transforms and user data.
*/
struct FRayTracingGeometryInstance
{
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	FRayTracingGeometryInstance() = default;
	FRayTracingGeometryInstance(const FRayTracingGeometryInstance&) = default;
	FRayTracingGeometryInstance& operator=(const FRayTracingGeometryInstance&) = default;
	FRayTracingGeometryInstance(FRayTracingGeometryInstance&&) = default;
	FRayTracingGeometryInstance& operator=(FRayTracingGeometryInstance&&) = default;
	~FRayTracingGeometryInstance() = default;
	PRAGMA_ENABLE_DEPRECATION_WARNINGS

	FRHIRayTracingGeometry* GeometryRHI = nullptr;

	int32 InstanceContributionToHitGroupIndex = INDEX_NONE;

	// A single physical mesh may be duplicated many times in the scene with different transforms and user data.
	// All copies share the same shader binding table entries and therefore will have the same material and shader resources.
	TArrayView<const FMatrix> Transforms;

	// Offsets into the scene's instance scene data buffer used to get instance transforms from GPUScene
	// If BaseInstanceSceneDataOffset != -1, instances are assumed to be continuous.
	int32 BaseInstanceSceneDataOffset = -1;
	TArrayView<const uint32> InstanceSceneDataOffsets;

	// Optional buffer that stores GPU transforms. Used instead of CPU-side transform data.
	UE_DEPRECATED(5.5, "GPUTransformsSRV has been deprecated. GPU Scene should be used instead.")
	FShaderResourceViewRHIRef GPUTransformsSRV = nullptr;

	// Conservative number of instances. Some of the actual instances may be made inactive if GPU transforms are used.
	// Must be less or equal to number of entries in Transforms view if CPU transform data is used.
	uint32 NumTransforms = 0;

	// Each geometry copy can receive a user-provided integer, which can be used to retrieve extra shader parameters or customize appearance.
	// This data can be retrieved using GetInstanceUserData() in closest/any hit shaders.
	// If UserData view is empty, then DefaultUserData value will be used for all instances.
	// If UserData view is used, then it must have the same number of entries as NumInstances.
	uint32 DefaultUserData = 0;
	TArrayView<const uint32> UserData;

	// Whether local bounds scale and center translation should be applied to the instance transform.
	bool bApplyLocalBoundsTransform = false;
	// Whether to increment UserData for each instance of this geometry (only applied when using DefaultUserData)
	bool bIncrementUserDataPerInstance = false;

	// Mask that will be tested against one provided to TraceRay() in shader code.
	// If binary AND of instance mask with ray mask is zero, then the instance is considered not intersected / invisible.
	uint8 Mask = 0xFF;

	UE_DEPRECATED(5.5, "Specify layer when adding instances to FRayTracingScene instead.")
	uint8 LayerIndex = 0;

	// Flags to control triangle back face culling, whether to allow any-hit shaders, etc.
	ERayTracingInstanceFlags Flags = ERayTracingInstanceFlags::None;
};

enum ERayTracingGeometryType
{
	// Indexed or non-indexed triangle list with fixed function ray intersection.
	// Vertex buffer must contain vertex positions as VET_Float3.
	// Vertex stride must be at least 12 bytes, but may be larger to support custom per-vertex data.
	// Index buffer may be provided for indexed triangle lists. Implicit triangle list is assumed otherwise.
	RTGT_Triangles,

	// Custom primitive type that requires an intersection shader.
	// Vertex buffer for procedural geometry must contain one AABB per primitive as {float3 MinXYZ, float3 MaxXYZ}.
	// Vertex stride must be at least 24 bytes, but may be larger to support custom per-primitive data.
	// Index buffers can't be used with procedural geometry.
	RTGT_Procedural,
};
DECLARE_INTRINSIC_TYPE_LAYOUT(ERayTracingGeometryType);

enum class ERayTracingGeometryInitializerType : uint8
{
	// Fully initializes the RayTracingGeometry object: creates underlying buffer and initializes shader parameters.
	Rendering,

	// Does not create underlying buffer or shader parameters. Used by the streaming system as an object that is streamed into. 
	StreamingDestination,

	// Creates buffers but does not create shader parameters. Used for intermediate objects in the streaming system.
	StreamingSource,
};
DECLARE_INTRINSIC_TYPE_LAYOUT(ERayTracingGeometryInitializerType);

struct FRayTracingGeometrySegment
{
public:
	FBufferRHIRef VertexBuffer = nullptr;
	EVertexElementType VertexBufferElementType = VET_Float3;

	// Offset in bytes from the base address of the vertex buffer.
	uint32 VertexBufferOffset = 0;

	// Number of bytes between elements of the vertex buffer (sizeof VET_Float3 by default).
	// Must be equal or greater than the size of the position vector.
	uint32 VertexBufferStride = 12;

	// Number of vertices (positions) in VertexBuffer.
	// If an index buffer is present, this must be at least the maximum index value in the index buffer + 1.
	uint32 MaxVertices = 0;

	// Primitive range for this segment.
	uint32 FirstPrimitive = 0;
	uint32 NumPrimitives = 0;

	// Indicates whether any-hit shader could be invoked when hitting this geometry segment.
	// Setting this to `false` turns off any-hit shaders, making the section "opaque" and improving ray tracing performance.
	bool bForceOpaque = false;

	// Any-hit shader may be invoked multiple times for the same primitive during ray traversal.
	// Setting this to `false` guarantees that only a single instance of any-hit shader will run per primitive, at some performance cost.
	bool bAllowDuplicateAnyHitShaderInvocation = true;

	// Indicates whether this section is enabled and should be taken into account during acceleration structure creation
	bool bEnabled = true;
};

struct FRayTracingGeometryInitializer
{
public:
	FBufferRHIRef IndexBuffer = nullptr;

	// Offset in bytes from the base address of the index buffer.
	uint32 IndexBufferOffset = 0;

	ERayTracingGeometryType GeometryType = RTGT_Triangles;

	// Total number of primitives in all segments of the geometry. Only used for validation.
	uint32 TotalPrimitiveCount = 0;

	bool bFastBuild = false;
	bool bAllowUpdate = false;
	bool bAllowCompaction = true;
	ERayTracingGeometryInitializerType Type = ERayTracingGeometryInitializerType::Rendering;

	// Partitions of geometry to allow different shader and resource bindings.
	// All ray tracing geometries must have at least one segment.
	TArray<FRayTracingGeometrySegment> Segments;

	// Offline built geometry data. If null, the geometry will be built by the RHI at runtime.
	FResourceArrayUploadInterface* OfflineData = nullptr;

	// Pointer to an existing ray tracing geometry which the new geometry is built from.
	FRHIRayTracingGeometry* SourceGeometry = nullptr;

	// Use FDebugName for auto-generated debug names with numbered suffixes, it is a variation of FMemoryImageName with optional number postfix.
	FDebugName DebugName;
	// Store the path name of the owner object for resource tracking. FMemoryImageName allows a conversion to/from FName.
	FName OwnerName;
};

#if DO_CHECK
FORCEINLINE bool operator==(const FRayTracingGeometryInitializer& LHS, const FRayTracingGeometryInitializer& RHS)
{
	// Can't compare LHS == RHS directly due to some members not having equality operators

	if (LHS.IndexBuffer != RHS.IndexBuffer
		|| LHS.IndexBufferOffset != RHS.IndexBufferOffset
		|| LHS.GeometryType != RHS.GeometryType
		|| LHS.TotalPrimitiveCount != RHS.TotalPrimitiveCount)
	{
		return false;
	}

	// Can't compare Segments directly due to some members not having equality operators
	if (LHS.Segments.Num() != RHS.Segments.Num())
	{
		return false;
	}

	for (int32 SegmentIndex = 0; SegmentIndex < LHS.Segments.Num(); ++SegmentIndex)
	{
		//if (LHS.Segments[SegmentIndex] != RHS.Segments[SegmentIndex])
		//{
		//	return false;
		//}

		if (LHS.Segments[SegmentIndex].VertexBuffer != RHS.Segments[SegmentIndex].VertexBuffer
			|| LHS.Segments[SegmentIndex].VertexBufferElementType != RHS.Segments[SegmentIndex].VertexBufferElementType
			|| LHS.Segments[SegmentIndex].VertexBufferOffset != RHS.Segments[SegmentIndex].VertexBufferOffset
			|| LHS.Segments[SegmentIndex].VertexBufferStride != RHS.Segments[SegmentIndex].VertexBufferStride
			|| LHS.Segments[SegmentIndex].MaxVertices != RHS.Segments[SegmentIndex].MaxVertices
			|| LHS.Segments[SegmentIndex].FirstPrimitive != RHS.Segments[SegmentIndex].FirstPrimitive
			|| LHS.Segments[SegmentIndex].NumPrimitives != RHS.Segments[SegmentIndex].NumPrimitives
			|| LHS.Segments[SegmentIndex].bForceOpaque != RHS.Segments[SegmentIndex].bForceOpaque
			|| LHS.Segments[SegmentIndex].bAllowDuplicateAnyHitShaderInvocation != RHS.Segments[SegmentIndex].bAllowDuplicateAnyHitShaderInvocation
			|| LHS.Segments[SegmentIndex].bEnabled != RHS.Segments[SegmentIndex].bEnabled)
		{
			return false;
		}
	}

	if (LHS.OfflineData != RHS.OfflineData
		|| LHS.SourceGeometry != RHS.SourceGeometry
		|| LHS.bFastBuild != RHS.bFastBuild
		|| LHS.bAllowUpdate != RHS.bAllowUpdate
		|| LHS.bAllowCompaction != RHS.bAllowCompaction
		|| LHS.Type != RHS.Type)
	{
		return false;
	}

	// Can't compare DebugName directly due to FDebugName not having equality operator
	if (LHS.OwnerName != RHS.OwnerName)
	{
		return false;
	}

	return true;
}
#endif

enum ERayTracingSceneLifetime
{
	// Scene may only be used during the frame when it was created.
	RTSL_SingleFrame,

	// Scene may be constructed once and used in any number of later frames (not currently implemented).
	// RTSL_MultiFrame,
};

enum class ERayTracingAccelerationStructureFlags
{
	None = 0,
	AllowUpdate = 1 << 0,
	AllowCompaction = 1 << 1,
	FastTrace = 1 << 2,
	FastBuild = 1 << 3,
	MinimizeMemory = 1 << 4,
};
ENUM_CLASS_FLAGS(ERayTracingAccelerationStructureFlags);

enum class ERayTracingShaderBindingMode
{
	Disabled	= 0,				//< No binding data at all
	Inline		= 1 << 0,			//< Binding data for inline raytracing
	RTPSO		= 1 << 1,			//< Binding data for raytracing using RTPSOs
};
ENUM_CLASS_FLAGS(ERayTracingShaderBindingMode);

enum class ERayTracingHitGroupIndexingMode
{
	Allow,
	Disallow,
};
ENUM_CLASS_FLAGS(ERayTracingHitGroupIndexingMode);

struct FRayTracingShaderBindingTableInitializer
{
	// Defines which types of binding data needs to be stored in the SBT (Inline and/or RTPSO)
	ERayTracingShaderBindingMode ShaderBindingMode = ERayTracingShaderBindingMode::Disabled;
	
	// Allow indexing of the hit group shaders for RTPSO bindings - if disabled then the SBT won't store any hit group data
	ERayTracingHitGroupIndexingMode HitGroupIndexingMode = ERayTracingHitGroupIndexingMode::Allow;

	// Local binding data size used for each entry in the SBT (needs to be at least as big as the local binding data size of all shaders used in the SBT) 
	uint32 LocalBindingDataSize = 0;

	// This value controls how many elements will be allocated in the shader binding table per geometry segment.
	// Changing this value allows different hit shaders to be used for different effects.
	// For example, setting this to 2 allows one hit shader for regular material evaluation and a different one for shadows.
	// Desired hit shader can be selected by providing appropriate RayContributionToHitGroupIndex to TraceRay() function.
	// Use ShaderSlot argument in SetRayTracingHitGroup() to assign shaders and resources for specific part of the shder binding table record.
	uint32 NumShaderSlotsPerGeometrySegment = 1;

	// Maximum number of geometry segments which can be stored in the hit group binding data
	uint32 NumGeometrySegments = 0;

	// At least one miss shader must be present in a ray tracing scene.
	// Default miss shader is always in slot 0. Default shader must not use local resources.
	// Custom miss shaders can be bound to other slots using SetRayTracingMissShader().
	uint32 NumMissShaderSlots = 1;

	// Defines how many different callable shaders with unique resource bindings can be bound to this scene.
	// Shaders and resources are assigned to slots in the scene using SetRayTracingCallableShader().
	uint32 NumCallableShaderSlots = 0;
};

struct FRayTracingSceneInitializer
{
	// Unique list of geometries referenced by all instances in this scene.
	// Any referenced geometry is kept alive while the scene is alive.
	UE_DEPRECATED(5.5, "ReferencedGeometries should be provided in FRayTracingSceneBuildParams.")
	TArray<TRefCountPtr<FRHIRayTracingGeometry>> ReferencedGeometries;
	// One entry per instance
	UE_DEPRECATED(5.5, "PerInstanceGeometries should be provided in FRayTracingSceneBuildParams.")
	TArray<FRHIRayTracingGeometry*> PerInstanceGeometries;

	// Exclusive prefix sum of `Instance.NumTransforms` for all instances in this scene. Used to emulate SV_InstanceID in hit shaders.
	UE_DEPRECATED(5.5, "Providing BaseInstancePrefixSum is no longer necessary.")
	TArray<uint32> BaseInstancePrefixSum;
	// Exclusive prefix sum of instance geometry segments is used to calculate SBT record address from instance and segment indices.
	UE_DEPRECATED(5.5, "Providing SegmentPrefixSum is no longer necessary.")
	TArray<uint32> SegmentPrefixSum;

	// Total flattened number of ray tracing geometry instances (a single FRayTracingGeometryInstance may represent many) per layer.
	UE_DEPRECATED(5.5, "FRHIRayTracingScene layers are deprecated. Use MaxNumInstances and create one FRHIRayTracingScene per layer instead.")
	TArray<uint32> NumNativeInstancesPerLayer;

	// Maximum number of instances in this scene. Actual number of instances is specified in FRayTracingSceneBuildParams.
	uint32 MaxNumInstances = 0;

	uint32 NumTotalSegments = 0;

	UE_DEPRECATED(5.5, "Use FRayTracingShaderBindingTableInitializer instead.")
	uint32 ShaderSlotsPerGeometrySegment = 1;

	UE_DEPRECATED(5.5, "Use FRayTracingShaderBindingTableInitializer instead.")
	uint32 NumCallableShaderSlots = 0;

	UE_DEPRECATED(5.5, "Use FRayTracingShaderBindingTableInitializer instead.")
	uint32 NumMissShaderSlots = 1;

	// Defines whether data in this scene should persist between frames.
	// Currently only single-frame lifetime is supported.
	ERayTracingSceneLifetime Lifetime = RTSL_SingleFrame;
	
	// Controls the flags of the ray tracing scene build.
	ERayTracingAccelerationStructureFlags BuildFlags = ERayTracingAccelerationStructureFlags::FastTrace;

	FName DebugName;

	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	FRayTracingSceneInitializer() = default;
	FRayTracingSceneInitializer(FRayTracingSceneInitializer&&) = default;
	FRayTracingSceneInitializer& operator=(FRayTracingSceneInitializer&&) = default;
	PRAGMA_ENABLE_DEPRECATION_WARNINGS
};

using FRayTracingSceneInitializer2 UE_DEPRECATED(5.5, "Use FRayTracingSceneInitializer instead") = FRayTracingSceneInitializer;

struct FRayTracingAccelerationStructureSize
{
	uint64 ResultSize = 0;
	uint64 BuildScratchSize = 0;
	uint64 UpdateScratchSize = 0;
};

class FRHIRayTracingAccelerationStructure
	: public FRHIResource
#if ENABLE_RHI_VALIDATION
	, public RHIValidation::FAccelerationStructureResource
#endif
{
public:
	FRHIRayTracingAccelerationStructure() : FRHIResource(RRT_RayTracingAccelerationStructure) {}

	FRayTracingAccelerationStructureSize GetSizeInfo() const
	{
		return SizeInfo;
	};

protected:
	FRayTracingAccelerationStructureSize SizeInfo = {};
};

using FRayTracingAccelerationStructureAddress = uint64;

/** Bottom level ray tracing acceleration structure (contains triangles). */
class FRHIRayTracingGeometry : public FRHIRayTracingAccelerationStructure
{
public:
	FRHIRayTracingGeometry() = default;
	FRHIRayTracingGeometry(const FRayTracingGeometryInitializer& InInitializer)
		: Initializer(InInitializer)
	{}

	virtual FRayTracingAccelerationStructureAddress GetAccelerationStructureAddress(uint64 GPUIndex) const = 0;
	virtual bool IsCompressed() const { return false; }

	const FRayTracingGeometryInitializer& GetInitializer() const
	{
		return Initializer;
	}

	uint32 GetNumSegments() const 
	{ 
		return Initializer.Segments.Num(); 
	}
protected:
	FRayTracingGeometryInitializer Initializer = {};
};

/** Top level ray tracing acceleration structure (contains instances of meshes). */
class FRHIRayTracingScene
	: public FRHIRayTracingAccelerationStructure
{
public:
	virtual const FRayTracingSceneInitializer& GetInitializer() const = 0;

	UE_DEPRECATED(5.5, "Use GetOrCreateInlineBufferSRV on the FRHIShaderBindingTable instead of the Scene")
	virtual FRHIShaderResourceView* GetOrCreateMetadataBufferSRV(FRHICommandListImmediate& RHICmdList)
	{
		return nullptr;
	}

	UE_DEPRECATED(5.5, "FRHIRayTracingScene layers are deprecated. Create one FRHIRayTracingScene per layer instead.")
	virtual uint32 GetLayerBufferOffset(uint32 LayerIndex) const
	{
		checkf(LayerIndex == 0, TEXT("FRHIRayTracingScene layers are deprecated. Create one FRHIRayTracingScene per layer instead."));
		return 0;
	}

	UE_DEPRECATED(5.5, "Create standalone FRHIShaderBindingTable instead.")
	virtual FRHIShaderBindingTable* FindOrCreateShaderBindingTable(const FRHIRayTracingPipelineState* Pipeline) = 0;
};

class FRHIShaderBindingTable
	: public FRHIResource
#if ENABLE_RHI_VALIDATION
	, public RHIValidation::FRayTracingShaderBindingTable
#endif
{
public:
	FRHIShaderBindingTable(const FRayTracingShaderBindingTableInitializer& InInitializer)
		: FRHIResource(RRT_RayTracingShaderBindingTable)
		, Initializer(InInitializer)
	{}

	const FRayTracingShaderBindingTableInitializer& GetInitializer() const
	{
		return Initializer;
	}

	// Returns a buffer view for RHI-specific system parameters associated with this SBT.
	// This may be needed to access ray tracing geometry data in shaders that use ray queries.
	// Returns NULL if current RHI does not require this buffer.
	virtual FRHIShaderResourceView* GetOrCreateInlineBufferSRV(FRHICommandListBase& RHICmdList)
	{
		return nullptr;
	}

protected:
	FRayTracingShaderBindingTableInitializer Initializer = {};
};

enum class ERHIShaderBundleMode : uint8
{
	// Compute shaders
	CS,

	// Mesh and pixel shaders
	MSPS,

	// Vertex and pixel shaders
	VSPS,

	MAX
};

class FShaderBundleCreateInfo
{
public:
	FShaderBundleCreateInfo() = default;

	uint32 NumRecords	= 0u;
	uint32 ArgOffset	= 0u;
	uint32 ArgStride	= 0u;

	ERHIShaderBundleMode Mode = ERHIShaderBundleMode::CS;
};

class FRHIShaderBundle : public FRHIResource
{
public:
	const uint32 NumRecords	= 0;
	const uint32 ArgOffset	= 0;
	const uint32 ArgStride	= 0;
	const ERHIShaderBundleMode Mode = ERHIShaderBundleMode::CS;

	FName ModeName;

public:
	FRHIShaderBundle(const FShaderBundleCreateInfo& CreateInfo)
	: FRHIResource(RRT_ShaderBundle)
	, NumRecords(CreateInfo.NumRecords)
	, ArgOffset(CreateInfo.ArgOffset)
	, ArgStride(CreateInfo.ArgStride)
	, Mode(CreateInfo.Mode)
	{
		if (Mode == ERHIShaderBundleMode::CS)
		{
			// Load3
			check(ArgStride >= 12u);
			ModeName = TEXT("CS");
		}
		else if (Mode == ERHIShaderBundleMode::MSPS)
		{
			// Load
			check(ArgStride >= 4u);
			ModeName = TEXT("MSPS");
		}
		else if (Mode == ERHIShaderBundleMode::VSPS)
		{
			// Load4
			check(ArgStride >= 16u);
			ModeName = TEXT("VSPS");
		}
		else
		{
			checkNoEntry();
		}
	}
};

/* Generic staging buffer class used by FRHIGPUMemoryReadback
* RHI specific staging buffers derive from this
*/
class FRHIStagingBuffer : public FRHIResource
{
public:
	FRHIStagingBuffer()
		: FRHIResource(RRT_StagingBuffer)
		, bIsLocked(false)
	{}

	virtual ~FRHIStagingBuffer() {}

	virtual void *Lock(uint32 Offset, uint32 NumBytes) = 0;
	virtual void Unlock() = 0;

	// For debugging, may not be implemented on all RHIs
	virtual uint64 GetGPUSizeBytes() const { return 0; }

protected:
	bool bIsLocked;
};

class FGenericRHIStagingBuffer : public FRHIStagingBuffer
{
public:
	FGenericRHIStagingBuffer()
		: FRHIStagingBuffer()
	{}

	~FGenericRHIStagingBuffer() {}

	RHI_API virtual void* Lock(uint32 Offset, uint32 NumBytes) final override;
	RHI_API virtual void Unlock() final override;
	virtual uint64 GetGPUSizeBytes() const final override { return ShadowBuffer.IsValid() ? ShadowBuffer->GetSize() : 0; }

	FBufferRHIRef ShadowBuffer;
	uint32 Offset;
};

class FRHIRenderTargetView
{
public:
	FRHITexture* Texture = nullptr;
	uint32 MipIndex = 0;

	/** Array slice or texture cube face.  Only valid if texture resource was created with TexCreate_TargetArraySlicesIndependently! */
	uint32 ArraySliceIndex = -1;

	ERenderTargetLoadAction LoadAction = ERenderTargetLoadAction::ENoAction;
	ERenderTargetStoreAction StoreAction = ERenderTargetStoreAction::ENoAction;

	FRHIRenderTargetView() = default;
	FRHIRenderTargetView(FRHIRenderTargetView&&) = default;
	FRHIRenderTargetView(const FRHIRenderTargetView&) = default;
	FRHIRenderTargetView& operator=(FRHIRenderTargetView&&) = default;
	FRHIRenderTargetView& operator=(const FRHIRenderTargetView&) = default;

	//common case
	explicit FRHIRenderTargetView(FRHITexture* InTexture, ERenderTargetLoadAction InLoadAction) :
		Texture(InTexture),
		MipIndex(0),
		ArraySliceIndex(-1),
		LoadAction(InLoadAction),
		StoreAction(ERenderTargetStoreAction::EStore)
	{}

	//common case
	explicit FRHIRenderTargetView(FRHITexture* InTexture, ERenderTargetLoadAction InLoadAction, uint32 InMipIndex, uint32 InArraySliceIndex) :
		Texture(InTexture),
		MipIndex(InMipIndex),
		ArraySliceIndex(InArraySliceIndex),
		LoadAction(InLoadAction),
		StoreAction(ERenderTargetStoreAction::EStore)
	{}
	
	explicit FRHIRenderTargetView(FRHITexture* InTexture, uint32 InMipIndex, uint32 InArraySliceIndex, ERenderTargetLoadAction InLoadAction, ERenderTargetStoreAction InStoreAction) :
		Texture(InTexture),
		MipIndex(InMipIndex),
		ArraySliceIndex(InArraySliceIndex),
		LoadAction(InLoadAction),
		StoreAction(InStoreAction)
	{}

	bool operator==(const FRHIRenderTargetView& Other) const
	{
		return 
			Texture == Other.Texture &&
			MipIndex == Other.MipIndex &&
			ArraySliceIndex == Other.ArraySliceIndex &&
			LoadAction == Other.LoadAction &&
			StoreAction == Other.StoreAction;
	}
};

class FRHIDepthRenderTargetView
{
public:
	FRHITexture* Texture;

	ERenderTargetLoadAction		DepthLoadAction;
	ERenderTargetStoreAction	DepthStoreAction;
	ERenderTargetLoadAction		StencilLoadAction;

private:
	ERenderTargetStoreAction	StencilStoreAction;
	FExclusiveDepthStencil		DepthStencilAccess;
public:

	// accessor to prevent write access to StencilStoreAction
	ERenderTargetStoreAction GetStencilStoreAction() const { return StencilStoreAction; }
	// accessor to prevent write access to DepthStencilAccess
	FExclusiveDepthStencil GetDepthStencilAccess() const { return DepthStencilAccess; }

	explicit FRHIDepthRenderTargetView() :
		Texture(nullptr),
		DepthLoadAction(ERenderTargetLoadAction::ENoAction),
		DepthStoreAction(ERenderTargetStoreAction::ENoAction),
		StencilLoadAction(ERenderTargetLoadAction::ENoAction),
		StencilStoreAction(ERenderTargetStoreAction::ENoAction),
		DepthStencilAccess(FExclusiveDepthStencil::DepthNop_StencilNop)
	{
		Validate();
	}

	//common case
	explicit FRHIDepthRenderTargetView(FRHITexture* InTexture, ERenderTargetLoadAction InLoadAction, ERenderTargetStoreAction InStoreAction) :
		Texture(InTexture),
		DepthLoadAction(InLoadAction),
		DepthStoreAction(InStoreAction),
		StencilLoadAction(InLoadAction),
		StencilStoreAction(InStoreAction),
		DepthStencilAccess(FExclusiveDepthStencil::DepthWrite_StencilWrite)
	{
		Validate();
	}

	explicit FRHIDepthRenderTargetView(FRHITexture* InTexture, ERenderTargetLoadAction InLoadAction, ERenderTargetStoreAction InStoreAction, FExclusiveDepthStencil InDepthStencilAccess) :
		Texture(InTexture),
		DepthLoadAction(InLoadAction),
		DepthStoreAction(InStoreAction),
		StencilLoadAction(InLoadAction),
		StencilStoreAction(InStoreAction),
		DepthStencilAccess(InDepthStencilAccess)
	{
		Validate();
	}

	explicit FRHIDepthRenderTargetView(FRHITexture* InTexture, ERenderTargetLoadAction InDepthLoadAction, ERenderTargetStoreAction InDepthStoreAction, ERenderTargetLoadAction InStencilLoadAction, ERenderTargetStoreAction InStencilStoreAction) :
		Texture(InTexture),
		DepthLoadAction(InDepthLoadAction),
		DepthStoreAction(InDepthStoreAction),
		StencilLoadAction(InStencilLoadAction),
		StencilStoreAction(InStencilStoreAction),
		DepthStencilAccess(FExclusiveDepthStencil::DepthWrite_StencilWrite)
	{
		Validate();
	}

	explicit FRHIDepthRenderTargetView(FRHITexture* InTexture, ERenderTargetLoadAction InDepthLoadAction, ERenderTargetStoreAction InDepthStoreAction, ERenderTargetLoadAction InStencilLoadAction, ERenderTargetStoreAction InStencilStoreAction, FExclusiveDepthStencil InDepthStencilAccess) :
		Texture(InTexture),
		DepthLoadAction(InDepthLoadAction),
		DepthStoreAction(InDepthStoreAction),
		StencilLoadAction(InStencilLoadAction),
		StencilStoreAction(InStencilStoreAction),
		DepthStencilAccess(InDepthStencilAccess)
	{
		Validate();
	}

	void Validate() const
	{
		// VK and Metal MAY leave the attachment in an undefined state if the StoreAction is DontCare. So we can't assume read-only implies it should be DontCare unless we know for sure it will never be used again.
		// ensureMsgf(DepthStencilAccess.IsDepthWrite() || DepthStoreAction == ERenderTargetStoreAction::ENoAction, TEXT("Depth is read-only, but we are performing a store.  This is a waste on mobile.  If depth can't change, we don't need to store it out again"));
		/*ensureMsgf(DepthStencilAccess.IsStencilWrite() || StencilStoreAction == ERenderTargetStoreAction::ENoAction, TEXT("Stencil is read-only, but we are performing a store.  This is a waste on mobile.  If stencil can't change, we don't need to store it out again"));*/
	}

	bool operator==(const FRHIDepthRenderTargetView& Other) const
	{
		return
			Texture == Other.Texture &&
			DepthLoadAction == Other.DepthLoadAction &&
			DepthStoreAction == Other.DepthStoreAction &&
			StencilLoadAction == Other.StencilLoadAction &&
			StencilStoreAction == Other.StencilStoreAction &&
			DepthStencilAccess == Other.DepthStencilAccess;
	}
};

class FRHISetRenderTargetsInfo
{
public:
	// Color Render Targets Info
	FRHIRenderTargetView ColorRenderTarget[MaxSimultaneousRenderTargets];	
	int32 NumColorRenderTargets;
	bool bClearColor;

	// Color Render Targets Info
	FRHIRenderTargetView ColorResolveRenderTarget[MaxSimultaneousRenderTargets];	
	bool bHasResolveAttachments;

	// Depth/Stencil Render Target Info
	FRHIDepthRenderTargetView DepthStencilRenderTarget;	
	// Used when depth resolve is enabled.
	FRHIDepthRenderTargetView DepthStencilResolveRenderTarget;
	bool bClearDepth;
	bool bClearStencil;

	FRHITexture* ShadingRateTexture;
	EVRSRateCombiner ShadingRateTextureCombiner;

	uint8 MultiViewCount;

	FRHISetRenderTargetsInfo() :
		NumColorRenderTargets(0),
		bClearColor(false),
		bHasResolveAttachments(false),
		bClearDepth(false),
		ShadingRateTexture(nullptr),
		MultiViewCount(0)
	{}

	FRHISetRenderTargetsInfo(int32 InNumColorRenderTargets, const FRHIRenderTargetView* InColorRenderTargets, const FRHIDepthRenderTargetView& InDepthStencilRenderTarget) :
		NumColorRenderTargets(InNumColorRenderTargets),
		bClearColor(InNumColorRenderTargets > 0 && InColorRenderTargets[0].LoadAction == ERenderTargetLoadAction::EClear),
		bHasResolveAttachments(false),
		DepthStencilRenderTarget(InDepthStencilRenderTarget),		
		bClearDepth(InDepthStencilRenderTarget.Texture && InDepthStencilRenderTarget.DepthLoadAction == ERenderTargetLoadAction::EClear),
		ShadingRateTexture(nullptr),
		ShadingRateTextureCombiner(VRSRB_Passthrough)
	{
		check(InNumColorRenderTargets <= 0 || InColorRenderTargets);
		for (int32 Index = 0; Index < InNumColorRenderTargets; ++Index)
		{
			ColorRenderTarget[Index] = InColorRenderTargets[Index];			
		}
	}
	// @todo metal mrt: This can go away after all the cleanup is done
	void SetClearDepthStencil(bool bInClearDepth, bool bInClearStencil = false)
	{
		if (bInClearDepth)
		{
			DepthStencilRenderTarget.DepthLoadAction = ERenderTargetLoadAction::EClear;
		}
		if (bInClearStencil)
		{
			DepthStencilRenderTarget.StencilLoadAction = ERenderTargetLoadAction::EClear;
		}
		bClearDepth = bInClearDepth;		
		bClearStencil = bInClearStencil;		
	}

	uint32 CalculateHash() const
	{
		// Need a separate struct so we can memzero/remove dependencies on reference counts
		struct FHashableStruct
		{
			// *2 for color and resolves
			// depth goes in the third-to-last slot
			// depth resolve goes in the second-to-last slot
			// shading rate goes in the last slot
			FRHITexture* Texture[MaxSimultaneousRenderTargets*2 + 3];
			uint32 MipIndex[MaxSimultaneousRenderTargets];
			uint32 ArraySliceIndex[MaxSimultaneousRenderTargets];
			ERenderTargetLoadAction LoadAction[MaxSimultaneousRenderTargets];
			ERenderTargetStoreAction StoreAction[MaxSimultaneousRenderTargets];

			ERenderTargetLoadAction		DepthLoadAction;
			ERenderTargetStoreAction	DepthStoreAction;
			ERenderTargetLoadAction		StencilLoadAction;
			ERenderTargetStoreAction	StencilStoreAction;
			FExclusiveDepthStencil		DepthStencilAccess;

			bool bClearDepth;
			bool bClearStencil;
			bool bClearColor;
			bool bHasResolveAttachments;
			FRHIUnorderedAccessView* UnorderedAccessView[MaxSimultaneousUAVs];
			uint8 MultiViewCount;

			void Set(const FRHISetRenderTargetsInfo& RTInfo)
			{
				FMemory::Memzero(*this);
				for (int32 Index = 0; Index < RTInfo.NumColorRenderTargets; ++Index)
				{
					Texture[Index] = RTInfo.ColorRenderTarget[Index].Texture;
					Texture[MaxSimultaneousRenderTargets+Index] = RTInfo.ColorResolveRenderTarget[Index].Texture;
					MipIndex[Index] = RTInfo.ColorRenderTarget[Index].MipIndex;
					ArraySliceIndex[Index] = RTInfo.ColorRenderTarget[Index].ArraySliceIndex;
					LoadAction[Index] = RTInfo.ColorRenderTarget[Index].LoadAction;
					StoreAction[Index] = RTInfo.ColorRenderTarget[Index].StoreAction;
				}

				Texture[MaxSimultaneousRenderTargets*2] = RTInfo.DepthStencilRenderTarget.Texture;
				Texture[MaxSimultaneousRenderTargets*2 + 1] = RTInfo.DepthStencilResolveRenderTarget.Texture;
				Texture[MaxSimultaneousRenderTargets*2 + 2] = RTInfo.ShadingRateTexture;
				DepthLoadAction = RTInfo.DepthStencilRenderTarget.DepthLoadAction;
				DepthStoreAction = RTInfo.DepthStencilRenderTarget.DepthStoreAction;
				StencilLoadAction = RTInfo.DepthStencilRenderTarget.StencilLoadAction;
				StencilStoreAction = RTInfo.DepthStencilRenderTarget.GetStencilStoreAction();
				DepthStencilAccess = RTInfo.DepthStencilRenderTarget.GetDepthStencilAccess();

				bClearDepth = RTInfo.bClearDepth;
				bClearStencil = RTInfo.bClearStencil;
				bClearColor = RTInfo.bClearColor;
				bHasResolveAttachments = RTInfo.bHasResolveAttachments;
				MultiViewCount = RTInfo.MultiViewCount;
			}
		};

		FHashableStruct RTHash;
		FMemory::Memzero(RTHash);
		RTHash.Set(*this);
		return FCrc::MemCrc32(&RTHash, sizeof(RTHash));
	}
};

class FRHICustomPresent : public FRHIResource
{
public:
	FRHICustomPresent() : FRHIResource(RRT_CustomPresent) {}
	
	virtual ~FRHICustomPresent() {} // should release any references to D3D resources.
	
	// Called when viewport is resized.
	virtual void OnBackBufferResize() = 0;

	// Called from render thread to see if a native present will be requested for this frame.
	// @return	true if native Present will be requested for this frame; false otherwise.  Must
	// match value subsequently returned by Present for this frame.
	virtual bool NeedsNativePresent() = 0;
	// In come cases we want to use custom present but still let the native environment handle 
	// advancement of the backbuffer indices.
	// @return true if backbuffer index should advance independently from CustomPresent.
	virtual bool NeedsAdvanceBackbuffer() { return false; };

	// Called from RHI thread when the engine begins drawing to the viewport.
	virtual void BeginDrawing() {};

	// Called from RHI thread to perform custom present.
	// @param InOutSyncInterval - in out param, indicates if vsync is on (>0) or off (==0).
	// @param RHICmdContext - the current rhi command context
	// @return	true if native Present should be also be performed; false otherwise. If it returns
	// true, then InOutSyncInterval could be modified to switch between VSync/NoVSync for the normal 
	// Present.  Must match value previously returned by NeedsNativePresent for this frame.
	virtual bool Present(IRHICommandContext& RHICmdContext, int32& InOutSyncInterval)
	{
	 	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	 	return Present(InOutSyncInterval); 
		PRAGMA_ENABLE_DEPRECATION_WARNINGS
	 };

	UE_DEPRECATED(5.5, "Please replace with Present(IRHICommandContext& RHICmdContext, int32& InOutSyncInterval).")
	virtual bool Present(int32& InOutSyncInterval) { check(false); return true; };

	// Called from RHI thread after native Present has been called
	virtual void PostPresent() {};

	// Called when rendering thread is acquired
	virtual void OnAcquireThreadOwnership() {}
	// Called when rendering thread is released
	virtual void OnReleaseThreadOwnership() {}
};


// Templates to convert an FRHI*Shader to its enum
template<typename TRHIShader> struct TRHIShaderToEnum {};
template<> struct TRHIShaderToEnum<FRHIVertexShader>           { enum { ShaderFrequency = SF_Vertex        }; };
template<> struct TRHIShaderToEnum<FRHIMeshShader>             { enum { ShaderFrequency = SF_Mesh          }; };
template<> struct TRHIShaderToEnum<FRHIAmplificationShader>    { enum { ShaderFrequency = SF_Amplification }; };
template<> struct TRHIShaderToEnum<FRHIPixelShader>            { enum { ShaderFrequency = SF_Pixel         }; };
template<> struct TRHIShaderToEnum<FRHIGeometryShader>         { enum { ShaderFrequency = SF_Geometry      }; };
template<> struct TRHIShaderToEnum<FRHIComputeShader>          { enum { ShaderFrequency = SF_Compute       }; };
template<> struct TRHIShaderToEnum<FRHIVertexShader*>          { enum { ShaderFrequency = SF_Vertex        }; };
template<> struct TRHIShaderToEnum<FRHIMeshShader*>            { enum { ShaderFrequency = SF_Mesh          }; };
template<> struct TRHIShaderToEnum<FRHIAmplificationShader*>   { enum { ShaderFrequency = SF_Amplification }; };
template<> struct TRHIShaderToEnum<FRHIPixelShader*>           { enum { ShaderFrequency = SF_Pixel         }; };
template<> struct TRHIShaderToEnum<FRHIGeometryShader*>        { enum { ShaderFrequency = SF_Geometry      }; };
template<> struct TRHIShaderToEnum<FRHIComputeShader*>         { enum { ShaderFrequency = SF_Compute       }; };
template<> struct TRHIShaderToEnum<FVertexShaderRHIRef>        { enum { ShaderFrequency = SF_Vertex        }; };
template<> struct TRHIShaderToEnum<FMeshShaderRHIRef>          { enum { ShaderFrequency = SF_Mesh          }; };
template<> struct TRHIShaderToEnum<FAmplificationShaderRHIRef> { enum { ShaderFrequency = SF_Amplification }; };
template<> struct TRHIShaderToEnum<FPixelShaderRHIRef>         { enum { ShaderFrequency = SF_Pixel         }; };
template<> struct TRHIShaderToEnum<FGeometryShaderRHIRef>      { enum { ShaderFrequency = SF_Geometry      }; };
template<> struct TRHIShaderToEnum<FComputeShaderRHIRef>       { enum { ShaderFrequency = SF_Compute       }; };

template<typename TRHIShaderType>
inline const TCHAR* GetShaderFrequencyString(bool bIncludePrefix = true)
{
	return GetShaderFrequencyString(static_cast<EShaderFrequency>(TRHIShaderToEnum<TRHIShaderType>::ShaderFrequency), bIncludePrefix);
}

struct FBoundShaderStateInput
{
	inline FBoundShaderStateInput() {}

	inline FBoundShaderStateInput
	(
		FRHIVertexDeclaration* InVertexDeclarationRHI
		, FRHIVertexShader* InVertexShaderRHI
		, FRHIPixelShader* InPixelShaderRHI
#if PLATFORM_SUPPORTS_GEOMETRY_SHADERS
		, FRHIGeometryShader* InGeometryShaderRHI
#endif
	)
		: VertexDeclarationRHI(InVertexDeclarationRHI)
		, VertexShaderRHI(InVertexShaderRHI)
		, PixelShaderRHI(InPixelShaderRHI)
#if PLATFORM_SUPPORTS_GEOMETRY_SHADERS
		, GeometryShaderRHI(InGeometryShaderRHI)
#endif
	{
	}

#if PLATFORM_SUPPORTS_MESH_SHADERS
	inline FBoundShaderStateInput(
		FRHIMeshShader* InMeshShaderRHI,
		FRHIAmplificationShader* InAmplificationShader,
		FRHIPixelShader* InPixelShaderRHI)
		: PixelShaderRHI(InPixelShaderRHI)
		, MeshShaderRHI(InMeshShaderRHI)
		, AmplificationShaderRHI(InAmplificationShader)
	{
	}
#endif

	void AddRefResources()
	{
		if (GetMeshShader())
		{
			check(VertexDeclarationRHI == nullptr);
			check(VertexShaderRHI == nullptr);
			GetMeshShader()->AddRef();

			if (GetAmplificationShader())
			{
				GetAmplificationShader()->AddRef();
			}
		}
		else
		{
			check(VertexDeclarationRHI);
			VertexDeclarationRHI->AddRef();

			check(VertexShaderRHI);
			VertexShaderRHI->AddRef();
		}

		if (PixelShaderRHI)
		{
			PixelShaderRHI->AddRef();
		}

		if (GetGeometryShader())
		{
			GetGeometryShader()->AddRef();
		}
	}

	void ReleaseResources()
	{
		if (GetMeshShader())
		{
			check(VertexDeclarationRHI == nullptr);
			check(VertexShaderRHI == nullptr);
			GetMeshShader()->Release();

			if (GetAmplificationShader())
			{
				GetAmplificationShader()->Release();
			}
		}
		else
		{
			check(VertexDeclarationRHI);
			VertexDeclarationRHI->Release();

			check(VertexShaderRHI);
			VertexShaderRHI->Release();
		}

		if (PixelShaderRHI)
		{
			PixelShaderRHI->Release();
		}

		if (GetGeometryShader())
		{
			GetGeometryShader()->Release();
		}
	}

	FRHIVertexShader* GetVertexShader() const { return VertexShaderRHI; }
	FRHIPixelShader* GetPixelShader() const { return PixelShaderRHI; }

#if PLATFORM_SUPPORTS_MESH_SHADERS
	FRHIMeshShader* GetMeshShader() const { return MeshShaderRHI; }
	void SetMeshShader(FRHIMeshShader* InMeshShader) { MeshShaderRHI = InMeshShader; }
	FRHIAmplificationShader* GetAmplificationShader() const { return AmplificationShaderRHI; }
	void SetAmplificationShader(FRHIAmplificationShader* InAmplificationShader) { AmplificationShaderRHI = InAmplificationShader; }
#else
	constexpr FRHIMeshShader* GetMeshShader() const { return nullptr; }
	void SetMeshShader(FRHIMeshShader*) {}
	constexpr FRHIAmplificationShader* GetAmplificationShader() const { return nullptr; }
	void SetAmplificationShader(FRHIAmplificationShader*) {}
#endif

#if PLATFORM_SUPPORTS_GEOMETRY_SHADERS
	FRHIGeometryShader* GetGeometryShader() const { return GeometryShaderRHI; }
	void SetGeometryShader(FRHIGeometryShader* InGeometryShader) { GeometryShaderRHI = InGeometryShader; }
#else
	constexpr FRHIGeometryShader* GetGeometryShader() const { return nullptr; }
	void SetGeometryShader(FRHIGeometryShader*) {}
#endif

	FRHIVertexDeclaration* VertexDeclarationRHI = nullptr;
	FRHIVertexShader* VertexShaderRHI = nullptr;
	FRHIPixelShader* PixelShaderRHI = nullptr;
private:
#if PLATFORM_SUPPORTS_MESH_SHADERS
	FRHIMeshShader* MeshShaderRHI = nullptr;
	FRHIAmplificationShader* AmplificationShaderRHI = nullptr;
#endif
#if PLATFORM_SUPPORTS_GEOMETRY_SHADERS
	FRHIGeometryShader* GeometryShaderRHI = nullptr;
#endif
};

// Hints for some RHIs that support subpasses
enum class ESubpassHint : uint8
{
	// Regular rendering
	None,

	// Render pass has depth reading subpass
	DepthReadSubpass,

	// Mobile defferred shading subpass
	DeferredShadingSubpass,

	// Mobile MSAA custom resolve subpass. Includes DepthReadSubpass.
	CustomResolveSubpass,
};

enum class EConservativeRasterization : uint8
{
	Disabled,
	Overestimated,
};

struct FGraphicsPipelineRenderTargetsInfo
{
	FGraphicsPipelineRenderTargetsInfo()
		: RenderTargetFormats(InPlace, UE_PIXELFORMAT_TO_UINT8(PF_Unknown))
		, RenderTargetFlags(InPlace, TexCreate_None)
		, DepthStencilAccess(FExclusiveDepthStencil::DepthNop_StencilNop)
	{
	}

	uint32															RenderTargetsEnabled = 0;
	TStaticArray<uint8, MaxSimultaneousRenderTargets>				RenderTargetFormats;
	TStaticArray<ETextureCreateFlags, MaxSimultaneousRenderTargets>	RenderTargetFlags;
	EPixelFormat													DepthStencilTargetFormat = PF_Unknown;
	ETextureCreateFlags												DepthStencilTargetFlag = ETextureCreateFlags::None;
	ERenderTargetLoadAction											DepthTargetLoadAction = ERenderTargetLoadAction::ENoAction;
	ERenderTargetStoreAction										DepthTargetStoreAction = ERenderTargetStoreAction::ENoAction;
	ERenderTargetLoadAction											StencilTargetLoadAction = ERenderTargetLoadAction::ENoAction;
	ERenderTargetStoreAction										StencilTargetStoreAction = ERenderTargetStoreAction::ENoAction;
	FExclusiveDepthStencil											DepthStencilAccess;
	uint16															NumSamples = 0;
	uint8															MultiViewCount = 0;
	bool															bHasFragmentDensityAttachment = false;
};


class FGraphicsPipelineStateInitializer
{
public:
	// Can't use TEnumByte<EPixelFormat> as it changes the struct to be non trivially constructible, breaking memset
	using TRenderTargetFormats		= TStaticArray<uint8/*EPixelFormat*/, MaxSimultaneousRenderTargets>;
	using TRenderTargetFlags		= TStaticArray<ETextureCreateFlags, MaxSimultaneousRenderTargets>;

	FGraphicsPipelineStateInitializer()
		: BlendState(nullptr)
		, RasterizerState(nullptr)
		, DepthStencilState(nullptr)
		, RenderTargetsEnabled(0)
		, RenderTargetFormats(InPlace, UE_PIXELFORMAT_TO_UINT8(PF_Unknown))
		, RenderTargetFlags(InPlace, TexCreate_None)
		, DepthStencilTargetFormat(PF_Unknown)
		, DepthStencilTargetFlag(TexCreate_None)
		, DepthTargetLoadAction(ERenderTargetLoadAction::ENoAction)
		, DepthTargetStoreAction(ERenderTargetStoreAction::ENoAction)
		, StencilTargetLoadAction(ERenderTargetLoadAction::ENoAction)
		, StencilTargetStoreAction(ERenderTargetStoreAction::ENoAction)
		, NumSamples(0)
		, SubpassHint(ESubpassHint::None)
		, SubpassIndex(0)
		, ConservativeRasterization(EConservativeRasterization::Disabled)
		, bDepthBounds(false)
		, MultiViewCount(0)
		, bHasFragmentDensityAttachment(false)
		, bAllowVariableRateShading(true)
		, ShadingRate(EVRSShadingRate::VRSSR_1x1)
		, Flags(0)
		, StatePrecachePSOHash(0)
	{
#if PLATFORM_WINDOWS
		static_assert(sizeof(TRenderTargetFormats::ElementType) == sizeof(uint8/*EPixelFormat*/), "Change TRenderTargetFormats's uint8 to EPixelFormat's size!");
#endif
		static_assert(PF_MAX < MAX_uint8, "TRenderTargetFormats assumes EPixelFormat can fit in a uint8!");
	}

	FGraphicsPipelineStateInitializer(
		FBoundShaderStateInput		InBoundShaderState,
		FRHIBlendState*				InBlendState,
		FRHIRasterizerState*		InRasterizerState,
		FRHIDepthStencilState*		InDepthStencilState,
		FImmutableSamplerState		InImmutableSamplerState,
		EPrimitiveType				InPrimitiveType,
		uint32						InRenderTargetsEnabled,
		const TRenderTargetFormats&	InRenderTargetFormats,
		const TRenderTargetFlags&	InRenderTargetFlags,
		EPixelFormat				InDepthStencilTargetFormat,
		ETextureCreateFlags			InDepthStencilTargetFlag,
		ERenderTargetLoadAction		InDepthTargetLoadAction,
		ERenderTargetStoreAction	InDepthTargetStoreAction,
		ERenderTargetLoadAction		InStencilTargetLoadAction,
		ERenderTargetStoreAction	InStencilTargetStoreAction,
		FExclusiveDepthStencil		InDepthStencilAccess,
		uint16						InNumSamples,
		ESubpassHint				InSubpassHint,
		uint8						InSubpassIndex,
		EConservativeRasterization	InConservativeRasterization,
		uint16						InFlags,
		bool						bInDepthBounds,
		uint8						InMultiViewCount,
		bool						bInHasFragmentDensityAttachment,
		bool						bInAllowVariableRateShading,
		EVRSShadingRate				InShadingRate)
		: BoundShaderState(InBoundShaderState)
		, BlendState(InBlendState)
		, RasterizerState(InRasterizerState)
		, DepthStencilState(InDepthStencilState)
		, ImmutableSamplerState(InImmutableSamplerState)
		, PrimitiveType(InPrimitiveType)
		, RenderTargetsEnabled(InRenderTargetsEnabled)
		, RenderTargetFormats(InRenderTargetFormats)
		, RenderTargetFlags(InRenderTargetFlags)
		, DepthStencilTargetFormat(InDepthStencilTargetFormat)
		, DepthStencilTargetFlag(InDepthStencilTargetFlag)
		, DepthTargetLoadAction(InDepthTargetLoadAction)
		, DepthTargetStoreAction(InDepthTargetStoreAction)
		, StencilTargetLoadAction(InStencilTargetLoadAction)
		, StencilTargetStoreAction(InStencilTargetStoreAction)
		, DepthStencilAccess(InDepthStencilAccess)
		, NumSamples(InNumSamples)
		, SubpassHint(InSubpassHint)
		, SubpassIndex(InSubpassIndex)
		, ConservativeRasterization(EConservativeRasterization::Disabled)
		, bDepthBounds(bInDepthBounds)
		, MultiViewCount(InMultiViewCount)
		, bHasFragmentDensityAttachment(bInHasFragmentDensityAttachment)
		, bAllowVariableRateShading(bInAllowVariableRateShading)
		, ShadingRate(InShadingRate)
		, Flags(InFlags)
		, StatePrecachePSOHash(0)
	{
	}

	bool operator==(const FGraphicsPipelineStateInitializer& rhs) const
	{
		if (BoundShaderState.VertexDeclarationRHI != rhs.BoundShaderState.VertexDeclarationRHI ||
			BoundShaderState.VertexShaderRHI != rhs.BoundShaderState.VertexShaderRHI ||
			BoundShaderState.PixelShaderRHI != rhs.BoundShaderState.PixelShaderRHI ||
			BoundShaderState.GetMeshShader() != rhs.BoundShaderState.GetMeshShader() ||
			BoundShaderState.GetAmplificationShader() != rhs.BoundShaderState.GetAmplificationShader() ||
			BoundShaderState.GetGeometryShader() != rhs.BoundShaderState.GetGeometryShader() ||
			BlendState != rhs.BlendState ||
			RasterizerState != rhs.RasterizerState ||
			DepthStencilState != rhs.DepthStencilState ||
			ImmutableSamplerState != rhs.ImmutableSamplerState ||
			PrimitiveType != rhs.PrimitiveType ||
			bDepthBounds != rhs.bDepthBounds ||
			MultiViewCount != rhs.MultiViewCount ||
			ShadingRate != rhs.ShadingRate ||
			bAllowVariableRateShading != rhs.bAllowVariableRateShading ||
			bHasFragmentDensityAttachment != rhs.bHasFragmentDensityAttachment ||
			RenderTargetsEnabled != rhs.RenderTargetsEnabled ||
			RenderTargetFormats != rhs.RenderTargetFormats || 
			!RelevantRenderTargetFlagsEqual(RenderTargetFlags, rhs.RenderTargetFlags) || 
			DepthStencilTargetFormat != rhs.DepthStencilTargetFormat || 
			!RelevantDepthStencilFlagsEqual(DepthStencilTargetFlag, rhs.DepthStencilTargetFlag) ||
			DepthTargetLoadAction != rhs.DepthTargetLoadAction ||
			DepthTargetStoreAction != rhs.DepthTargetStoreAction ||
			StencilTargetLoadAction != rhs.StencilTargetLoadAction ||
			StencilTargetStoreAction != rhs.StencilTargetStoreAction || 
			DepthStencilAccess != rhs.DepthStencilAccess ||
			NumSamples != rhs.NumSamples ||
			SubpassHint != rhs.SubpassHint ||
			SubpassIndex != rhs.SubpassIndex ||
			ConservativeRasterization != rhs.ConservativeRasterization)
		{
			return false;
		}

		return true;
	}

	// We care about flags that influence RT formats (which is the only thing the underlying API cares about).
	// In most RHIs, the format is only influenced by TexCreate_SRGB. D3D12 additionally uses TexCreate_Shared in its format selection logic.
	static constexpr ETextureCreateFlags RelevantRenderTargetFlagMask = ETextureCreateFlags::SRGB | ETextureCreateFlags::Shared;

	// We care about flags that influence DS formats (which is the only thing the underlying API cares about).
	// D3D12 shares the format choice function with the RT, so preserving all the flags used there out of abundance of caution.
	static constexpr ETextureCreateFlags RelevantDepthStencilFlagMask = ETextureCreateFlags::SRGB | ETextureCreateFlags::Shared | ETextureCreateFlags::DepthStencilTargetable;

	static bool RelevantRenderTargetFlagsEqual(const TRenderTargetFlags& A, const TRenderTargetFlags& B)
	{
		for (int32 Index = 0; Index < A.Num(); ++Index)
		{
			ETextureCreateFlags FlagsA = A[Index] & RelevantRenderTargetFlagMask;
			ETextureCreateFlags FlagsB = B[Index] & RelevantRenderTargetFlagMask;
			if (FlagsA != FlagsB)
			{
				return false;
			}
		}
		return true;
	}

	static bool RelevantDepthStencilFlagsEqual(const ETextureCreateFlags A, const ETextureCreateFlags B)
	{
		ETextureCreateFlags FlagsA = (A & RelevantDepthStencilFlagMask);
		ETextureCreateFlags FlagsB = (B & RelevantDepthStencilFlagMask);
		return (FlagsA == FlagsB);
	}

	uint32 ComputeNumValidRenderTargets() const
	{
		// Get the count of valid render targets (ignore those at the end of the array with PF_Unknown)
		if (RenderTargetsEnabled > 0)
		{
			int32 LastValidTarget = -1;
			for (int32 i = (int32)RenderTargetsEnabled - 1; i >= 0; i--)
			{
				if (RenderTargetFormats[i] != PF_Unknown)
				{
					LastValidTarget = i;
					break;
				}
			}
			return uint32(LastValidTarget + 1);
		}
		return RenderTargetsEnabled;
	}

	FBoundShaderStateInput			BoundShaderState;
	FRHIBlendState*					BlendState;
	FRHIRasterizerState*			RasterizerState;
	FRHIDepthStencilState*			DepthStencilState;
	FImmutableSamplerState			ImmutableSamplerState;

	EPrimitiveType					PrimitiveType;
	uint32							RenderTargetsEnabled;
	TRenderTargetFormats			RenderTargetFormats;
	TRenderTargetFlags				RenderTargetFlags;
	EPixelFormat					DepthStencilTargetFormat;
	ETextureCreateFlags				DepthStencilTargetFlag;
	ERenderTargetLoadAction			DepthTargetLoadAction;
	ERenderTargetStoreAction		DepthTargetStoreAction;
	ERenderTargetLoadAction			StencilTargetLoadAction;
	ERenderTargetStoreAction		StencilTargetStoreAction;
	FExclusiveDepthStencil			DepthStencilAccess;
	uint16							NumSamples;
	ESubpassHint					SubpassHint;
	uint8							SubpassIndex;
	EConservativeRasterization		ConservativeRasterization;
	bool							bDepthBounds;
	uint8							MultiViewCount;
	bool							bHasFragmentDensityAttachment;
	bool							bAllowVariableRateShading;
	EVRSShadingRate					ShadingRate;
	
	// Note: these flags do NOT affect compilation of this PSO.
	// The resulting object is invariant with respect to whatever is set here, they are
	// behavior hints.
	// They do not participate in equality comparisons or hashing.
	union
	{
		struct
		{
			uint16					Reserved			: 11;
			uint16					bPSOPrecache		: 1;
			uint16					bFromPSOFileCache	: 1;
			uint16					PrecacheCompileType : 3;
		};
		uint16						Flags;
	};

	enum class EPSOPrecacheCompileType : uint8
	{
		NotSet = 0,
		MinPri = 1,
		NormalPri = 2,
		MaxPri = 3,

		NumTypes = 4,
	};
	static_assert((int)EPSOPrecacheCompileType::MaxPri < (1<<3) ); // ensure MaxPri fits within PrecacheCompileType
	void SetPSOPrecacheCompileType(EPSOPrecacheCompileType PrecacheCompileTypeIN) 
	{ 
		check(PrecacheCompileTypeIN <= EPSOPrecacheCompileType::MaxPri && PrecacheCompileTypeIN >= EPSOPrecacheCompileType::MinPri);
		PrecacheCompileType = (uint16)PrecacheCompileTypeIN;
	}
	EPSOPrecacheCompileType GetPSOPrecacheCompileType() const {	return (EPSOPrecacheCompileType)PrecacheCompileType; }

	// Cached hash off all state data provided at creation time (Only contains hash of data which influences the PSO precaching for the current platform)
	// Created from hashing the state data instead of the pointers which are used during fast runtime cache checking and compares
	uint64							StatePrecachePSOHash;
};

/** Helper for fast compute of hash for a shader table. */
template<typename TShaderType>
inline uint64 ComputeShaderTableHash(const TArrayView<TShaderType*>& ShaderTable, uint64 InitialHash = 5699878132332235837ull)
{
	uint64 CombinedHash = InitialHash;
	for (FRHIShader* ShaderRHI : ShaderTable)
	{
		uint64 ShaderHash = 0;
		if (ShaderRHI)
		{
			// 64 bits from the shader SHA1
			FMemory::Memcpy(&ShaderHash, ShaderRHI->GetHash().Hash, sizeof(ShaderHash));
		}

		// 64 bit hash combination as per boost::hash_combine_impl
		CombinedHash ^= ShaderHash + 0x9e3779b9 + (CombinedHash << 6) + (CombinedHash >> 2);
	}

	return CombinedHash;
}

class FWorkGraphPipelineStateSignature
{
public:
	bool operator==(const FWorkGraphPipelineStateSignature& Rhs) const
	{
		return BaseHash == Rhs.BaseHash && NameHash == Rhs.NameHash && ShaderBundleNodeHash == Rhs.ShaderBundleNodeHash;
	}

	friend uint32 GetTypeHash(const FWorkGraphPipelineStateSignature& Initializer)
	{
		return GetTypeHash(Initializer.BaseHash) ^ GetTypeHash(Initializer.NameHash) ^ GetTypeHash(Initializer.ShaderBundleNodeHash);
	}

protected:
	uint64 BaseHash = 0;
	uint64 NameHash = 0;
	uint64 ShaderBundleNodeHash = 0;
};

class FWorkGraphPipelineStateInitializer : public FWorkGraphPipelineStateSignature
{
public:
	FWorkGraphPipelineStateInitializer() = default;
	FWorkGraphPipelineStateRHIRef BasePipeline;

	void SetProgramName(TCHAR const* InProgramName)
	{
		ProgramName = InProgramName;
		NameHash = ComputeNameHash();
	}

	FString const& GetProgramName() const { return ProgramName; }

	void SetShader(FRHIWorkGraphShader* InShader)
	{
		BaseShader = InShader;
		FMemory::Memcpy(&BaseHash, InShader->GetHash().Hash, sizeof(BaseHash));	// 64 bits from the shader SHA1
	}

	FRHIWorkGraphShader* GetShader() const { return BaseShader; }

	void SetShaderBundleNodeTable(const TArrayView<FRHIWorkGraphShader*>& InShaders, TCHAR const* InNodeName, uint64 Hash = 0)
	{
		ShaderBundleNodeTable = InShaders;
		ShaderBundleNodeHash = Hash ? Hash : ComputeShaderTableHash(InShaders);

		ShaderBundleNodeName = InNodeName;
		NameHash = ComputeNameHash();
	}

	const TArrayView<FRHIWorkGraphShader*>& GetShaderBundleNodeTable() const { return ShaderBundleNodeTable; }
	const FString& GetShaderBundleNodeName() const { return ShaderBundleNodeName; }

private:
	uint64 ComputeNameHash() const
	{
		return HashCombineFast(GetTypeHash(ProgramName), GetTypeHash(ShaderBundleNodeName));
	}

	FRHIWorkGraphShader* BaseShader = nullptr;
	FString ProgramName;
	TArrayView<FRHIWorkGraphShader*> ShaderBundleNodeTable;
	FString ShaderBundleNodeName;
};

class FRayTracingPipelineStateSignature
{
public:

	uint32 MaxAttributeSizeInBytes = 8; // sizeof FRayTracingIntersectionAttributes declared in RayTracingCommon.ush
	uint32 MaxPayloadSizeInBytes = 24; // sizeof FDefaultPayload declared in RayTracingCommon.ush

	UE_DEPRECATED(5.5, "Set bAllowHitGroupIndexing in FRayTracingShaderBindingTableInitializer.")
	bool bAllowHitGroupIndexing = true;

	// NOTE: GetTypeHash(const FRayTracingPipelineStateInitializer& Initializer) should also be updated when changing this function
	bool operator==(const FRayTracingPipelineStateSignature& rhs) const
	{
		return MaxAttributeSizeInBytes == rhs.MaxAttributeSizeInBytes
			&& MaxPayloadSizeInBytes == rhs.MaxPayloadSizeInBytes
			&& RayGenHash == rhs.RayGenHash
			&& MissHash == rhs.MissHash
			&& HitGroupHash == rhs.HitGroupHash
			&& CallableHash == rhs.CallableHash
		PRAGMA_DISABLE_DEPRECATION_WARNINGS
			&& bAllowHitGroupIndexing == rhs.bAllowHitGroupIndexing;
		PRAGMA_ENABLE_DEPRECATION_WARNINGS
	}

	friend uint32 GetTypeHash(const FRayTracingPipelineStateSignature& Initializer)
	{
		return GetTypeHash(Initializer.MaxAttributeSizeInBytes) ^
			GetTypeHash(Initializer.MaxPayloadSizeInBytes) ^
			GetTypeHash(Initializer.GetRayGenHash()) ^
			GetTypeHash(Initializer.GetRayMissHash()) ^
			GetTypeHash(Initializer.GetHitGroupHash()) ^
			GetTypeHash(Initializer.GetCallableHash()) ^
		PRAGMA_DISABLE_DEPRECATION_WARNINGS
			GetTypeHash(Initializer.bAllowHitGroupIndexing);
		PRAGMA_ENABLE_DEPRECATION_WARNINGS
	}

	uint64 GetHitGroupHash() const { return HitGroupHash; }
	uint64 GetRayGenHash()   const { return RayGenHash; }
	uint64 GetRayMissHash()  const { return MissHash; }
	uint64 GetCallableHash() const { return CallableHash; }

	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	FRayTracingPipelineStateSignature() = default;
	FRayTracingPipelineStateSignature(const FRayTracingPipelineStateSignature&) = default;
	FRayTracingPipelineStateSignature& operator=(const FRayTracingPipelineStateSignature&) = default;
	FRayTracingPipelineStateSignature(FRayTracingPipelineStateSignature&&) = default;
	FRayTracingPipelineStateSignature& operator=(FRayTracingPipelineStateSignature&&) = default;
	~FRayTracingPipelineStateSignature() = default;
	PRAGMA_ENABLE_DEPRECATION_WARNINGS

protected:

	uint64 RayGenHash = 0;
	uint64 MissHash = 0;
	uint64 HitGroupHash = 0;
	uint64 CallableHash = 0;
};

class FRayTracingPipelineStateInitializer : public FRayTracingPipelineStateSignature
{
public:

	FRayTracingPipelineStateInitializer() = default;

	// Partial ray tracing pipelines can be used for run-time asynchronous shader compilation, but not for rendering.
	// Any number of shaders for any stage may be provided when creating partial pipelines, but 
	// at least one shader must be present in total (completely empty pipelines are not allowed).
	bool bPartial = false;

	// Hints to the RHI that this PSO is being compiled by a background task and will not be needed immediately for rendering.
	// Speculative PSO pre-caching or non-blocking PSO creation should set this flag.
	// This may be used by the RHI to decide if a hitch warning should be reported, change priority of any internally dispatched tasks, etc.
	// Does not affect the creation of the PSO itself.
	bool bBackgroundCompilation = false;

	// Ray tracing pipeline may be created by deriving from the existing base.
	// Base pipeline will be extended by adding new shaders into it, potentially saving substantial amount of CPU time.
	// Depends on GRHISupportsRayTracingPSOAdditions support at runtime (base pipeline is simply ignored if it is unsupported).
	FRayTracingPipelineStateRHIRef BasePipeline;

	// Shader binding table layout used during shader compilation which needs to be the same for all shaders in the RTPSO and defines
	// how uniform buffers needs to be bound at runtime (global(RayGen) vs local(miss/hit/callable) data)
	const FRHIShaderBindingLayout* ShaderBindingLayout = nullptr;

	const TArrayView<FRHIRayTracingShader*>& GetRayGenTable()   const { return RayGenTable; }
	const TArrayView<FRHIRayTracingShader*>& GetMissTable()     const { return MissTable; }
	const TArrayView<FRHIRayTracingShader*>& GetHitGroupTable() const { return HitGroupTable; }
	const TArrayView<FRHIRayTracingShader*>& GetCallableTable() const { return CallableTable; }

	// Shaders used as entry point to ray tracing work. At least one RayGen shader must be provided.
	void SetRayGenShaderTable(const TArrayView<FRHIRayTracingShader*>& InRayGenShaders, uint64 Hash = 0)
	{
		RayGenTable = InRayGenShaders;
		RayGenHash = Hash ? Hash : ComputeShaderTableHash(InRayGenShaders);
	}

	// Shaders that will be invoked if a ray misses all geometry.
	// If this table is empty, then a built-in default miss shader will be used that sets HitT member of FMinimalPayload to -1.
	// Desired miss shader can be selected by providing MissShaderIndex to TraceRay() function.
	void SetMissShaderTable(const TArrayView<FRHIRayTracingShader*>& InMissShaders, uint64 Hash = 0)
	{
		MissTable = InMissShaders;
		MissHash = Hash ? Hash : ComputeShaderTableHash(InMissShaders);
	}

	// Shaders that will be invoked when ray intersects geometry.
	// If this table is empty, then a built-in default shader will be used for all geometry, using FDefaultPayload.
	void SetHitGroupTable(const TArrayView<FRHIRayTracingShader*>& InHitGroups, uint64 Hash = 0)
	{
		HitGroupTable = InHitGroups;
		HitGroupHash = Hash ? Hash : ComputeShaderTableHash(HitGroupTable);
	}

	// Shaders that can be explicitly invoked from RayGen shaders by their Shader Binding Table (SBT) index.
	// SetRayTracingCallableShader() command must be used to fill SBT slots before a shader can be called.
	void SetCallableTable(const TArrayView<FRHIRayTracingShader*>& InCallableShaders, uint64 Hash = 0)
	{
		CallableTable = InCallableShaders;
		CallableHash = Hash ? Hash : ComputeShaderTableHash(CallableTable);
	}

	// Retrieve the max local binding size of all the raytracing shaders used in the RTPSO
	RHI_API uint32 GetMaxLocalBindingDataSize() const;

private:
	TArrayView<FRHIRayTracingShader*> RayGenTable;
	TArrayView<FRHIRayTracingShader*> MissTable;
	TArrayView<FRHIRayTracingShader*> HitGroupTable;
	TArrayView<FRHIRayTracingShader*> CallableTable;
};

// This PSO is used as a fallback for RHIs that dont support PSOs. It is used to set the graphics state using the legacy state setting APIs
class FRHIGraphicsPipelineStateFallBack : public FRHIGraphicsPipelineState
{
public:
	FRHIGraphicsPipelineStateFallBack() {}

	FRHIGraphicsPipelineStateFallBack(const FGraphicsPipelineStateInitializer& Init)
		: Initializer(Init)
	{
	}

	FRHIGraphicsShader* GetShader(EShaderFrequency Frequency) const override
	{
		switch (Frequency)
		{
		case SF_Vertex: return Initializer.BoundShaderState.GetVertexShader();
		case SF_Mesh: return Initializer.BoundShaderState.GetMeshShader();
		case SF_Amplification: return Initializer.BoundShaderState.GetAmplificationShader();
		case SF_Pixel: return Initializer.BoundShaderState.GetPixelShader();
		case SF_Geometry: return Initializer.BoundShaderState.GetGeometryShader();
		default: return nullptr;
		}
	}

	FGraphicsPipelineStateInitializer Initializer;
};

class FRHIComputePipelineStateFallback : public FRHIComputePipelineState
{
public:
	FRHIComputePipelineStateFallback(FRHIComputeShader* InComputeShader) : FRHIComputePipelineState(InComputeShader)
	{
	}
};

enum class ERenderTargetActions : uint8
{
	LoadOpMask = 2,

#define RTACTION_MAKE_MASK(Load, Store) (((uint8)ERenderTargetLoadAction::Load << (uint8)LoadOpMask) | (uint8)ERenderTargetStoreAction::Store)

	DontLoad_DontStore =	RTACTION_MAKE_MASK(ENoAction, ENoAction),

	DontLoad_Store =		RTACTION_MAKE_MASK(ENoAction, EStore),
	Clear_Store =			RTACTION_MAKE_MASK(EClear, EStore),
	Load_Store =			RTACTION_MAKE_MASK(ELoad, EStore),

	Clear_DontStore =		RTACTION_MAKE_MASK(EClear, ENoAction),
	Load_DontStore =		RTACTION_MAKE_MASK(ELoad, ENoAction),
	Clear_Resolve =			RTACTION_MAKE_MASK(EClear, EMultisampleResolve),
	Load_Resolve =			RTACTION_MAKE_MASK(ELoad, EMultisampleResolve),

#undef RTACTION_MAKE_MASK
};

inline ERenderTargetActions MakeRenderTargetActions(ERenderTargetLoadAction Load, ERenderTargetStoreAction Store)
{
	return (ERenderTargetActions)(((uint8)Load << (uint8)ERenderTargetActions::LoadOpMask) | (uint8)Store);
}

inline ERenderTargetLoadAction GetLoadAction(ERenderTargetActions Action)
{
	return (ERenderTargetLoadAction)((uint8)Action >> (uint8)ERenderTargetActions::LoadOpMask);
}

inline ERenderTargetStoreAction GetStoreAction(ERenderTargetActions Action)
{
	return (ERenderTargetStoreAction)((uint8)Action & ((1 << (uint8)ERenderTargetActions::LoadOpMask) - 1));
}

enum class EDepthStencilTargetActions : uint8
{
	DepthMask = 4,

#define RTACTION_MAKE_MASK(Depth, Stencil) (((uint8)ERenderTargetActions::Depth << (uint8)DepthMask) | (uint8)ERenderTargetActions::Stencil)

	DontLoad_DontStore =						RTACTION_MAKE_MASK(DontLoad_DontStore, DontLoad_DontStore),
	DontLoad_StoreDepthStencil =				RTACTION_MAKE_MASK(DontLoad_Store, DontLoad_Store),
	DontLoad_StoreStencilNotDepth =				RTACTION_MAKE_MASK(DontLoad_DontStore, DontLoad_Store),
	ClearDepthStencil_StoreDepthStencil =		RTACTION_MAKE_MASK(Clear_Store, Clear_Store),
	LoadDepthStencil_StoreDepthStencil =		RTACTION_MAKE_MASK(Load_Store, Load_Store),
	LoadDepthNotStencil_StoreDepthNotStencil =	RTACTION_MAKE_MASK(Load_Store, DontLoad_DontStore),
	LoadDepthNotStencil_DontStore =				RTACTION_MAKE_MASK(Load_DontStore, DontLoad_DontStore),
	LoadDepthStencil_StoreStencilNotDepth =		RTACTION_MAKE_MASK(Load_DontStore, Load_Store),

	ClearDepthStencil_DontStoreDepthStencil =	RTACTION_MAKE_MASK(Clear_DontStore, Clear_DontStore),
	LoadDepthStencil_DontStoreDepthStencil =	RTACTION_MAKE_MASK(Load_DontStore, Load_DontStore),
	ClearDepthStencil_StoreDepthNotStencil =	RTACTION_MAKE_MASK(Clear_Store, Clear_DontStore),
	ClearDepthStencil_StoreStencilNotDepth =	RTACTION_MAKE_MASK(Clear_DontStore, Clear_Store),
	ClearDepthStencil_ResolveDepthNotStencil =	RTACTION_MAKE_MASK(Clear_Resolve, Clear_DontStore),
	ClearDepthStencil_ResolveStencilNotDepth =	RTACTION_MAKE_MASK(Clear_DontStore, Clear_Resolve),
	LoadDepthClearStencil_StoreDepthStencil  =  RTACTION_MAKE_MASK(Load_Store, Clear_Store),

	ClearStencilDontLoadDepth_StoreStencilNotDepth = RTACTION_MAKE_MASK(DontLoad_DontStore, Clear_Store),

#undef RTACTION_MAKE_MASK
};

inline constexpr EDepthStencilTargetActions MakeDepthStencilTargetActions(const ERenderTargetActions Depth, const ERenderTargetActions Stencil)
{
	return (EDepthStencilTargetActions)(((uint8)Depth << (uint8)EDepthStencilTargetActions::DepthMask) | (uint8)Stencil);
}

inline ERenderTargetActions GetDepthActions(EDepthStencilTargetActions Action)
{
	return (ERenderTargetActions)((uint8)Action >> (uint8)EDepthStencilTargetActions::DepthMask);
}

inline ERenderTargetActions GetStencilActions(EDepthStencilTargetActions Action)
{
	return (ERenderTargetActions)((uint8)Action & ((1 << (uint8)EDepthStencilTargetActions::DepthMask) - 1));
}

struct FResolveRect
{
	int32 X1;
	int32 Y1;
	int32 X2;
	int32 Y2;

	// e.g. for a a full 256 x 256 area starting at (0, 0) it would be 
	// the values would be 0, 0, 256, 256
	FResolveRect(int32 InX1 = -1, int32 InY1 = -1, int32 InX2 = -1, int32 InY2 = -1)
		: X1(InX1)
		, Y1(InY1)
		, X2(InX2)
		, Y2(InY2)
	{}

	explicit FResolveRect(FIntRect Other)
		: X1(Other.Min.X)
		, Y1(Other.Min.Y)
		, X2(Other.Max.X)
		, Y2(Other.Max.Y)
	{}

	bool operator==(FResolveRect Other) const
	{
		return X1 == Other.X1 && Y1 == Other.Y1 && X2 == Other.X2 && Y2 == Other.Y2;
	}

	bool operator!=(FResolveRect Other) const
	{
		return !(*this == Other);
	}

	bool IsValid() const
	{
		return X1 >= 0 && Y1 >= 0 && X2 - X1 > 0 && Y2 - Y1 > 0;
	}
};

struct FRHIRenderPassInfo
{
	struct FColorEntry
	{
		FRHITexture*         RenderTarget      = nullptr;
		FRHITexture*         ResolveTarget     = nullptr;
		int32                ArraySlice        = -1;
		uint8                MipIndex          = 0;
		ERenderTargetActions Action            = ERenderTargetActions::DontLoad_DontStore;
	};
	TStaticArray<FColorEntry, MaxSimultaneousRenderTargets> ColorRenderTargets;

	struct FDepthStencilEntry
	{
		FRHITexture*         DepthStencilTarget = nullptr;
		FRHITexture*         ResolveTarget      = nullptr;
		EDepthStencilTargetActions Action       = EDepthStencilTargetActions::DontLoad_DontStore;
		FExclusiveDepthStencil ExclusiveDepthStencil;
	};
	FDepthStencilEntry DepthStencilRenderTarget;

	// Controls the area for a multisample resolve or raster UAV (i.e. no fixed-function targets) operation.
	FResolveRect ResolveRect;

	// Some RHIs can use a texture to control the sampling and/or shading resolution of different areas 
	FTextureRHIRef ShadingRateTexture = nullptr;
	EVRSRateCombiner ShadingRateTextureCombiner = VRSRB_Passthrough;

	// Some RHIs require a hint that occlusion queries will be used in this render pass
	uint32 NumOcclusionQueries = 0;
	bool bOcclusionQueries = false;

	// if this renderpass should be multiview, and if so how many views are required
	uint8 MultiViewCount = 0;

	// Hint for some RHI's that renderpass will have specific sub-passes 
	ESubpassHint SubpassHint = ESubpassHint::None;

	FRHIRenderPassInfo() = default;
	FRHIRenderPassInfo(const FRHIRenderPassInfo&) = default;
	FRHIRenderPassInfo& operator=(const FRHIRenderPassInfo&) = default;

	// Color, no depth, optional resolve, optional mip, optional array slice
	explicit FRHIRenderPassInfo(FRHITexture* ColorRT, ERenderTargetActions ColorAction, FRHITexture* ResolveRT = nullptr, uint8 InMipIndex = 0, int32 InArraySlice = -1)
	{
		check(!(ResolveRT && ResolveRT->IsMultisampled()));
		check(ColorRT);
		ColorRenderTargets[0].RenderTarget = ColorRT;
		ColorRenderTargets[0].ResolveTarget = ResolveRT;
		ColorRenderTargets[0].ArraySlice = InArraySlice;
		ColorRenderTargets[0].MipIndex = InMipIndex;
		ColorRenderTargets[0].Action = ColorAction;
	}

	// Color MRTs, no depth
	explicit FRHIRenderPassInfo(int32 NumColorRTs, FRHITexture* ColorRTs[], ERenderTargetActions ColorAction)
	{
		check(NumColorRTs > 0);
		for (int32 Index = 0; Index < NumColorRTs; ++Index)
		{
			check(ColorRTs[Index]);
			ColorRenderTargets[Index].RenderTarget = ColorRTs[Index];
			ColorRenderTargets[Index].ArraySlice = -1;
			ColorRenderTargets[Index].Action = ColorAction;
		}
		DepthStencilRenderTarget.DepthStencilTarget = nullptr;
		DepthStencilRenderTarget.Action = EDepthStencilTargetActions::DontLoad_DontStore;
		DepthStencilRenderTarget.ExclusiveDepthStencil = FExclusiveDepthStencil::DepthNop_StencilNop;
		DepthStencilRenderTarget.ResolveTarget = nullptr;
	}

	// Color MRTs, no depth
	explicit FRHIRenderPassInfo(int32 NumColorRTs, FRHITexture* ColorRTs[], ERenderTargetActions ColorAction, FRHITexture* ResolveTargets[])
	{
		check(NumColorRTs > 0);
		for (int32 Index = 0; Index < NumColorRTs; ++Index)
		{
			check(ColorRTs[Index]);
			ColorRenderTargets[Index].RenderTarget = ColorRTs[Index];
			ColorRenderTargets[Index].ResolveTarget = ResolveTargets[Index];
			ColorRenderTargets[Index].ArraySlice = -1;
			ColorRenderTargets[Index].MipIndex = 0;
			ColorRenderTargets[Index].Action = ColorAction;
		}
		DepthStencilRenderTarget.DepthStencilTarget = nullptr;
		DepthStencilRenderTarget.Action = EDepthStencilTargetActions::DontLoad_DontStore;
		DepthStencilRenderTarget.ExclusiveDepthStencil = FExclusiveDepthStencil::DepthNop_StencilNop;
		DepthStencilRenderTarget.ResolveTarget = nullptr;
	}

	// Color MRTs and depth
	explicit FRHIRenderPassInfo(int32 NumColorRTs, FRHITexture* ColorRTs[], ERenderTargetActions ColorAction, FRHITexture* DepthRT, EDepthStencilTargetActions DepthActions, FExclusiveDepthStencil InEDS = FExclusiveDepthStencil::DepthWrite_StencilWrite)
	{
		check(NumColorRTs > 0);
		for (int32 Index = 0; Index < NumColorRTs; ++Index)
		{
			check(ColorRTs[Index]);
			ColorRenderTargets[Index].RenderTarget = ColorRTs[Index];
			ColorRenderTargets[Index].ResolveTarget = nullptr;
			ColorRenderTargets[Index].ArraySlice = -1;
			ColorRenderTargets[Index].MipIndex = 0;
			ColorRenderTargets[Index].Action = ColorAction;
		}
		check(DepthRT);
		DepthStencilRenderTarget.DepthStencilTarget = DepthRT;
		DepthStencilRenderTarget.ResolveTarget = nullptr;
		DepthStencilRenderTarget.Action = DepthActions;
		DepthStencilRenderTarget.ExclusiveDepthStencil = InEDS;
	}

	// Color MRTs and depth
	explicit FRHIRenderPassInfo(int32 NumColorRTs, FRHITexture* ColorRTs[], ERenderTargetActions ColorAction, FRHITexture* ResolveRTs[], FRHITexture* DepthRT, EDepthStencilTargetActions DepthActions, FRHITexture* ResolveDepthRT, FExclusiveDepthStencil InEDS = FExclusiveDepthStencil::DepthWrite_StencilWrite)
	{
		check(NumColorRTs > 0);
		for (int32 Index = 0; Index < NumColorRTs; ++Index)
		{
			check(!ResolveRTs[Index] || ResolveRTs[Index]->IsMultisampled());
			check(ColorRTs[Index]);
			ColorRenderTargets[Index].RenderTarget = ColorRTs[Index];
			ColorRenderTargets[Index].ResolveTarget = ResolveRTs[Index];
			ColorRenderTargets[Index].ArraySlice = -1;
			ColorRenderTargets[Index].MipIndex = 0;
			ColorRenderTargets[Index].Action = ColorAction;
		}
		check(!ResolveDepthRT || ResolveDepthRT->IsMultisampled());
		check(DepthRT);
		DepthStencilRenderTarget.DepthStencilTarget = DepthRT;
		DepthStencilRenderTarget.ResolveTarget = ResolveDepthRT;
		DepthStencilRenderTarget.Action = DepthActions;
		DepthStencilRenderTarget.ExclusiveDepthStencil = InEDS;
	}

	// Depth, no color
	explicit FRHIRenderPassInfo(FRHITexture* DepthRT, EDepthStencilTargetActions DepthActions, FRHITexture* ResolveDepthRT = nullptr, FExclusiveDepthStencil InEDS = FExclusiveDepthStencil::DepthWrite_StencilWrite)
	{
		check(!ResolveDepthRT || ResolveDepthRT->IsMultisampled());
		check(DepthRT);
		DepthStencilRenderTarget.DepthStencilTarget = DepthRT;
		DepthStencilRenderTarget.ResolveTarget = ResolveDepthRT;
		DepthStencilRenderTarget.Action = DepthActions;
		DepthStencilRenderTarget.ExclusiveDepthStencil = InEDS;
	}

	// Depth, no color, occlusion queries
	explicit FRHIRenderPassInfo(FRHITexture* DepthRT, uint32 InNumOcclusionQueries, EDepthStencilTargetActions DepthActions, FRHITexture* ResolveDepthRT = nullptr, FExclusiveDepthStencil InEDS = FExclusiveDepthStencil::DepthWrite_StencilWrite)
		: NumOcclusionQueries(InNumOcclusionQueries)
	{
		check(!ResolveDepthRT || ResolveDepthRT->IsMultisampled());
		check(DepthRT);
		DepthStencilRenderTarget.DepthStencilTarget = DepthRT;
		DepthStencilRenderTarget.ResolveTarget = ResolveDepthRT;
		DepthStencilRenderTarget.Action = DepthActions;
		DepthStencilRenderTarget.ExclusiveDepthStencil = InEDS;
	}

	// Color and depth
	explicit FRHIRenderPassInfo(FRHITexture* ColorRT, ERenderTargetActions ColorAction, FRHITexture* DepthRT, EDepthStencilTargetActions DepthActions, FExclusiveDepthStencil InEDS = FExclusiveDepthStencil::DepthWrite_StencilWrite)
	{
		check(ColorRT);
		ColorRenderTargets[0].RenderTarget = ColorRT;
		ColorRenderTargets[0].ResolveTarget = nullptr;
		ColorRenderTargets[0].ArraySlice = -1;
		ColorRenderTargets[0].MipIndex = 0;
		ColorRenderTargets[0].Action = ColorAction;
		check(DepthRT);
		DepthStencilRenderTarget.DepthStencilTarget = DepthRT;
		DepthStencilRenderTarget.ResolveTarget = nullptr;
		DepthStencilRenderTarget.Action = DepthActions;
		DepthStencilRenderTarget.ExclusiveDepthStencil = InEDS;
		FMemory::Memzero(&ColorRenderTargets[1], sizeof(FColorEntry) * (MaxSimultaneousRenderTargets - 1));
	}

	// Color and depth with resolve
	explicit FRHIRenderPassInfo(FRHITexture* ColorRT, ERenderTargetActions ColorAction, FRHITexture* ResolveColorRT,
		FRHITexture* DepthRT, EDepthStencilTargetActions DepthActions, FRHITexture* ResolveDepthRT, FExclusiveDepthStencil InEDS = FExclusiveDepthStencil::DepthWrite_StencilWrite)
	{
		check(!ResolveColorRT || ResolveColorRT->IsMultisampled());
		check(!ResolveDepthRT || ResolveDepthRT->IsMultisampled());
		check(ColorRT);
		ColorRenderTargets[0].RenderTarget = ColorRT;
		ColorRenderTargets[0].ResolveTarget = ResolveColorRT;
		ColorRenderTargets[0].ArraySlice = -1;
		ColorRenderTargets[0].MipIndex = 0;
		ColorRenderTargets[0].Action = ColorAction;
		check(DepthRT);
		DepthStencilRenderTarget.DepthStencilTarget = DepthRT;
		DepthStencilRenderTarget.ResolveTarget = ResolveDepthRT;
		DepthStencilRenderTarget.Action = DepthActions;
		DepthStencilRenderTarget.ExclusiveDepthStencil = InEDS;
		FMemory::Memzero(&ColorRenderTargets[1], sizeof(FColorEntry) * (MaxSimultaneousRenderTargets - 1));
	}

	// Color and depth with resolve and optional sample density
	explicit FRHIRenderPassInfo(FRHITexture* ColorRT, ERenderTargetActions ColorAction, FRHITexture* ResolveColorRT,
		FRHITexture* DepthRT, EDepthStencilTargetActions DepthActions, FRHITexture* ResolveDepthRT, 
		FRHITexture* InShadingRateTexture, EVRSRateCombiner InShadingRateTextureCombiner,
		FExclusiveDepthStencil InEDS = FExclusiveDepthStencil::DepthWrite_StencilWrite)
	{
		check(!ResolveColorRT || ResolveColorRT->IsMultisampled());
		check(!ResolveDepthRT || ResolveDepthRT->IsMultisampled());
		check(ColorRT);
		ColorRenderTargets[0].RenderTarget = ColorRT;
		ColorRenderTargets[0].ResolveTarget = ResolveColorRT;
		ColorRenderTargets[0].ArraySlice = -1;
		ColorRenderTargets[0].MipIndex = 0;
		ColorRenderTargets[0].Action = ColorAction;
		check(DepthRT);
		DepthStencilRenderTarget.DepthStencilTarget = DepthRT;
		DepthStencilRenderTarget.ResolveTarget = ResolveDepthRT;
		DepthStencilRenderTarget.Action = DepthActions;
		DepthStencilRenderTarget.ExclusiveDepthStencil = InEDS;
		ShadingRateTexture = InShadingRateTexture;
		ShadingRateTextureCombiner = InShadingRateTextureCombiner;
		FMemory::Memzero(&ColorRenderTargets[1], sizeof(FColorEntry) * (MaxSimultaneousRenderTargets - 1));
	}

	inline int32 GetNumColorRenderTargets() const
	{
		int32 ColorIndex = 0;
		for (; ColorIndex < MaxSimultaneousRenderTargets; ++ColorIndex)
		{
			const FColorEntry& Entry = ColorRenderTargets[ColorIndex];
			if (!Entry.RenderTarget)
			{
				break;
			}
		}

		return ColorIndex;
	}

	FGraphicsPipelineRenderTargetsInfo ExtractRenderTargetsInfo() const
	{
		FGraphicsPipelineRenderTargetsInfo RenderTargetsInfo;

		RenderTargetsInfo.NumSamples = 1;
		int32 RenderTargetIndex = 0;

		for (; RenderTargetIndex < MaxSimultaneousRenderTargets; ++RenderTargetIndex)
		{
			FRHITexture* RenderTarget = ColorRenderTargets[RenderTargetIndex].RenderTarget;
			if (!RenderTarget)
			{
				break;
			}

			RenderTargetsInfo.RenderTargetFormats[RenderTargetIndex] = (uint8)RenderTarget->GetFormat();
			RenderTargetsInfo.RenderTargetFlags[RenderTargetIndex] = RenderTarget->GetFlags();
			RenderTargetsInfo.NumSamples |= RenderTarget->GetNumSamples();
		}

		RenderTargetsInfo.RenderTargetsEnabled = RenderTargetIndex;
		for (; RenderTargetIndex < MaxSimultaneousRenderTargets; ++RenderTargetIndex)
		{
			RenderTargetsInfo.RenderTargetFormats[RenderTargetIndex] = PF_Unknown;
		}

		if (DepthStencilRenderTarget.DepthStencilTarget)
		{
			RenderTargetsInfo.DepthStencilTargetFormat = DepthStencilRenderTarget.DepthStencilTarget->GetFormat();
			RenderTargetsInfo.DepthStencilTargetFlag = DepthStencilRenderTarget.DepthStencilTarget->GetFlags();
			RenderTargetsInfo.NumSamples |= DepthStencilRenderTarget.DepthStencilTarget->GetNumSamples();
		}
		else
		{
			RenderTargetsInfo.DepthStencilTargetFormat = PF_Unknown;
		}

		const ERenderTargetActions DepthActions = GetDepthActions(DepthStencilRenderTarget.Action);
		const ERenderTargetActions StencilActions = GetStencilActions(DepthStencilRenderTarget.Action);
		RenderTargetsInfo.DepthTargetLoadAction = GetLoadAction(DepthActions);
		RenderTargetsInfo.DepthTargetStoreAction = GetStoreAction(DepthActions);
		RenderTargetsInfo.StencilTargetLoadAction = GetLoadAction(StencilActions);
		RenderTargetsInfo.StencilTargetStoreAction = GetStoreAction(StencilActions);
		RenderTargetsInfo.DepthStencilAccess = DepthStencilRenderTarget.ExclusiveDepthStencil;

		RenderTargetsInfo.MultiViewCount = MultiViewCount;
		RenderTargetsInfo.bHasFragmentDensityAttachment = ShadingRateTexture != nullptr;

		return RenderTargetsInfo;
	}

#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
	RHI_API void Validate() const;
#else
	void Validate() const {}
#endif
	RHI_API void ConvertToRenderTargetsInfo(FRHISetRenderTargetsInfo& OutRTInfo) const;
};

//UE_DEPRECATED(5.3, "Use FRHITextureSRVCreateDesc::SetDisableSRGB to create a view which explicitly disables SRGB.")
enum ERHITextureSRVOverrideSRGBType : uint8
{
	SRGBO_Default,
	SRGBO_ForceDisable,
};

//UE_DEPRECATED(5.3, "Use FRHITextureSRVCreateDesc rather than FRHITextureSRVCreateInfo.")
struct FRHITextureSRVCreateInfo
{
	explicit FRHITextureSRVCreateInfo(uint8 InMipLevel = 0u, uint8 InNumMipLevels = 1u, EPixelFormat InFormat = PF_Unknown)
		: Format(InFormat)
		, MipLevel(InMipLevel)
		, NumMipLevels(InNumMipLevels)
		, SRGBOverride(SRGBO_Default)
		, FirstArraySlice(0)
		, NumArraySlices(0)
	{}

	explicit FRHITextureSRVCreateInfo(uint8 InMipLevel, uint8 InNumMipLevels, uint16 InFirstArraySlice, uint16 InNumArraySlices, EPixelFormat InFormat = PF_Unknown)
		: Format(InFormat)
		, MipLevel(InMipLevel)
		, NumMipLevels(InNumMipLevels)
		, SRGBOverride(SRGBO_Default)
		, FirstArraySlice(InFirstArraySlice)
		, NumArraySlices(InNumArraySlices)
	{}

	/** View the texture with a different format. Leave as PF_Unknown to use original format. Useful when sampling stencil */
	EPixelFormat Format;

	/** Specify the mip level to use. Useful when rendering to one mip while sampling from another */
	uint8 MipLevel;

	/** Create a view to a single, or multiple mip levels */
	uint8 NumMipLevels;

	/** Potentially override the texture's sRGB flag */
	ERHITextureSRVOverrideSRGBType SRGBOverride;

	/** Specify first array slice index. By default 0. */
	uint16 FirstArraySlice;

	/** Specify number of array slices. If FirstArraySlice and NumArraySlices are both zero, the SRV is created for all array slices. By default 0. */
	uint16 NumArraySlices;

	/** Specify the metadata plane to use when creating a view. */
	ERHITextureMetaDataAccess MetaData = ERHITextureMetaDataAccess::None;
    
    /** Specify a dimension to use which overrides the default  */
    TOptional<ETextureDimension> DimensionOverride;

	FORCEINLINE bool operator==(const FRHITextureSRVCreateInfo& Other)const
	{
		return (
			Format == Other.Format &&
			MipLevel == Other.MipLevel &&
			NumMipLevels == Other.NumMipLevels &&
			SRGBOverride == Other.SRGBOverride &&
			FirstArraySlice == Other.FirstArraySlice &&
			NumArraySlices == Other.NumArraySlices &&
			MetaData == Other.MetaData &&
            DimensionOverride == Other.DimensionOverride);
	}

	FORCEINLINE bool operator!=(const FRHITextureSRVCreateInfo& Other)const
	{
		return !(*this == Other);
	}

	friend uint32 GetTypeHash(const FRHITextureSRVCreateInfo& Info)
	{
		uint32 Hash = uint32(Info.Format) | uint32(Info.MipLevel) << 8 | uint32(Info.NumMipLevels) << 16 | uint32(Info.SRGBOverride) << 24;
		Hash = HashCombine(Hash, uint32(Info.FirstArraySlice) | uint32(Info.NumArraySlices) << 16);
        Hash = HashCombine(Hash, Info.DimensionOverride.IsSet() ? uint32(*Info.DimensionOverride) : MAX_uint32);
		Hash = HashCombine(Hash, uint32(Info.MetaData));
		return Hash;
	}

	/** Check the validity. */
	static bool CheckValidity(const FRHITextureDesc& TextureDesc, const FRHITextureSRVCreateInfo& TextureSRVDesc, const TCHAR* TextureName)
	{
		return FRHITextureSRVCreateInfo::Validate(TextureDesc, TextureSRVDesc, TextureName, /* bFatal = */ true);
	}

protected:
	RHI_API static bool Validate(const FRHITextureDesc& TextureDesc, const FRHITextureSRVCreateInfo& TextureSRVDesc, const TCHAR* TextureName, bool bFatal);
};

struct FRHITextureUAVCreateInfo
{
public:
	FRHITextureUAVCreateInfo() = default;

	explicit FRHITextureUAVCreateInfo(uint8 InMipLevel, EPixelFormat InFormat = PF_Unknown, uint16 InFirstArraySlice = 0, uint16 InNumArraySlices = 0)
		: Format(InFormat)
		, MipLevel(InMipLevel)
		, FirstArraySlice(InFirstArraySlice)
		, NumArraySlices(InNumArraySlices)
	{}

	explicit FRHITextureUAVCreateInfo(ERHITextureMetaDataAccess InMetaData)
		: MetaData(InMetaData)
	{}

	FORCEINLINE bool operator==(const FRHITextureUAVCreateInfo& Other)const
	{
		return Format == Other.Format && MipLevel == Other.MipLevel && MetaData == Other.MetaData &&
                FirstArraySlice == Other.FirstArraySlice && NumArraySlices == Other.NumArraySlices &&
                DimensionOverride == Other.DimensionOverride;
	}

	FORCEINLINE bool operator!=(const FRHITextureUAVCreateInfo& Other)const
	{
		return !(*this == Other);
	}

	friend uint32 GetTypeHash(const FRHITextureUAVCreateInfo& Info)
	{
		uint32 Hash = uint32(Info.Format) | uint32(Info.MipLevel) << 8 | uint32(Info.FirstArraySlice) << 16;
        Hash = HashCombine(Hash, Info.DimensionOverride.IsSet() ? uint32(*Info.DimensionOverride) : MAX_uint32);
		Hash = HashCombine(Hash, uint32(Info.NumArraySlices) | uint32(Info.MetaData) << 16);
		return Hash;
	}

	EPixelFormat Format = PF_Unknown;
	uint8 MipLevel = 0;
	uint16 FirstArraySlice = 0;
	uint16 NumArraySlices = 0;	// When 0, the default behavior will be used, e.g. all slices mapped.
	ERHITextureMetaDataAccess MetaData = ERHITextureMetaDataAccess::None;
    
    /** Specify a dimension to use which overrides the default  */
    TOptional<ETextureDimension> DimensionOverride;
};

/** Descriptor used to create a buffer resource */
struct FRHIBufferCreateInfo
{
	bool operator == (const FRHIBufferCreateInfo& Other) const
	{
		return (
			Size == Other.Size &&
			Stride == Other.Stride &&
			Usage == Other.Usage);
	}

	bool operator != (const FRHIBufferCreateInfo& Other) const
	{
		return !(*this == Other);
	}

	/** Total size of the buffer. */
	uint32 Size = 1;

	/** Stride in bytes */
	uint32 Stride = 1;

	/** Bitfields describing the uses of that buffer. */
	EBufferUsageFlags Usage = BUF_None;
};

struct FRHIBufferSRVCreateInfo
{
	explicit FRHIBufferSRVCreateInfo() = default;

	explicit FRHIBufferSRVCreateInfo(EPixelFormat InFormat)
		: Format(InFormat)
	{}

	FRHIBufferSRVCreateInfo(uint32 InStartOffsetBytes, uint32 InNumElements)
		: StartOffsetBytes(InStartOffsetBytes)
		, NumElements(InNumElements)
	{}

	FRHIBufferSRVCreateInfo(FRHIRayTracingScene* InRayTracingScene, uint32 InStartOffsetBytes)
		: StartOffsetBytes(InStartOffsetBytes)
		, RayTracingScene(InRayTracingScene)
	{}

	FORCEINLINE bool operator==(const FRHIBufferSRVCreateInfo& Other)const
	{
		return Format == Other.Format
			&& StartOffsetBytes == Other.StartOffsetBytes
			&& NumElements == Other.NumElements
			&& RayTracingScene == Other.RayTracingScene;
	}

	FORCEINLINE bool operator!=(const FRHIBufferSRVCreateInfo& Other)const
	{
		return !(*this == Other);
	}

	friend uint32 GetTypeHash(const FRHIBufferSRVCreateInfo& Desc)
	{
		return HashCombine(
			HashCombine(
				HashCombine(GetTypeHash(Desc.Format), GetTypeHash(Desc.StartOffsetBytes)),
				GetTypeHash(Desc.NumElements)),
			GetTypeHash(Desc.RayTracingScene)
		);
	}

	/** Encoding format for the element. */
	EPixelFormat Format = PF_Unknown;

	/** Offset in bytes from the beginning of buffer */
	uint32 StartOffsetBytes = 0;

	/** Number of elements (whole buffer by default) */
	uint32 NumElements = UINT32_MAX;

	/** Ray tracing scene associated with the SRV (if BUF_AccelerationStructure) */
	FRHIRayTracingScene* RayTracingScene = nullptr;
};

struct FRHIBufferUAVCreateInfo
{
	FRHIBufferUAVCreateInfo() = default;

	explicit FRHIBufferUAVCreateInfo(EPixelFormat InFormat)
		: Format(InFormat)
	{}

	FORCEINLINE bool operator==(const FRHIBufferUAVCreateInfo& Other)const
	{
		return Format == Other.Format && bSupportsAtomicCounter == Other.bSupportsAtomicCounter && bSupportsAppendBuffer == Other.bSupportsAppendBuffer;
	}

	FORCEINLINE bool operator!=(const FRHIBufferUAVCreateInfo& Other)const
	{
		return !(*this == Other);
	}

	friend uint32 GetTypeHash(const FRHIBufferUAVCreateInfo& Info)
	{
		return uint32(Info.Format) | uint32(Info.bSupportsAtomicCounter) << 8 | uint32(Info.bSupportsAppendBuffer) << 16;
	}

	/** Number of bytes per element (used for typed buffers). */
	EPixelFormat Format = PF_Unknown;

	/** Whether the uav supports atomic counter or append buffer operations (used for structured buffers) */
	bool bSupportsAtomicCounter = false;
	bool bSupportsAppendBuffer = false;
};

class FRHITextureViewCache
{
public:
	// Finds a UAV matching the descriptor in the cache or creates a new one and updates the cache.
	RHI_API FRHIUnorderedAccessView* GetOrCreateUAV(FRHICommandListBase& RHICmdList, FRHITexture* Texture, const FRHITextureUAVCreateInfo& CreateInfo);

	// Finds a SRV matching the descriptor in the cache or creates a new one and updates the cache.
	RHI_API FRHIShaderResourceView* GetOrCreateSRV(FRHICommandListBase& RHICmdList, FRHITexture* Texture, const FRHITextureSRVCreateInfo& CreateInfo);

	// Sets the debug name of the RHI view resources.
#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
	RHI_API void SetDebugName(FRHICommandListBase& RHICmdList, const TCHAR* DebugName);
#else
	void SetDebugName(FRHICommandListBase& RHICmdList, const TCHAR* DebugName) {}
#endif

private:
	TArray<TPair<FRHITextureUAVCreateInfo, FUnorderedAccessViewRHIRef>, TInlineAllocator<1>> UAVs;
	TArray<TPair<FRHITextureSRVCreateInfo, FShaderResourceViewRHIRef>, TInlineAllocator<1>> SRVs;
};

class FRHIBufferViewCache
{
public:
	// Finds a UAV matching the descriptor in the cache or creates a new one and updates the cache.
	RHI_API FRHIUnorderedAccessView* GetOrCreateUAV(FRHICommandListBase& RHICmdList, FRHIBuffer* Buffer, const FRHIBufferUAVCreateInfo& CreateInfo);

	// Finds a SRV matching the descriptor in the cache or creates a new one and updates the cache.
	RHI_API FRHIShaderResourceView* GetOrCreateSRV(FRHICommandListBase& RHICmdList, FRHIBuffer* Buffer, const FRHIBufferSRVCreateInfo& CreateInfo);

	// Sets the debug name of the RHI view resources.
#if !(UE_BUILD_SHIPPING || UE_BUILD_TEST)
	RHI_API void SetDebugName(FRHICommandListBase& RHICmdList, const TCHAR* DebugName);
#else
	void SetDebugName(FRHICommandListBase& RHICmdList, const TCHAR* DebugName) {}
#endif
	FORCEINLINE int32 NumItems() const
	{
		return UAVs.Num() + SRVs.Num();
	}

private:
	TArray<TPair<FRHIBufferUAVCreateInfo, FUnorderedAccessViewRHIRef>, TInlineAllocator<1>> UAVs;
	TArray<TPair<FRHIBufferSRVCreateInfo, FShaderResourceViewRHIRef>, TInlineAllocator<1>> SRVs;
};
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Containers/Array.h"
#include "RHIResources.h"
#include "RHIResourceCollection.h"

#define RHI_VALIDATE_BATCHED_SHADER_PARAMETERS DO_CHECK

class FRHICommandList;
class FRHIComputeCommandList;

/** Compact representation of a bound shader parameter (read: value). Its offsets are for referencing their data in an associated blob. */
struct FRHIShaderParameter
{
	FRHIShaderParameter(uint16 InBufferIndex, uint16 InBaseIndex, uint16 InByteOffset, uint16 InByteSize)
		: BufferIndex(InBufferIndex)
		, BaseIndex(InBaseIndex)
		, ByteOffset(InByteOffset)
		, ByteSize(InByteSize)
	{
	}
	uint16 BufferIndex;
	uint16 BaseIndex;
	uint16 ByteOffset;
	uint16 ByteSize;
};

/** Compact representation of a bound resource parameter (Texture, SRV, UAV, SamplerState, or UniformBuffer) */
struct FRHIShaderParameterResource
{
	enum class EType : uint8
	{
		Texture,
		ResourceView,
		UnorderedAccessView,
		Sampler,
		UniformBuffer,
		ResourceCollection,
	};

	FRHIShaderParameterResource() = default;
	FRHIShaderParameterResource(EType InType, FRHIResource* InResource, uint16 InIndex)
		: Resource(InResource)
		, Index(InIndex)
		, Type(InType)
	{
	}
	FRHIShaderParameterResource(FRHITexture* InTexture, uint16 InIndex)
		: FRHIShaderParameterResource(FRHIShaderParameterResource::EType::Texture, InTexture, InIndex)
	{
	}
	FRHIShaderParameterResource(FRHIShaderResourceView* InView, uint16 InIndex)
		: FRHIShaderParameterResource(FRHIShaderParameterResource::EType::ResourceView, InView, InIndex)
	{
	}
	FRHIShaderParameterResource(FRHIUnorderedAccessView* InUAV, uint16 InIndex)
		: FRHIShaderParameterResource(FRHIShaderParameterResource::EType::UnorderedAccessView, InUAV, InIndex)
	{
	}
	FRHIShaderParameterResource(FRHISamplerState* InSamplerState, uint16 InIndex)
		: FRHIShaderParameterResource(FRHIShaderParameterResource::EType::Sampler, InSamplerState, InIndex)
	{
	}
	FRHIShaderParameterResource(FRHIUniformBuffer* InUniformBuffer, uint16 InIndex)
		: FRHIShaderParameterResource(FRHIShaderParameterResource::EType::UniformBuffer, InUniformBuffer, InIndex)
	{
	}
	FRHIShaderParameterResource(FRHIResourceCollection* InResourceCollection, uint16 InIndex)
		: FRHIShaderParameterResource(FRHIShaderParameterResource::EType::ResourceCollection, InResourceCollection, InIndex)
	{
	}

	bool operator == (const FRHIShaderParameterResource& Other) const
	{
		return Resource == Other.Resource
			&& Index == Other.Index
			&& Type == Other.Type;
	}

	FRHIResource* Resource = nullptr;
	uint16        Index = 0;
	EType         Type = EType::Texture;
};

struct FRHIBatchedShaderParameters;

enum class ERHIBatchedShaderParameterAllocatorPageSize
{
	Small,
	Large
};

class FRHIBatchedShaderParametersAllocator
{
public:
	FRHIBatchedShaderParametersAllocator* Next;
	FRHICommandListBase& RHICmdList;

private:
	friend class FRHICommandListBase;
	friend struct FRHIBatchedShaderParameters;

	FMemStackBase ParametersData;
	FMemStackBase Parameters;
	FMemStackBase ResourceParameters;
	FMemStackBase BindlessParameters;

	FRHIBatchedShaderParametersAllocator(FRHIBatchedShaderParametersAllocator*& InOutRootListLink, FRHICommandListBase& InRHICmdList, ERHIBatchedShaderParameterAllocatorPageSize PageSize)
		: FRHIBatchedShaderParametersAllocator(InOutRootListLink, InRHICmdList, PageSize == ERHIBatchedShaderParameterAllocatorPageSize::Small ? FMemStackBase::EPageSize::Small : FMemStackBase::EPageSize::Large)
	{}

	FRHIBatchedShaderParametersAllocator(FRHIBatchedShaderParametersAllocator*& InOutRootListLink, FRHICommandListBase& InRHICmdList, FMemStackBase::EPageSize PageSize)
		: Next(InOutRootListLink)
		, RHICmdList(InRHICmdList)
		, ParametersData(PageSize)
		, Parameters(PageSize)
		, ResourceParameters(PageSize)
		, BindlessParameters(PageSize)
	{
		InOutRootListLink = this;
	}

	FORCEINLINE void Attach(const FRHIBatchedShaderParameters* InParameters)
	{
#if RHI_VALIDATE_BATCHED_SHADER_PARAMETERS
		if (AttachedParameters != InParameters)
		{
			checkf(!AttachedParameters, TEXT("Only one FRHIBatchedShaderParameters instance can be used at a time with this allocator. You must call FRHIBatchedShaderParameters::{Reset, Finish} to start processing a new one."));
			AttachedParameters = InParameters;
		}
#endif
	}

	FORCEINLINE void Detach()
	{
#if RHI_VALIDATE_BATCHED_SHADER_PARAMETERS
		AttachedParameters = nullptr;
#endif
	}

	template <typename... ArgsType>
	FORCEINLINE void EmplaceParameter(TArrayView<FRHIShaderParameter>& InOutArray, ArgsType&& ...Args)
	{
		Emplace(Parameters, InOutArray, Forward<ArgsType&&>(Args)...);
	}

	template <typename... ArgsType>
	FORCEINLINE void AddResourceParameter(TArrayView<FRHIShaderParameterResource>& InOutArray, ArgsType&& ...Args)
	{
		Emplace(ResourceParameters, InOutArray, Forward<ArgsType&&>(Args)...);
	}

	template <typename... ArgsType>
	FORCEINLINE void AddBindlessParameter(TArrayView<FRHIShaderParameterResource>& InOutArray, ArgsType&& ...Args)
	{
		Emplace(BindlessParameters, InOutArray, Forward<ArgsType&&>(Args)...);
	}

#if RHI_VALIDATE_BATCHED_SHADER_PARAMETERS
	const FRHIBatchedShaderParameters* AttachedParameters = nullptr;
#endif

	template <typename ElementType, typename... ArgsType>
	void Emplace(FMemStackBase& MemStack, TArrayView<ElementType>& InOutArray, ArgsType&& ...Args)
	{
		static_assert(sizeof(ElementType) % alignof(ElementType) == 0, "Element size must be a multiple of its alignment");

		const size_t ElementSize = sizeof(ElementType);
		const size_t Alignment   = alignof(ElementType);
		const int32 NumElements  = InOutArray.Num() + 1;
		ElementType* Elements    = InOutArray.GetData();

		if (InOutArray.IsEmpty())
		{
			Elements = new (MemStack.Alloc(ElementSize, Alignment)) ElementType(Forward<ArgsType&>(Args)...);
		}
		else
		{
			// Sanity check that the top of the stack contains the last element that was allocated.
			check(MemStack.GetTop() == (uint8*)(InOutArray.GetData() + InOutArray.Num()));

			// Try to extend the size of the current array without resizing.
			if (MemStack.CanFitInPage(ElementSize, 1))
			{
				new (MemStack.Alloc(ElementSize, 1)) ElementType(Forward<ArgsType&>(Args)...);
			}
			// Reached the end of the page. Reallocate the entire array into a new page.
			else
			{
				Elements = reinterpret_cast<ElementType*>(MemStack.Alloc(NumElements * ElementSize, Alignment));
				ElementType* LastElement = Elements;
				for (int32 Index = 0; Index < InOutArray.Num(); ++Index, ++LastElement)
				{
					new (LastElement) ElementType(MoveTemp(InOutArray[Index]));
				}
				new (LastElement) ElementType(Forward<ArgsType&>(Args)...);
			}
		}

		InOutArray = TArrayView<ElementType>(Elements, NumElements);
	}

	void AppendParametersData(TArrayView<uint8>& InOutArray, uint32 NumBytes, const uint8* Bytes)
	{
		constexpr size_t Alignment = 1;
		const int32 NumArrayBytes  = InOutArray.Num() + NumBytes;
		uint8* ArrayBytes          = InOutArray.GetData();

		if (InOutArray.IsEmpty())
		{
			ArrayBytes = (uint8*)ParametersData.Alloc(NumBytes, Alignment);
			FMemory::Memcpy(ArrayBytes, Bytes, NumBytes);
		}
		else
		{
			// Sanity check that the top of the stack contains the last element that was allocated.
			check(ParametersData.GetTop() == InOutArray.GetData() + InOutArray.Num());

			// Try to extend the size of the current array without resizing.
			if (ParametersData.CanFitInPage(NumBytes, Alignment))
			{
				FMemory::Memcpy(ParametersData.Alloc(NumBytes, Alignment), Bytes, NumBytes);
			}
			// Reached the end of the page. Reallocate the entire array into a new page.
			else
			{
				ArrayBytes = (uint8*)ParametersData.Alloc(NumArrayBytes, Alignment);
				FMemory::Memcpy(ArrayBytes, InOutArray.GetData(), InOutArray.Num());
				FMemory::Memcpy(ArrayBytes + InOutArray.Num(), Bytes, NumBytes);
			}
		}

		InOutArray = TArrayView<uint8>(ArrayBytes, NumArrayBytes);
	}
};

/** Collection of parameters to set in the RHI. These parameters aren't bound to any specific shader until SetBatchedShaderParameters is called. */
struct FRHIBatchedShaderParameters
{
	FRHIBatchedShaderParametersAllocator& Allocator;
	TArrayView<uint8> ParametersData;
	TArrayView<FRHIShaderParameter> Parameters;
	TArrayView<FRHIShaderParameterResource> ResourceParameters;
	TArrayView<FRHIShaderParameterResource> BindlessParameters;

	FRHIBatchedShaderParameters(FRHIBatchedShaderParametersAllocator& InAllocator)
		: Allocator(InAllocator)
	{}

	inline bool HasParameters() const
	{
		return (Parameters.Num() + ResourceParameters.Num() + BindlessParameters.Num()) > 0;
	}

	// Marks the parameters as complete and retains the parameter contents.
	void Finish()
	{
		Allocator.Detach();
	}

	// Resets the parameters back to an empty state.
	void Reset()
	{
		Allocator.Detach();
		ParametersData = {};
		Parameters = {};
		ResourceParameters = {};
		BindlessParameters = {};
	}

	template <typename... ArgsType>
	FORCEINLINE_DEBUGGABLE void AddResourceParameter(ArgsType&& ...Args)
	{
		Allocator.Attach(this);
		Allocator.AddResourceParameter(ResourceParameters, Forward<ArgsType&>(Args)...);
	}
	
	template <typename... ArgsType>
	FORCEINLINE_DEBUGGABLE void AddBindlessParameter(ArgsType&& ...Args)
	{
		Allocator.Attach(this);
		Allocator.AddBindlessParameter(BindlessParameters, Forward<ArgsType&>(Args)...);
	}

	FORCEINLINE_DEBUGGABLE void SetShaderParameter(uint32 BufferIndex, uint32 BaseIndex, uint32 NumBytes, const void* NewValue)
	{
		const int32 DestDataOffset = ParametersData.Num();
		Allocator.Attach(this);
		Allocator.AppendParametersData(ParametersData, NumBytes, (const uint8*)NewValue);
		Allocator.EmplaceParameter(Parameters, (uint16)BufferIndex, (uint16)BaseIndex, (uint16)DestDataOffset, (uint16)NumBytes);
	}

	FORCEINLINE_DEBUGGABLE void SetShaderUniformBuffer(uint32 Index, FRHIUniformBuffer* UniformBuffer)
	{
		Allocator.Attach(this);
		AddResourceParameter(UniformBuffer, (uint16)Index);
	}

	FORCEINLINE_DEBUGGABLE void SetShaderTexture(uint32 Index, FRHITexture* Texture)
	{
		AddResourceParameter(Texture, (uint16)Index);
	}

	FORCEINLINE_DEBUGGABLE void SetShaderResourceViewParameter(uint32 Index, FRHIShaderResourceView* SRV)
	{
		AddResourceParameter(SRV, (uint16)Index);
	}

	FORCEINLINE_DEBUGGABLE void SetShaderSampler(uint32 Index, FRHISamplerState* State)
	{
		AddResourceParameter(State, (uint16)Index);
	}

	FORCEINLINE_DEBUGGABLE void SetUAVParameter(uint32 Index, FRHIUnorderedAccessView* UAV)
	{
		AddResourceParameter(UAV, (uint16)Index);
	}

	FORCEINLINE_DEBUGGABLE void SetResourceCollection(uint32 Index, FRHIResourceCollection* ResourceCollection)
	{
		AddResourceParameter(ResourceCollection, (uint16)Index);
	}

	FORCEINLINE_DEBUGGABLE void SetBindlessTexture(uint32 Index, FRHITexture* Texture)
	{
		AddBindlessParameter(Texture, (uint16)Index);
	}

	FORCEINLINE_DEBUGGABLE void SetBindlessResourceView(uint32 Index, FRHIShaderResourceView* SRV)
	{
		AddBindlessParameter(SRV, (uint16)Index);
	}

	FORCEINLINE_DEBUGGABLE void SetBindlessSampler(uint32 Index, FRHISamplerState* State)
	{
		AddBindlessParameter(State, (uint16)Index);
	}

	FORCEINLINE_DEBUGGABLE void SetBindlessUAV(uint32 Index, FRHIUnorderedAccessView* UAV)
	{
		AddBindlessParameter(UAV, (uint16)Index);
	}

	FORCEINLINE_DEBUGGABLE void SetBindlessResourceCollection(uint32 Index, FRHIResourceCollection* ResourceCollection)
	{
		AddBindlessParameter(ResourceCollection, (uint16)Index);
	}
};

/** Compact representation of a resource parameter unbind, limited to  SRVs and UAVs */
struct FRHIShaderParameterUnbind
{
	enum class EType : uint8
	{
		ResourceView,
		UnorderedAccessView,
	};

	FRHIShaderParameterUnbind() = default;
	FRHIShaderParameterUnbind(EType InType, uint16 InIndex)
		: Index(InIndex)
		, Type(InType)
	{
	}

	uint16  Index = 0;
	EType   Type = EType::ResourceView;
};

/** Collection of parameters to unbind in the RHI. These unbinds aren't tied to any specific shader until SetBatchedShaderUnbinds is called. */
struct FRHIBatchedShaderUnbinds
{
	TArray<FRHIShaderParameterUnbind> Unbinds;

	bool HasParameters() const
	{
		return Unbinds.Num() > 0;
	}

	void Reset()
	{
		Unbinds.Reset();
	}

	void UnsetSRV(uint32 Index)
	{
		Unbinds.Emplace(FRHIShaderParameterUnbind::EType::ResourceView, (uint16)Index);
	}
	void UnsetUAV(uint32 Index)
	{
		Unbinds.Emplace(FRHIShaderParameterUnbind::EType::UnorderedAccessView, (uint16)Index);
	}
};

struct FRHIShaderBundleComputeDispatch
{
	uint32 RecordIndex = ~uint32(0u);
	class FComputePipelineState* PipelineState = nullptr;
	FRHIComputeShader* Shader = nullptr;
	FRHIWorkGraphShader* WorkGraphShader = nullptr;
	FRHIComputePipelineState* RHIPipeline = nullptr;
	TOptional<FRHIBatchedShaderParameters> Parameters;
	FUint32Vector4 Constants;

	inline bool IsValid() const
	{
		return RecordIndex != ~uint32(0u);
	}
};

struct FRHIShaderBundleGraphicsState
{
	FIntRect ViewRect;

	float DepthMin = 0.0f;
	float DepthMax = 1.0f;

	float BlendFactor[4] = { 1.0f, 1.0f, 1.0f, 1.0f };

	EPrimitiveType PrimitiveType = PT_TriangleList;

	uint8 StencilRef = 0;
};

struct FRHIShaderBundleGraphicsDispatch
{
	uint32 RecordIndex = ~uint32(0u);
	class FGraphicsPipelineState* PipelineState = nullptr;
	FRHIGraphicsPipelineState* RHIPipeline = nullptr;

	FGraphicsPipelineStateInitializer PipelineInitializer;

	TOptional<FRHIBatchedShaderParameters> Parameters_MSVS;
	TOptional<FRHIBatchedShaderParameters> Parameters_PS;

	FUint32Vector4 Constants;

	inline bool IsValid() const
	{
		return RecordIndex != ~uint32(0u);
	}
};// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	Shader.h: Shader definitions.
=============================================================================*/

#pragma once

#include "Algo/BinarySearch.h"
#include "Containers/Array.h"
#include "Containers/ArrayView.h"
#include "Containers/ContainersFwd.h"
#include "Containers/EnumAsByte.h"
#include "Containers/HashTable.h"
#include "Containers/List.h"
#include "Containers/Map.h"
#include "Containers/Set.h"
#include "Containers/StringFwd.h"
#include "Containers/UnrealString.h"
#include "CoreMinimal.h"
#include "CoreTypes.h"
#include "HAL/CriticalSection.h"
#include "HAL/PlatformCrt.h"
#include "HAL/ThreadSafeBool.h"
#include "HAL/UnrealMemory.h"
#include "Math/NumericLimits.h"
#include "Misc/AssertionMacros.h"
#include "Misc/CString.h"
#include "Misc/EnumClassFlags.h"
#include "Misc/ScopeLock.h"
#include "Misc/SecureHash.h"
#include "RHI.h"
#include "RHIDefinitions.h"
#include "RHIMemoryLayout.h"
#include "RenderResource.h"
#if UE_ENABLE_INCLUDE_ORDER_DEPRECATED_IN_5_2
#include "RenderingThread.h"
#endif
#include "RenderDeferredCleanup.h"
#include "Serialization/Archive.h"
#include "Serialization/ArchiveProxy.h"
#include "Serialization/MemoryImage.h"
#include "Serialization/MemoryLayout.h"
#include "ShaderCore.h"
#include "ShaderParameterMetadata.h"
#include "ShaderParameters.h"
#include "ShaderPermutation.h"
#include "ShaderSerialization.h"
#include "Templates/RefCounting.h"
#include "Templates/TypeHash.h"
#include "Templates/UniquePtr.h"
#include "Templates/UnrealTemplate.h"
#include "Templates/UnrealTypeTraits.h"
#include "UObject/NameTypes.h"
#include "UObject/RenderingObjectVersion.h"

#include <atomic>

// For FShaderUniformBufferParameter

#if WITH_EDITOR
#include "UObject/DebugSerializationFlags.h"
#endif

class ITargetPlatform;
class FCbFieldView;
class FCbWriter;
class FComputeKernelShaderType;
class FGlobalShaderType;
class FMaterialShaderType;
class FMemoryImageWriter;
class FMemoryUnfreezeContent;
class FMeshMaterialShaderType;
class FNiagaraShaderType;
class FOpenColorIOShaderType;
class FRHIComputeCommandList;
class FShader;
class FShaderKeyGenerator;
class FShaderMapBase;
class FShaderMapPointerTable;
class FShaderParametersMetadata;
class FShaderPipelineType;
class FShaderType;
class FVertexFactoryType;
class FRHIShaderBindingLayout;
struct FShaderCompiledShaderInitializerType;
struct FShaderCompilerOutput;
using FShaderMapAssetPaths = TSet<FName>; // Copied from ShaderCodeLibrary.h

/** Define a shader permutation uniquely according to its type, and permutation id.*/
template<typename MetaShaderType>
struct TShaderTypePermutation
{
	MetaShaderType* const Type;
	const int32 PermutationId;

	TShaderTypePermutation(MetaShaderType* InType, int32 InPermutationId)
		: Type(InType)
		, PermutationId(InPermutationId)
	{
	}

	FORCEINLINE bool operator==(const TShaderTypePermutation& Other)const
	{
		return Type == Other.Type && PermutationId == Other.PermutationId;
	}

	FORCEINLINE bool operator!=(const TShaderTypePermutation& Other)const
	{
		return !(*this == Other);
	}

	friend FORCEINLINE uint32 GetTypeHash(const TShaderTypePermutation& Var)
	{
		return HashCombine(GetTypeHash(Var.Type), (uint32)Var.PermutationId);
	}
};

using FShaderPermutation = TShaderTypePermutation<FShaderType>;

inline const int32 kUniqueShaderPermutationId = 0;

/** Used to compare order shader types permutation deterministically. */
template<typename MetaShaderType>
class TCompareShaderTypePermutation
{
public:
	FORCEINLINE bool operator()(const TShaderTypePermutation<MetaShaderType>& A, const TShaderTypePermutation<MetaShaderType>& B) const
	{
		int32 AL = FCString::Strlen(A.Type->GetName());
		int32 BL = FCString::Strlen(B.Type->GetName());
		if (AL == BL)
		{
			int32 StrCmp = FCString::Strncmp(A.Type->GetName(), B.Type->GetName(), AL);
			if (StrCmp != 0)
			{
				return StrCmp > 0;
			}
			return A.PermutationId > B.PermutationId;
		}
		return AL > BL;
	}
};

class FShaderUniformBufferParameterInfo
{
	DECLARE_EXPORTED_TYPE_LAYOUT(FShaderUniformBufferParameterInfo, RENDERCORE_API, NonVirtual);
public:
	LAYOUT_FIELD(uint16, BaseIndex);

	FShaderUniformBufferParameterInfo() = default;

	FShaderUniformBufferParameterInfo(uint16 InBaseIndex)
	{
		BaseIndex = InBaseIndex;
		checkf(BaseIndex == InBaseIndex, TEXT("Tweak FShaderUniformBufferParameterInfo type sizes"));
	}

	friend FArchive& operator<<(FArchive& Ar, FShaderUniformBufferParameterInfo& Info)
	{
		Ar << Info.BaseIndex;
		return Ar;
	}

	inline bool operator==(const FShaderUniformBufferParameterInfo& Rhs) const
	{
		return BaseIndex == Rhs.BaseIndex;
	}

	inline bool operator<(const FShaderUniformBufferParameterInfo& Rhs) const
	{
		return BaseIndex < Rhs.BaseIndex;
	}
};

class FShaderResourceParameterInfo
{
	DECLARE_EXPORTED_TYPE_LAYOUT(FShaderResourceParameterInfo, RENDERCORE_API, NonVirtual);
public:
	LAYOUT_FIELD(uint16, BaseIndex);
	LAYOUT_FIELD(uint8, BufferIndex);
	LAYOUT_FIELD(EShaderParameterType, Type);

	FShaderResourceParameterInfo() = default;

	FShaderResourceParameterInfo(uint16 InBaseIndex, uint8 InBufferIndex, EShaderParameterType InType)
	{
		BaseIndex = InBaseIndex;
		BufferIndex = InBufferIndex;
		Type = InType;
		checkf(BaseIndex == InBaseIndex && BufferIndex == InBufferIndex && Type == InType, TEXT("Tweak FShaderResourceParameterInfo type sizes"));
	}

	friend FArchive& operator<<(FArchive& Ar, FShaderResourceParameterInfo& Info)
	{
		Ar << Info.BaseIndex;
		Ar << Info.BufferIndex;
		Ar << Info.Type;
		return Ar;
	}

	inline bool operator==(const FShaderResourceParameterInfo& Rhs) const
	{
		return BaseIndex == Rhs.BaseIndex
			&& BufferIndex == Rhs.BufferIndex
			&& Type == Rhs.Type;
	}

	inline bool operator<(const FShaderResourceParameterInfo& Rhs) const
	{
		return BaseIndex < Rhs.BaseIndex;
	}
};

class FShaderLooseParameterInfo
{
	DECLARE_EXPORTED_TYPE_LAYOUT(FShaderLooseParameterInfo, RENDERCORE_API, NonVirtual);
public:
	LAYOUT_FIELD(uint16, BaseIndex);
	LAYOUT_FIELD(uint16, Size);

	FShaderLooseParameterInfo() = default;

	FShaderLooseParameterInfo(uint16 InBaseIndex, uint16 InSize)
	{
		BaseIndex = InBaseIndex;
		Size = InSize;
		checkf(BaseIndex == InBaseIndex && Size == InSize, TEXT("Tweak FShaderLooseParameterInfo type sizes"));
	}

	friend FArchive& operator<<(FArchive& Ar, FShaderLooseParameterInfo& Info)
	{
		Ar << Info.BaseIndex;
		Ar << Info.Size;
		return Ar;
	}

	inline bool operator==(const FShaderLooseParameterInfo& Rhs) const
	{
		return BaseIndex == Rhs.BaseIndex
			&& Size == Rhs.Size;
	}

	inline bool operator<(const FShaderLooseParameterInfo& Rhs) const
	{
		return BaseIndex < Rhs.BaseIndex;
	}
};

class FShaderLooseParameterBufferInfo
{
	DECLARE_EXPORTED_TYPE_LAYOUT(FShaderLooseParameterBufferInfo, RENDERCORE_API, NonVirtual);
public:
	LAYOUT_FIELD(uint16, BaseIndex);
	LAYOUT_FIELD(uint16, Size);

	LAYOUT_FIELD(TMemoryImageArray<FShaderLooseParameterInfo>, Parameters);

	FShaderLooseParameterBufferInfo() {}

	FShaderLooseParameterBufferInfo(uint16 InBufferIndex, uint16 InBufferSize)
	{
		BaseIndex = InBufferIndex;
		Size = InBufferSize;
		checkf(BaseIndex == InBufferIndex, TEXT("Tweak FShaderLooseParameterBufferInfo type sizes"));
	}

	friend FArchive& operator<<(FArchive& Ar,FShaderLooseParameterBufferInfo& Info)
	{
		Ar << Info.BaseIndex;
		Ar << Info.Size;
		Ar << Info.Parameters;
		return Ar;
	}

	inline bool operator==(const FShaderLooseParameterBufferInfo& Rhs) const
	{
		return BaseIndex == Rhs.BaseIndex
			&& Size == Rhs.Size
			&& Parameters == Rhs.Parameters;
	}

	inline bool operator<(const FShaderLooseParameterBufferInfo& Rhs) const
	{
		return BaseIndex < Rhs.BaseIndex;
	}
};

class FShaderParameterMapInfo
{
	DECLARE_EXPORTED_TYPE_LAYOUT(FShaderParameterMapInfo, RENDERCORE_API, NonVirtual);
public:
	LAYOUT_FIELD(TMemoryImageArray<FShaderUniformBufferParameterInfo>, UniformBuffers);
	LAYOUT_FIELD(TMemoryImageArray<FShaderResourceParameterInfo>, TextureSamplers);
	LAYOUT_FIELD(TMemoryImageArray<FShaderResourceParameterInfo>, SRVs);
	LAYOUT_FIELD(TMemoryImageArray<FShaderLooseParameterBufferInfo>, LooseParameterBuffers);
	LAYOUT_FIELD(uint64, Hash);

	friend FArchive& operator<<(FArchive& Ar,FShaderParameterMapInfo& Info)
	{
		Ar << Info.UniformBuffers;
		Ar << Info.TextureSamplers;
		Ar << Info.SRVs;
		Ar << Info.LooseParameterBuffers;
		Ar << Info.Hash;
		return Ar;
	}

	inline bool operator==(const FShaderParameterMapInfo& Rhs) const
	{
		return Hash == Rhs.Hash;
	}
};

enum class ERayTracingPayloadType : uint32; // actual enum is defined in /Shaders/Shared/RayTracingPayloadType.h
typedef uint32(*TRaytracingPayloadSizeFunction)();
ENUM_CLASS_FLAGS(ERayTracingPayloadType);

RENDERCORE_API uint32 GetRayTracingPayloadTypeMaxSize(ERayTracingPayloadType PayloadType);
RENDERCORE_API void RegisterRayTracingPayloadType(ERayTracingPayloadType PayloadType, uint32 PayloadSize, TRaytracingPayloadSizeFunction PayloadSizeFunction);

struct FRegisterRayTracingPayloadTypeHelper
{
	FRegisterRayTracingPayloadTypeHelper(ERayTracingPayloadType PayloadType, uint32 PayloadSize, TRaytracingPayloadSizeFunction PayloadSizeFunction)
	{
		RegisterRayTracingPayloadType(PayloadType, PayloadSize, PayloadSizeFunction);
	}
};

#define IMPLEMENT_RT_PAYLOAD_TYPE_CONCAT2( x, y ) x##y
#define IMPLEMENT_RT_PAYLOAD_TYPE_CONCAT( x, y ) IMPLEMENT_RT_PAYLOAD_TYPE_CONCAT2( x, y )
#define IMPLEMENT_RT_PAYLOAD_TYPE(PayloadType, PayloadSize)  static FRegisterRayTracingPayloadTypeHelper IMPLEMENT_RT_PAYLOAD_TYPE_CONCAT(PayloadHelper, __COUNTER__) = FRegisterRayTracingPayloadTypeHelper(PayloadType, PayloadSize, nullptr);
#define IMPLEMENT_RT_PAYLOAD_TYPE_FUNCTION(PayloadType, PayloadSizeFunction)  static FRegisterRayTracingPayloadTypeHelper IMPLEMENT_RT_PAYLOAD_TYPE_CONCAT(PayloadHelper, __COUNTER__) = FRegisterRayTracingPayloadTypeHelper(PayloadType, 0u, PayloadSizeFunction);

class FShaderMapResource : public FRenderResource, public FDeferredCleanupInterface
{
public:
	static RENDERCORE_API bool ArePlatformsCompatible(EShaderPlatform CurrentPlatform, EShaderPlatform TargetPlatform);

	EShaderPlatform GetPlatform() const { return Platform; }

	RENDERCORE_API void AddRef();
	RENDERCORE_API void Release();
	inline int32 GetNumRefs() const { return NumRefs.load(std::memory_order_relaxed); }

	// FRenderResource interface.
	RENDERCORE_API virtual void ReleaseRHI();

	inline int32 GetNumShaders() const
	{
		return NumRHIShaders;
	}

	inline bool IsValidShaderIndex(int32 ShaderIndex) const
	{
		return static_cast<uint32>(ShaderIndex) < NumRHIShaders;
	}

	inline bool HasShader(int32 ShaderIndex) const
	{
		return RHIShaders[ShaderIndex].load(std::memory_order_acquire) != nullptr;
	}

	virtual void PreloadShader(int32 ShaderIndex, FGraphEventArray& OutCompletionEvents)
	{
		/* no-op when not using shader library */
	};

	virtual void PreloadShaderMap(FGraphEventArray& OutCompletionEvents)
	{
		/* no-op when not using shader library */
	};

	virtual int32 GetGroupIndexForShader(int32 ShaderIndex) const
	{
		/* return invalid index when not using shader library */
		return INDEX_NONE;
	};

	virtual int32 GetLibraryId() const
	{
		/* return invalid index when not using shader library */
		return INDEX_NONE;
	}

	virtual int32 GetLibraryShaderIndex(int32 ShaderIndex) const
	{
		/* return invalid index when not using shader library */
		return INDEX_NONE;
	}

	inline bool ContainsAtLeastOneRHIShaderCreated() const
	{
		return bAtLeastOneRHIShaderCreated;
	}

	inline FRHIShader* GetShader(int32 ShaderIndex, bool bRequired = true)
	{
		// This is a double checked locking. This trickery arises from the fact that we're
		// synchronizing two threads: one that takes a lock and another that doesn't.
		// Without fences, there is a race between storing the shader pointer and accessing it
		// on the other (lockless) thread.
		FRHIShader* Shader = RHIShaders[ShaderIndex].load(std::memory_order_acquire);
		if (UNLIKELY(Shader == nullptr))
		{
			Shader = CreateShaderOrCrash(ShaderIndex, bRequired);
		}
		return Shader;
	}

	/** Return shader hash for a particular shader without creating it. */
	virtual FSHAHash GetShaderHash(int32 ShaderIndex) = 0;

	RENDERCORE_API void BeginCreateAllShaders();

#if RHI_RAYTRACING

	UE_DEPRECATED(5.1, "GetRayTracingMaterialLibrary is deprecated. Use GetRayTracingHitGroupLibrary instead.")
	static void GetRayTracingMaterialLibrary(TArray<FRHIRayTracingShader*>& RayTracingMaterials, FRHIRayTracingShader* DefaultShader)
	{
		GetRayTracingHitGroupLibrary(RayTracingMaterials, DefaultShader);
	}

	UE_DEPRECATED(5.1, "GetRayTracingMaterialLibraryIndex is deprecated. Use GetRayTracingHitGroupLibraryIndex instead.")
	inline uint32 GetRayTracingMaterialLibraryIndex(int32 ShaderIndex)
	{
		return GetRayTracingHitGroupLibraryIndex(ShaderIndex);
	}

	static RENDERCORE_API void GetRayTracingHitGroupLibrary(TArray<FRHIRayTracingShader*>& RayTracingHitGroupShaders, FRHIRayTracingShader* DefaultShader);
	static RENDERCORE_API void GetRayTracingCallableShaderLibrary(TArray<FRHIRayTracingShader*>& RayTracingCallableShaders, FRHIRayTracingShader* DefaultShader);
	static RENDERCORE_API void GetRayTracingMissShaderLibrary(TArray<FRHIRayTracingShader*>& RayTracingMissShaders, FRHIRayTracingShader* DefaultShader);

	inline uint32 GetRayTracingHitGroupLibraryIndex(int32 ShaderIndex)
	{
		FRHIShader* Shader = GetShader(ShaderIndex);	// make sure the shader is created
		checkSlow(Shader->GetFrequency() == SF_RayHitGroup);
		return RayTracingLibraryIndices[ShaderIndex];
	}

	inline uint32 GetRayTracingCallableShaderLibraryIndex(int32 ShaderIndex)
	{
		FRHIShader* Shader = GetShader(ShaderIndex);	// make sure the shader is created
		checkSlow(Shader->GetFrequency() == SF_RayCallable);
		return RayTracingLibraryIndices[ShaderIndex];
	}

	inline uint32 GetRayTracingMissShaderLibraryIndex(int32 ShaderIndex)
	{
		FRHIShader* Shader = GetShader(ShaderIndex);	// make sure the shader is created
		checkSlow(Shader->GetFrequency() == SF_RayMiss);
		return RayTracingLibraryIndices[ShaderIndex];
	}
#endif // RHI_RAYTRACING

	virtual uint32 GetSizeBytes() const = 0;

protected:
	RENDERCORE_API explicit FShaderMapResource(EShaderPlatform InPlatform, int32 NumShaders);
	RENDERCORE_API virtual ~FShaderMapResource();

	SIZE_T GetAllocatedSize() const
	{
		SIZE_T Size = NumRHIShaders * sizeof(std::atomic<FRHIShader*>);
#if RHI_RAYTRACING
		Size += RayTracingLibraryIndices.GetAllocatedSize();
#endif
		return Size;
	}

	/** Creates RHI shader, with a reference (so the caller can release). Never returns nullptr (inability to create is Fatal) */
	virtual FRHIShader*	CreateRHIShaderOrCrash(int32 ShaderIndex, bool bRequired) = 0;

	/** Signal the shader library that it can release compressed shader code for a shader that it keeps preloaded in memory. */
	virtual void ReleasePreloadedShaderCode(int32 ShaderIndex) { /* no-op when not using shader library */ };

	virtual bool TryRelease() { return true; }

	RENDERCORE_API void ReleaseShaders();

private:

	/** Creates an entry in RHIShaders array and registers it among the raytracing libs if needed. Created shader is returned. */
	RENDERCORE_API FRHIShader* CreateShaderOrCrash(int32 ShaderIndex, bool bRequired);

	/** This lock is to prevent two threads creating the same RHIShaders element. It is only taken if the element is to be created. */
	FCriticalSection RHIShadersCreationGuard;

#if RHI_RAYTRACING
	TArray<uint32> RayTracingLibraryIndices;
#endif // RHI_RAYTRACING

	/** An array of shader pointers (refcount is managed manually). */
	TUniquePtr<std::atomic<FRHIShader*>[]> RHIShaders;

	/** Since the shaders are no longer a TArray, this is their count (the size of the RHIShaders array). This does not count actually created RHI shaders, just the size of the above array of pointers to them. */
	uint32 NumRHIShaders : 31;

	/** Whether we have at least one RHI shader created. */
	uint32 bAtLeastOneRHIShaderCreated : 1;

	EShaderPlatform Platform;

	/** The number of references to this shader map. */
	std::atomic<int32> NumRefs;
};

class FShaderMapResourceCode : public FThreadSafeRefCountedObject
{
public:
	struct UE_DEPRECATED(5.5, "Use FShaderCodeResource") FShaderEntry
	{
		TArray<uint8> Code;
		int32 UncompressedSize;
		EShaderFrequency Frequency;

		friend FArchive& operator<<(FArchive& Ar, FShaderEntry& Entry)
		{
			uint8 Freq = Entry.Frequency;
			Ar << Entry.Code << Entry.UncompressedSize << Freq;
			Entry.Frequency = (EShaderFrequency)Freq;
			return Ar;
		}
	};

#if WITH_EDITORONLY_DATA
	struct FShaderEditorOnlyDataEntry
	{
		TArray<uint8> PlatformDebugData;

		/** This field contains a debug string stored in a ShaderSymbols.info file when using r.Shaders.SymbolInfo=1
		*   Used to facilitate reverse lookup of a shader from a platform shader hash when no full shader symbol 
		*   information is available */
		FString DebugInfo;

		/** A (deduplicated/sorted) array of all the compiler warnings that were emitted when all shaders resulting 
		 *  in the associated bytecode were compiled (i.e. if multiple shader sources have warnings but compile to
		 *  the same code, all warnings for each unique source will be reported).
		 *  Does not contain errors since if there were any errors, this object wouldn't exist. */
		TArray<FString> CompilerWarnings;

		/** Generic, data-driven key/value pairs of statistics. */
		TArray<FGenericShaderStat> ShaderStatistics;

		friend FArchive& operator<<(FArchive& Ar, FShaderEditorOnlyDataEntry& Entry)
		{
			return Ar << Entry.PlatformDebugData << Entry.DebugInfo << Entry.CompilerWarnings << Entry.ShaderStatistics;
		}
	};
#endif // WITH_EDITORONLY_DATA

	FShaderMapResourceCode() {}
	RENDERCORE_API FShaderMapResourceCode(const FShaderMapResourceCode& Other);
    RENDERCORE_API ~FShaderMapResourceCode();

	RENDERCORE_API void Finalize();

	UE_DEPRECATED(5.5, "Use overload accepting an FShaderSerializeContext object")
		void Serialize(FArchive& Ar, bool bLoadingCooked)
	{
		FShaderSerializeContext Ctx(Ar);
		Ctx.bLoadingCooked = bLoadingCooked;
		Serialize(Ctx);
	}

	RENDERCORE_API void Serialize(FShaderSerializeContext& Ctx);
#if WITH_EDITORONLY_DATA
	RENDERCORE_API void NotifyShadersCompiled(FName FormatName);
#endif // WITH_EDITORONLY_DATA

	RENDERCORE_API uint32 GetSizeBytes() const;

	RENDERCORE_API void AddShaderCompilerOutput(const FShaderCompilerOutput& Output, const FString& DebugName = FString(), FString DebugInfo = FString());

	int32 FindShaderIndex(const FSHAHash& InHash) const;

#if WITH_EDITORONLY_DATA
	void AddEditorOnlyData(int32 Index, const FString& DebugName, TConstArrayView<uint8> InPlatformDebugData, TConstArrayView<FShaderCompilerError> InCompilerWarnings, const TArray<FGenericShaderStat>& ShaderStatistics, const FString& DebugInfo = FString());
	void UpdateEditorOnlyData(int32 Index, const FString& DebugName, TConstArrayView<FShaderCompilerError> InCompilerWarnings, const FString& DebugInfo);

	RENDERCORE_API void LogShaderCompilerWarnings();
#endif

	RENDERCORE_API void ToString(FStringBuilderBase& OutString) const;

	/** A hash describing the total contents of *this. Constructed from the contents of ShaderHashes during Finalize. */
	FSHAHash ResourceHash;
	TArray<FSHAHash> ShaderHashes;

	UE_DEPRECATED(5.5, "Use ShaderCodeResources") 
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	TArray<FShaderEntry> ShaderEntries;
	PRAGMA_ENABLE_DEPRECATION_WARNINGS

	TArray<FShaderCodeResource> ShaderCodeResources;
#if WITH_EDITORONLY_DATA
	// Optional array of editor-only data indexed in the same order as ShaderEntries (sorted by the shader hash)
	// Empty in the cases where the editor-only data is not serialized.
	TArray<FShaderEditorOnlyDataEntry> ShaderEditorOnlyDataEntries;

private:
	// Given an existing shader entry and a new set of shader statistics determine if the shader stats match.
	// This is to prevent non-determinism issues.
	void ValidateShaderStatisticsEditorOnlyData(int32 Index, const TArray<FGenericShaderStat>& ShaderStatistics);
#endif // WITH_EDITORONLY_DATA
};
	
class FShaderMapResource_InlineCode : public FShaderMapResource
{
public:
	FShaderMapResource_InlineCode(EShaderPlatform InPlatform, FShaderMapResourceCode* InCode)
		: FShaderMapResource(InPlatform, InCode->ShaderCodeResources.Num())
		, Code(InCode)
	{}

	// FShaderMapResource interface
	RENDERCORE_API virtual FSHAHash GetShaderHash(int32 ShaderIndex) override;
	RENDERCORE_API virtual FRHIShader* CreateRHIShaderOrCrash(int32 ShaderIndex, bool bRequired) override;
	RENDERCORE_API virtual FString GetFriendlyName() const override { return TEXT("InlineCode"); }
	virtual uint32 GetSizeBytes() const override;

	TRefCountPtr<FShaderMapResourceCode> Code;
};

class FShaderMapPointerTable : public FPointerTableBase
{
public:
	RENDERCORE_API virtual int32 AddIndexedPointer(const FTypeLayoutDesc& TypeDesc, void* Ptr) override;
	RENDERCORE_API virtual void* GetIndexedPointer(const FTypeLayoutDesc& TypeDesc, uint32 i) const override;

	virtual FShaderMapPointerTable* Clone() const { return new FShaderMapPointerTable(*this); }

	RENDERCORE_API virtual void SaveToArchive(FArchive& Ar, const FPlatformTypeLayoutParameters& LayoutParams, const void* FrozenObject) const override;
	RENDERCORE_API virtual bool LoadFromArchive(FArchive& Ar, const FPlatformTypeLayoutParameters& LayoutParams, void* FrozenObject) override;

	TPtrTable<FShaderType> ShaderTypes;
	TPtrTable<FVertexFactoryType> VFTypes;
};

/** Encapsulates information about a shader's serialization behavior, used to detect when C++ serialization changes to auto-recompile. */

class UE_DEPRECATED(5.4, "FSerializationHistory is no longer used and will be removed") FSerializationHistory 
{
public: 

	/** Token stream stored as uint32's.  Each token is 4 bits, with a 0 meaning there's an associated 32 bit value in FullLengths. */
	TArray<uint32> TokenBits;

	/** Number of tokens in TokenBits. */
	int32 NumTokens;

	/** Full size length entries. One of these are used for every token with a value of 0. */
	TArray<uint32> FullLengths;

	FSerializationHistory() :
		NumTokens(0)
	{}

	FORCEINLINE void AddValue(uint32 InValue)
	{
		const int32 UIntIndex = NumTokens / 8; 

		if (UIntIndex >= TokenBits.Num())
		{
			// Add another uint32 if needed
			TokenBits.AddZeroed();
		}

		uint8 Token;

		// Anything that does not fit in 4 bits needs to go into FullLengths, with a special token value of 0
		// InValue == 0 also should go into FullLengths, because its Token value is also 0
		if (InValue > 7 || InValue == 0)
		{
			Token = 0;
			FullLengths.Add(InValue);
		}
		else
		{
			Token = (uint8)InValue;
		}

		const uint32 Shift = (NumTokens % 8) * 4;
		// Add the new token bits into the existing uint32
		TokenBits[UIntIndex] = TokenBits[UIntIndex] | (Token << Shift);
		NumTokens++;
	}

	FORCEINLINE uint8 GetToken(int32 Index) const
	{
		checkSlow(Index < NumTokens);
		const int32 UIntIndex = Index / 8; 
		checkSlow(UIntIndex < TokenBits.Num());
		const uint32 Shift = (Index % 8) * 4;
		const uint8 Token = (TokenBits[UIntIndex] >> Shift) & 0xF;
		return Token;
	}

	void AppendKeyString(FString& KeyString) const
	{
		KeyString += FString::FromInt(NumTokens);
		KeyString += BytesToHex((uint8*)TokenBits.GetData(), TokenBits.Num() * TokenBits.GetTypeSize());
		KeyString += BytesToHex((uint8*)FullLengths.GetData(), FullLengths.Num() * FullLengths.GetTypeSize());
	}

	inline bool operator==(const FSerializationHistory& Other) const
	{
		return TokenBits == Other.TokenBits && NumTokens == Other.NumTokens && FullLengths == Other.FullLengths;
	}

	friend FArchive& operator<<(FArchive& Ar,class FSerializationHistory& Ref)
	{
		Ar << Ref.TokenBits << Ref.NumTokens << Ref.FullLengths;
		return Ar;
	}
};

class FShaderKey
{
public:
	inline FShaderKey(const FSHAHash& InMaterialShaderMapHash, const FShaderPipelineType* InShaderPipeline, FVertexFactoryType* InVertexFactoryType, int32 PermutationId, EShaderPlatform InPlatform)
		: VertexFactoryType(InVertexFactoryType)
		, ShaderPipeline(InShaderPipeline)
		, MaterialShaderMapHash(InMaterialShaderMapHash)
		, PermutationId(PermutationId)
		, Platform(InPlatform)
	{}

	friend inline uint32 GetTypeHash(const FShaderKey& Id)
	{
		return
			HashCombine(
				HashCombine(*(uint32*)&Id.MaterialShaderMapHash, GetTypeHash(Id.Platform)),
				HashCombine(GetTypeHash(Id.VertexFactoryType), uint32(Id.PermutationId)));
	}

	friend bool operator==(const FShaderKey& X, const FShaderKey& Y)
	{
		return X.MaterialShaderMapHash == Y.MaterialShaderMapHash
			&& X.ShaderPipeline == Y.ShaderPipeline
			&& X.VertexFactoryType == Y.VertexFactoryType
			&& X.PermutationId == Y.PermutationId
			&& X.Platform == Y.Platform;
	}

	RENDERCORE_API friend FArchive& operator<<(FArchive& Ar, FShaderKey& Ref);

	FVertexFactoryType* VertexFactoryType;
	const FShaderPipelineType* ShaderPipeline;
	FSHAHash MaterialShaderMapHash;
	int32 PermutationId;
	uint32 Platform : SP_NumBits;
};

/** 
 * Uniquely identifies an FShader instance.  
 * Used to link FMaterialShaderMaps and FShaders on load. 
 */
class FShaderId
{
public:
	inline FShaderId() {}
	inline FShaderId(const FShaderType* InType, const FSHAHash& InMaterialShaderMapHash, const FHashedName& InShaderPipeline, const FVertexFactoryType* InVertexFactoryType, int32 InPermutationId, EShaderPlatform InPlatform)
		: Type(InType)
		, VFType(InVertexFactoryType)
		, ShaderPipelineName(InShaderPipeline)
		, MaterialShaderMapHash(InMaterialShaderMapHash)
		, PermutationId(InPermutationId)
		, Platform(InPlatform)
	{}

	const FShaderType* Type;
	const FVertexFactoryType* VFType;
	FHashedName ShaderPipelineName;
	FSHAHash MaterialShaderMapHash;
	int32 PermutationId;
	uint32 Platform : SP_NumBits;

	friend inline uint32 GetTypeHash( const FShaderId& Id )
	{
		return HashCombine(
			GetTypeHash(Id.Type),
			HashCombine(GetTypeHash(Id.VFType),
				HashCombine(GetTypeHash(Id.ShaderPipelineName),
					HashCombine(GetTypeHash(Id.MaterialShaderMapHash),
						HashCombine(GetTypeHash(Id.PermutationId), GetTypeHash(Id.Platform))))));
	}

	friend bool operator==(const FShaderId& X, const FShaderId& Y)
	{
		return X.Type == Y.Type
			&& X.MaterialShaderMapHash == Y.MaterialShaderMapHash
			&& X.ShaderPipelineName == Y.ShaderPipelineName
			&& X.VFType == Y.VFType
			&& X.PermutationId == Y.PermutationId 
			&& X.Platform == Y.Platform;
	}

	friend bool operator!=(const FShaderId& X, const FShaderId& Y)
	{
		return !(X == Y);
	}
};

class FMaterial;

/**
 * Stores all shader parameter bindings and their corresponding offset and size in the shader's parameters struct.
 */
class FShaderParameterBindings
{
public:
	struct FParameter
	{
		DECLARE_INLINE_TYPE_LAYOUT(FParameter, NonVirtual);

		LAYOUT_FIELD(uint16, BufferIndex);
		LAYOUT_FIELD(uint16, BaseIndex);
		LAYOUT_FIELD(uint16, ByteOffset);
		LAYOUT_FIELD(uint16, ByteSize);
	};

	struct FResourceParameter
	{
		DECLARE_INLINE_TYPE_LAYOUT(FResourceParameter, NonVirtual);		
		LAYOUT_FIELD(uint16, ByteOffset);
		LAYOUT_FIELD(uint8, BaseIndex);
		LAYOUT_FIELD(EUniformBufferBaseType, BaseType);
	};

	struct FBindlessResourceParameter
	{
		DECLARE_INLINE_TYPE_LAYOUT(FBindlessResourceParameter, NonVirtual);
		LAYOUT_FIELD(uint16, ByteOffset);
		LAYOUT_FIELD(uint16, GlobalConstantOffset);
		LAYOUT_FIELD(EUniformBufferBaseType, BaseType);
	};

	struct FParameterStructReference
	{
		DECLARE_INLINE_TYPE_LAYOUT(FParameterStructReference, NonVirtual);
		LAYOUT_FIELD(uint16, BufferIndex);
		LAYOUT_FIELD(uint16, ByteOffset);
	};

	DECLARE_EXPORTED_TYPE_LAYOUT(FShaderParameterBindings, RENDERCORE_API, NonVirtual);
public:
	static constexpr uint16 kInvalidBufferIndex = 0xFFFF;

	RENDERCORE_API void BindForLegacyShaderParameters(const FShader* Shader, int32 PermutationId, const FShaderParameterMap& ParameterMaps, const FShaderParametersMetadata& StructMetaData, bool bShouldBindEverything = false);
	RENDERCORE_API void BindForRootShaderParameters(const FShader* Shader, int32 PermutationId, const FShaderParameterMap& ParameterMaps);

	LAYOUT_FIELD(TMemoryImageArray<FParameter>, Parameters);
	LAYOUT_FIELD(TMemoryImageArray<FResourceParameter>, ResourceParameters);
	LAYOUT_FIELD(TMemoryImageArray<FBindlessResourceParameter>, BindlessResourceParameters);
	LAYOUT_FIELD(TMemoryImageArray<FParameterStructReference>, GraphUniformBuffers);
	LAYOUT_FIELD(TMemoryImageArray<FParameterStructReference>, ParameterReferences);

	// Hash of the shader parameter structure when doing the binding.
	LAYOUT_FIELD_INITIALIZED(uint32, StructureLayoutHash, 0);

	// Buffer index of FShaderParametersMetadata::kRootUniformBufferBindingName
	LAYOUT_FIELD_INITIALIZED(uint16, RootParameterBufferIndex, FShaderParameterBindings::kInvalidBufferIndex);

}; // FShaderParameterBindings

inline int16 GetParameterIndex(const FShaderParameterBindings::FResourceParameter& Parameter) { return Parameter.BaseIndex; }
inline int16 GetParameterIndex(const FShaderParameterBindings::FBindlessResourceParameter& Parameter) { return Parameter.GlobalConstantOffset; }
inline int16 GetParameterIndex(const FShaderParameterBindings::FParameterStructReference& Parameter) { return Parameter.BufferIndex; }

// Flags that can specialize shader permutations compiled for specific platforms
enum class EShaderPermutationFlags : uint32
{
	None = 0u,
	HasEditorOnlyData = (1u << 0),
};
ENUM_CLASS_FLAGS(EShaderPermutationFlags);

enum class EShaderPermutationPrecacheRequest : uint8
{
	Precached,			//< Permutation should be precached because it can be used at runtime
	NotPrecached,		//< Permutation doesn't have to be precached (debug feature only for example)
	NotUsed,			//< Permutation is not used with current cvar/configuration/feature level
};

RENDERCORE_API EShaderPermutationFlags GetShaderPermutationFlags(const FPlatformTypeLayoutParameters& LayoutParams);

struct FShaderPermutationParameters
{
	// Shader platform to compile to.
	const EShaderPlatform Platform;

	// Unique permutation identifier of the material shader type.
	const int32 PermutationId;

	// Flags that describe the permutation
	const EShaderPermutationFlags Flags;

	// Default to include editor-only shaders, to maintain backwards-compatibility
	explicit FShaderPermutationParameters(EShaderPlatform InPlatform, int32 InPermutationId = 0, EShaderPermutationFlags InFlags = EShaderPermutationFlags::HasEditorOnlyData)
		: Platform(InPlatform)
		, PermutationId(InPermutationId)
		, Flags(InFlags)
	{}
};

namespace Freeze
{
	RENDERCORE_API void IntrinsicToString(const TIndexedPtr<FShaderType>& Object, const FTypeLayoutDesc& TypeDesc, const FPlatformTypeLayoutParameters& LayoutParams, FMemoryToStringContext& OutContext);
	RENDERCORE_API void IntrinsicToString(const TIndexedPtr<FVertexFactoryType>& Object, const FTypeLayoutDesc& TypeDesc, const FPlatformTypeLayoutParameters& LayoutParams, FMemoryToStringContext& OutContext);
}

DECLARE_EXPORTED_TEMPLATE_INTRINSIC_TYPE_LAYOUT(template<>, TIndexedPtr<FShaderType>, RENDERCORE_API);
DECLARE_EXPORTED_TEMPLATE_INTRINSIC_TYPE_LAYOUT(template<>, TIndexedPtr<FVertexFactoryType>, RENDERCORE_API);

/** A compiled shader and its parameter bindings. */
class FShader
{
	friend class FShaderType;
	DECLARE_EXPORTED_TYPE_LAYOUT(FShader, RENDERCORE_API, NonVirtual);
public:
	using FPermutationDomain = FShaderPermutationNone;
	using FPermutationParameters = FShaderPermutationParameters;
	using CompiledShaderInitializerType = FShaderCompiledShaderInitializerType;
	using ShaderMetaType = FShaderType;
	using ShaderStatKeyType = FMemoryImageName;
	using FShaderStatisticMap = TMemoryImageMap<ShaderStatKeyType, FShaderStatVariant>;

	/** 
	 * Used to construct a shader for deserialization.
	 * This still needs to initialize members to safe values since FShaderType::GenerateSerializationHistory uses this constructor.
	 */
	RENDERCORE_API FShader();

	/**
	 * Construct a shader from shader compiler output.
	 */
	RENDERCORE_API FShader(const CompiledShaderInitializerType& Initializer);

	RENDERCORE_API ~FShader();

	/** Can be overridden by FShader subclasses to modify their compile environment just before compilation occurs. */
	static void ModifyCompilationEnvironment(const FShaderPermutationParameters&, FShaderCompilerEnvironment&) {}

	/**	Get shader binding layout used by the shader */
	static const FShaderBindingLayout* GetShaderBindingLayout(const FShaderPermutationParameters&) { return nullptr; }

	/** Can be overridden by FShader subclasses to determine whether a specific permutation should be compiled. */
	static bool ShouldCompilePermutation(const FShaderPermutationParameters&) { return true; }

	/** Can be overridden by FShader subclasses to determine whether a specific permutation should be precached. */
	static EShaderPermutationPrecacheRequest ShouldPrecachePermutation(const FShaderPermutationParameters& Parameters) { return EShaderPermutationPrecacheRequest::Precached; }

	/** Can be overridden by FShader subclasses to determine whether compilation is valid. */
	static bool ValidateCompiledResult(EShaderPlatform InPlatform, const FShaderParameterMap& InParameterMap, TArray<FString>& OutError) { return true; }

	/** Can be overriden by FShader subclasses to specify which raytracing payload should be used. This method is only called for raytracing shaders. */
	static ERayTracingPayloadType GetRayTracingPayloadType(const int32 PermutationId) { return static_cast<ERayTracingPayloadType>(0); }

	/** Returns the hash of the shader file that this shader was compiled with. */
	RENDERCORE_API const FSHAHash& GetHash() const;

	RENDERCORE_API const FSHAHash& GetVertexFactoryHash() const;
	
	RENDERCORE_API const FSHAHash& GetOutputHash() const;

	/** Returns an identifier suitable for deterministic sorting of shaders between sessions. */
	uint32 GetSortKey() const { return SortKey; }

	RENDERCORE_API void Finalize(const FShaderMapResourceCode* Code);

	// Accessors.
	inline FShaderType* GetType(const FShaderMapPointerTable& InPointerTable) const { return Type.Get(InPointerTable.ShaderTypes); }
	inline FShaderType* GetType(const FPointerTableBase* InPointerTable) const { return Type.Get(InPointerTable); }
	inline FVertexFactoryType* GetVertexFactoryType(const FShaderMapPointerTable& InPointerTable) const { return VFType.Get(InPointerTable.VFTypes); }
	inline FVertexFactoryType* GetVertexFactoryType(const FPointerTableBase* InPointerTable) const { return VFType.Get(InPointerTable); }
	inline FShaderType* GetTypeUnfrozen() const { return Type.GetUnfrozen(); }
	inline int32 GetResourceIndex() const { checkSlow(ResourceIndex != INDEX_NONE); return ResourceIndex; }
	inline EShaderPlatform GetShaderPlatform() const { return Target.GetPlatform(); }
	inline EShaderFrequency GetFrequency() const { return Target.GetFrequency(); }
	inline const FShaderTarget GetTarget() const { return Target; }
	inline bool IsFrozen() const { return Type.IsFrozen(); }
	inline uint32 GetNumInstructions() const { return NumInstructions; }

#if WITH_EDITORONLY_DATA
	inline uint32 GetNumTextureSamplers() const { return NumTextureSamplers; }
	inline uint32 GetCodeSize() const { return CodeSize; }
	inline void SetNumInstructions(uint32 Value) { NumInstructions = Value; }
	UE_DEPRECATED(5.5, "GetShaderStatistics which returns a reference to the stat map is deprecated. Shader Stats can be accessed on the editor only data on the FShaderMapResourceCode object.")
	inline const FShaderStatisticMap& GetShaderStatistics() const
	{
		static FShaderStatisticMap DummyStatMap;
		return DummyStatMap;
	}
#else
	inline uint32 GetNumTextureSamplers() const { return 0u; }
	inline uint32 GetCodeSize() const { return 0u; }
#endif

	/** Finds an automatically bound uniform buffer matching the given uniform buffer type if one exists, or returns an unbound parameter. */
	template<typename UniformBufferStructType>
	FORCEINLINE_DEBUGGABLE const TShaderUniformBufferParameter<UniformBufferStructType>& GetUniformBufferParameter() const
	{
		const FShaderUniformBufferParameter& FoundParameter = GetUniformBufferParameter(UniformBufferStructType::FTypeInfo::GetStructMetadata());
		return static_cast<const TShaderUniformBufferParameter<UniformBufferStructType>&>(FoundParameter);
	}

	/** Finds an automatically bound uniform buffer matching the given uniform buffer struct if one exists, or returns an unbound parameter. */
	FORCEINLINE_DEBUGGABLE const FShaderUniformBufferParameter& GetUniformBufferParameter(const FShaderParametersMetadata* SearchStruct) const
	{
		const FHashedName SearchName = SearchStruct->GetShaderVariableHashedName();
		
		return GetUniformBufferParameter(SearchName);
	}

	/** Finds an automatically bound uniform buffer matching the HashedName if one exists, or returns an unbound parameter. */
	FORCEINLINE_DEBUGGABLE const FShaderUniformBufferParameter& GetUniformBufferParameter(const FHashedName SearchName) const
	{
		int32 FoundIndex = INDEX_NONE;
		TArrayView<const FHashedName> UniformBufferParameterStructsView(UniformBufferParameterStructs);
		for (int32 StructIndex = 0, Count = UniformBufferParameterStructsView.Num(); StructIndex < Count; StructIndex++)
		{
			if (UniformBufferParameterStructsView[StructIndex] == SearchName)
			{
				FoundIndex = StructIndex;
				break;
			}
		}

		if (FoundIndex != INDEX_NONE)
		{
			const FShaderUniformBufferParameter& FoundParameter = UniformBufferParameters[FoundIndex];
			return FoundParameter;
		}
		else
		{
			// This can happen if the uniform buffer was not bound
			// There's no good way to distinguish not being bound due to temporary debugging / compiler optimizations or an actual code bug,
			// Hence failing silently instead of an error message
			static FShaderUniformBufferParameter UnboundParameter;
			return UnboundParameter;
		}
	}

	RENDERCORE_API const FShaderParametersMetadata* FindAutomaticallyBoundUniformBufferStruct(int32 BaseIndex) const;

	RENDERCORE_API void DumpDebugInfo(const FShaderMapPointerTable& InPtrTable);

#if WITH_EDITOR
	RENDERCORE_API void SaveShaderStableKeys(const FShaderMapPointerTable& InPtrTable, EShaderPlatform TargetShaderPlatform, int32 PermutationId, const struct FStableShaderKeyAndValue& SaveKeyVal);
#endif // WITH_EDITOR

	/** Returns the meta data for the root shader parameter struct. */
	static inline const FShaderParametersMetadata* GetRootParametersMetadata()
	{
		return nullptr;
	}

private:
	RENDERCORE_API void BuildParameterMapInfo(const TMap<FString, FParameterAllocation>& ParameterMap);

public:
	LAYOUT_FIELD(FShaderParameterBindings, Bindings);
	LAYOUT_FIELD(FShaderParameterMapInfo, ParameterMapInfo);

protected:
	LAYOUT_FIELD(TMemoryImageArray<FHashedName>, UniformBufferParameterStructs);
	LAYOUT_FIELD(TMemoryImageArray<FShaderUniformBufferParameter>, UniformBufferParameters);

	/**
	* Hash of the compiled output from this shader and the resulting parameter map.
	* This is used to find a matching resource.
	*/
	LAYOUT_FIELD_EDITORONLY(FSHAHash, OutputHash);

	/** Vertex factory source hash, stored so that an FShaderId can be constructed from this shader. */
	LAYOUT_FIELD_EDITORONLY(FSHAHash, VFSourceHash);

	/** Hash of this shader's source files generated at compile time, and stored to allow creating an FShaderId. */
	LAYOUT_FIELD_EDITORONLY(FSHAHash, SourceHash);

private:
	LAYOUT_FIELD(TIndexedPtr<FShaderType>, Type);

	LAYOUT_FIELD(TIndexedPtr<FVertexFactoryType>, VFType);

	/** Target platform and frequency. */
	LAYOUT_FIELD(FShaderTarget, Target);

	/** Index of this shader within the FShaderMapResource */
	LAYOUT_FIELD(int32, ResourceIndex);

	/** The number of instructions the shader takes to execute. */
	LAYOUT_FIELD(uint32, NumInstructions);

	/** Truncated version of OutputHash, intended for sorting. Not suitable for unique shader identification. */
	LAYOUT_FIELD(uint32, SortKey);

	/** Number of texture samplers the shader uses. */
	LAYOUT_FIELD_EDITORONLY(uint32, NumTextureSamplers);

	/** Size of shader's compiled code */
	LAYOUT_FIELD_EDITORONLY(uint32, CodeSize);
};

RENDERCORE_API const FTypeLayoutDesc& GetTypeLayoutDesc(const FPointerTableBase* PtrTable, const FShader& Shader);

template<typename ShaderType, typename PointerTableType>
class TShaderRefBase
{
public:
	TShaderRefBase() : ShaderContent(nullptr), ShaderMap(nullptr) {}
	TShaderRefBase(ShaderType* InShader, const FShaderMapBase& InShaderMap) : ShaderContent(InShader), ShaderMap(&InShaderMap) { checkSlow(InShader); }
	TShaderRefBase(const TShaderRefBase&) = default;

	template<typename OtherShaderType, typename OtherPointerTableType>
	TShaderRefBase(const TShaderRefBase<OtherShaderType, OtherPointerTableType>& Rhs) : ShaderContent(Rhs.GetShader()), ShaderMap(Rhs.GetShaderMap()) {}

	TShaderRefBase& operator=(const TShaderRefBase&) = default;

	template<typename OtherShaderType, typename OtherPointerTableType>
	TShaderRefBase& operator=(const TShaderRefBase<OtherShaderType, OtherPointerTableType>& Rhs)
	{
		ShaderContent = Rhs.GetShader();
		ShaderMap = Rhs.GetShaderMap();
		return *this;
	}

	template<typename OtherShaderType, typename OtherPointerTableType>
	static TShaderRefBase<ShaderType, PointerTableType> Cast(const TShaderRefBase<OtherShaderType, OtherPointerTableType>& Rhs)
	{
		return TShaderRefBase<ShaderType, PointerTableType>(static_cast<ShaderType*>(Rhs.GetShader()), Rhs.GetShaderMap());
	}

	template<typename OtherShaderType, typename OtherPointerTableType>
	static TShaderRefBase<ShaderType, PointerTableType> ReinterpretCast(const TShaderRefBase<OtherShaderType, OtherPointerTableType>& Rhs)
	{
		return TShaderRefBase<ShaderType, PointerTableType>(reinterpret_cast<ShaderType*>(Rhs.GetShader()), Rhs.GetShaderMap());
	}

	inline bool IsValid() const { return ShaderContent != nullptr; }
	inline bool IsNull() const { return ShaderContent == nullptr; }

	inline void Reset() { ShaderContent = nullptr; ShaderMap = nullptr; }

	inline ShaderType* GetShader() const { return ShaderContent; }
	inline const FShaderMapBase* GetShaderMap() const { return ShaderMap; }
	inline const FShaderMapBase& GetShaderMapChecked() const { check(ShaderMap); return *ShaderMap; }
	inline FShaderType* GetType() const { return ShaderContent->GetType(GetPointerTable()); }
	inline FVertexFactoryType* GetVertexFactoryType() const { return ShaderContent->GetVertexFactoryType(GetPointerTable()); }
	inline FShaderMapResource& GetResourceChecked() const { FShaderMapResource* Resource = GetResource(); check(Resource); return *Resource; }
	const PointerTableType& GetPointerTable() const;
	FShaderMapResource* GetResource() const;

	inline ShaderType* operator->() const { return ShaderContent; }

	inline FRHIShader* GetRHIShaderBase(EShaderFrequency Frequency, bool bRequired = true) const
	{
		FRHIShader* RHIShader = nullptr;
		if(ShaderContent)
		{
			checkSlow(ShaderContent->GetFrequency() == Frequency);
			RHIShader = GetResourceChecked().GetShader(ShaderContent->GetResourceIndex(), bRequired);
			if (RHIShader == nullptr)
			{
				UE_LOG(LogShaders, Log, TEXT("Failed to create shader for type %s with resource index %d."), GetType()->GetName(), ShaderContent->GetResourceIndex());
				return nullptr;
			}
			checkSlow(RHIShader->GetFrequency() == Frequency);
		}
		return RHIShader;
	}

	inline FRHIGraphicsShader* GetGraphicsShader(bool bRequired = true) const
	{
		FRHIGraphicsShader* RHIShader = nullptr;
		if(ShaderContent)
		{
			checkSlow(IsValidGraphicsFrequency(ShaderContent->GetFrequency()));
			RHIShader = static_cast<FRHIGraphicsShader*>(GetResourceChecked().GetShader(ShaderContent->GetResourceIndex(), bRequired));
			if (RHIShader == nullptr)
			{
				UE_LOG(LogShaders, Log, TEXT("Failed to create shader for type %s with resource index %d."), GetType()->GetName(), ShaderContent->GetResourceIndex());
				return nullptr;
			}
			checkSlow(IsValidGraphicsFrequency(RHIShader->GetFrequency()));
		}
		return RHIShader;
	}

	/** @return the shader's vertex shader */
	inline FRHIVertexShader* GetVertexShader(bool bRequired = true) const
	{
		return static_cast<FRHIVertexShader*>(GetRHIShaderBase(SF_Vertex, bRequired));
	}
	/** @return the shader's mesh shader */
	inline FRHIMeshShader* GetMeshShader() const
	{
		return static_cast<FRHIMeshShader*>(GetRHIShaderBase(SF_Mesh));
	}
	/** @return the shader's aplification shader */
	inline FRHIAmplificationShader* GetAmplificationShader() const
	{
		return static_cast<FRHIAmplificationShader*>(GetRHIShaderBase(SF_Amplification));
	}
	/** @return the shader's pixel shader */
	inline FRHIPixelShader* GetPixelShader(bool bRequired = true) const
	{
		return static_cast<FRHIPixelShader*>(GetRHIShaderBase(SF_Pixel, bRequired));
	}
	/** @return the shader's geometry shader */
	inline FRHIGeometryShader* GetGeometryShader() const
	{
		return static_cast<FRHIGeometryShader*>(GetRHIShaderBase(SF_Geometry));
	}
	/** @return the shader's compute shader */
	inline FRHIComputeShader* GetComputeShader() const
	{
		return static_cast<FRHIComputeShader*>(GetRHIShaderBase(SF_Compute));
	}
	/** @return the shader's work graph shader */
	inline FRHIWorkGraphShader* GetWorkGraphShader() const
	{
		FRHIWorkGraphShader* RHIShader = nullptr;
		if (ShaderContent)
		{
			const EShaderFrequency Frequency = ShaderContent->GetFrequency();
			checkSlow(Frequency == SF_WorkGraphRoot || Frequency == SF_WorkGraphComputeNode);
			RHIShader = static_cast<FRHIWorkGraphShader*>(GetRHIShaderBase(Frequency));
		}
		return RHIShader;
	}

#if RHI_RAYTRACING
	inline FRHIRayTracingShader* GetRayTracingShader() const
	{
		FRHIRayTracingShader* RHIShader = nullptr;
		if(ShaderContent)
		{
			const EShaderFrequency Frequency = ShaderContent->GetFrequency();
			checkSlow(Frequency == SF_RayGen
				|| Frequency == SF_RayMiss
				|| Frequency == SF_RayHitGroup
				|| Frequency == SF_RayCallable);
			RHIShader = static_cast<FRHIRayTracingShader*>(GetResourceChecked().GetShader(ShaderContent->GetResourceIndex()));
			checkSlow(RHIShader->GetFrequency() == Frequency);
		}
		return RHIShader;
	}

	UE_DEPRECATED(5.1, "GetRayTracingMaterialLibraryIndex is deprecated. Use GetRayTracingHitGroupLibraryIndex instead.")
	inline uint32 GetRayTracingMaterialLibraryIndex() const
	{
		return GetRayTracingHitGroupLibraryIndex();
	}

	inline uint32 GetRayTracingHitGroupLibraryIndex() const
	{
		checkSlow(ShaderContent);
		checkSlow(ShaderContent->GetFrequency() == SF_RayHitGroup);
		return GetResourceChecked().GetRayTracingHitGroupLibraryIndex(ShaderContent->GetResourceIndex());
	}

	inline uint32 GetRayTracingCallableShaderLibraryIndex() const
	{
		checkSlow(ShaderContent);
		checkSlow(ShaderContent->GetFrequency() == SF_RayCallable);
		return GetResourceChecked().GetRayTracingCallableShaderLibraryIndex(ShaderContent->GetResourceIndex());
	}

	inline uint32 GetRayTracingMissShaderLibraryIndex() const
	{
		checkSlow(ShaderContent);
		checkSlow(ShaderContent->GetFrequency() == SF_RayMiss);
		return GetResourceChecked().GetRayTracingMissShaderLibraryIndex(ShaderContent->GetResourceIndex());
	}
#endif // RHI_RAYTRACING

private:
	TShaderRefBase(ShaderType* InShader, const FShaderMapBase* InShaderMap)
		: ShaderContent(InShader), ShaderMap(InShaderMap)
	{
		checkSlow((!InShader && !InShaderMap) || (InShader && InShaderMap));
	}

	ShaderType* ShaderContent;
	const FShaderMapBase* ShaderMap;

	template<typename ShaderType1>
	friend inline bool operator==(const TShaderRefBase& Lhs, const TShaderRefBase<ShaderType1, PointerTableType>& Rhs)
	{
		if (Lhs.GetShader() == Rhs.GetShader())
		{
			check(Lhs.GetShaderMap() == Rhs.GetShaderMap());
			return true;
		}
		return false;
	}

	template<typename ShaderType1>
	friend inline bool operator!=(const TShaderRefBase& Lhs, const TShaderRefBase<ShaderType1, PointerTableType>& Rhs)
	{
		return !operator==(Lhs, Rhs);
	}

};

template<typename ShaderType>
using TShaderRef = TShaderRefBase<ShaderType, FShaderMapPointerTable>;

/**
 * An object which is used to serialize/deserialize, compile, and cache a particular shader class.
 *
 * A shader type can manage multiple instance of FShader across mutiple dimensions such as EShaderPlatform, or permutation id.
 * The number of permutation of a shader type is simply given by GetPermutationCount().
 */
class FShaderType
{
public:
	enum class EShaderTypeForDynamicCast : uint32
	{
		Global,
		Material,
		MeshMaterial,
		Niagara,
		OCIO,
		ComputeKernel,
		NumShaderTypes,
	};

	/**
	 * Derived FShaderTypes should derive from this class to pass params to FShader constructor
	 */
	class FParameters
	{
	public:
		virtual ~FParameters(){}
	};

	typedef class FShader* (*ConstructSerializedType)();
	typedef FShader* (*ConstructCompiledType)(const FShader::CompiledShaderInitializerType& Initializer);
	typedef bool (*ShouldCompilePermutationType)(const FShaderPermutationParameters&);
	typedef EShaderPermutationPrecacheRequest (*ShouldPrecachePermutationType)(const FShaderPermutationParameters&);
	typedef ERayTracingPayloadType(*GetRayTracingPayloadTypeType)(const int32 PermutationId);
	typedef const FShaderBindingLayout*(*GetShaderBindingLayoutType)(const FShaderPermutationParameters&);
#if WITH_EDITOR
	typedef void (*ModifyCompilationEnvironmentType)(const FShaderPermutationParameters&, FShaderCompilerEnvironment&);
	typedef bool (*ValidateCompiledResultType)(EShaderPlatform, const FShaderParameterMap&, TArray<FString>&);
#endif // WITH_EDITOR

	/** @return The global shader factory list. */
	static RENDERCORE_API TLinkedList<FShaderType*>*& GetTypeList();

	static RENDERCORE_API FShaderType* GetShaderTypeByName(const TCHAR* Name);
	static RENDERCORE_API TArray<const FShaderType*> GetShaderTypesByFilename(const TCHAR* Filename);

	/** @return The global shader name to type map */
	static RENDERCORE_API TMap<FHashedName, FShaderType*>& GetNameToTypeMap();

	static RENDERCORE_API const TArray<FShaderType*>& GetSortedTypes(EShaderTypeForDynamicCast Type);

	/** Initialize FShaderType static members, this must be called before any shader types are created. */
	static RENDERCORE_API void Initialize(const TMap<FString, TArray<const TCHAR*> >& ShaderFileToUniformBufferVariables);

	/** Uninitializes FShaderType cached data. */
	static RENDERCORE_API void Uninitialize();

	/** Minimal initialization constructor. */
	RENDERCORE_API FShaderType(
		EShaderTypeForDynamicCast InShaderTypeForDynamicCast,
		FTypeLayoutDesc& InTypeLayout,
		const TCHAR* InName,
		const TCHAR* InSourceFilename,
		const TCHAR* InFunctionName,
		uint32 InFrequency,
		int32 TotalPermutationCount,
		ConstructSerializedType InConstructSerializedRef,
		ConstructCompiledType InConstructCompiledRef,
		ShouldCompilePermutationType InShouldCompilePermutationRef,
		ShouldPrecachePermutationType InShouldPrecachePermutationRef,
		GetRayTracingPayloadTypeType InGetRayTracingPayloadTypeRef,
		GetShaderBindingLayoutType InGetShaderBindingLayoutTypeRef,
#if WITH_EDITOR
		ModifyCompilationEnvironmentType InModifyCompilationEnvironmentRef,
		ValidateCompiledResultType InValidateCompiledResultRef,
#endif // WITH_EDITOR
		uint32 InTypeSize,
		const FShaderParametersMetadata* InRootParametersMetadata
	);

	RENDERCORE_API virtual ~FShaderType();

	/** Constructs a new instance of the shader type for deserialization. */
	RENDERCORE_API FShader* ConstructForDeserialization() const;
	RENDERCORE_API FShader* ConstructCompiled(const FShader::CompiledShaderInitializerType& Initializer) const;

	RENDERCORE_API bool ShouldCompilePermutation(const FShaderPermutationParameters& Parameters) const;
	RENDERCORE_API EShaderPermutationPrecacheRequest ShouldPrecachePermutation(const FShaderPermutationParameters& Parameters) const;
	RENDERCORE_API const FShaderBindingLayout* GetShaderBindingLayout(const FShaderPermutationParameters& Parameters) const; 

#if WITH_EDITOR
	RENDERCORE_API void ModifyCompilationEnvironment(const FShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment) const;

	/**
	* Checks if the shader type should pass compilation for a particular set of parameters.
	* @param Platform - Platform to validate.
	* @param ParameterMap - Shader parameters to validate.
	* @param OutError - List for appending validation errors.
	*/
	RENDERCORE_API bool ValidateCompiledResult(EShaderPlatform Platform, const FShaderParameterMap& ParameterMap, TArray<FString>& OutError) const;
#endif // WITH_EDITOR

	RENDERCORE_API ERayTracingPayloadType GetRayTracingPayloadType(const int32 PermutationId) const;

	/** Calculates a Hash based on this shader type's source code and includes */
	RENDERCORE_API const FSHAHash& GetSourceHash(EShaderPlatform ShaderPlatform) const;

	/** Serializes a shader type reference by name. */
	RENDERCORE_API friend FArchive& operator<<(FArchive& Ar,FShaderType*& Ref);
	
	/** Hashes a pointer to a shader type. */
	friend uint32 GetTypeHash(FShaderType* Ref)
	{
		return Ref ? GetTypeHash(Ref->HashedName) : 0u;
	}

	// Dynamic casts.
	FORCEINLINE FGlobalShaderType* GetGlobalShaderType() 
	{ 
		return (ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::Global) ? reinterpret_cast<FGlobalShaderType*>(this) : nullptr;
	}
	FORCEINLINE const FGlobalShaderType* GetGlobalShaderType() const
	{
		return (ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::Global) ? reinterpret_cast<const FGlobalShaderType*>(this) : nullptr;
	}
	FORCEINLINE FMaterialShaderType* GetMaterialShaderType()
	{
		return (ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::Material) ? reinterpret_cast<FMaterialShaderType*>(this) : nullptr;
	}
	FORCEINLINE const FMaterialShaderType* GetMaterialShaderType() const
	{
		return (ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::Material) ? reinterpret_cast<const FMaterialShaderType*>(this) : nullptr;
	}
	FORCEINLINE FMeshMaterialShaderType* GetMeshMaterialShaderType()
	{
		return (ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::MeshMaterial) ? reinterpret_cast<FMeshMaterialShaderType*>(this) : nullptr;
	}
	FORCEINLINE const FMeshMaterialShaderType* GetMeshMaterialShaderType() const
	{
		return (ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::MeshMaterial) ? reinterpret_cast<const FMeshMaterialShaderType*>(this) : nullptr;
	}
	FORCEINLINE const FNiagaraShaderType* GetNiagaraShaderType() const
	{
		return (ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::Niagara) ? reinterpret_cast<const FNiagaraShaderType*>(this) : nullptr;
	}
	FORCEINLINE FNiagaraShaderType* GetNiagaraShaderType()
	{
		return (ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::Niagara) ? reinterpret_cast<FNiagaraShaderType*>(this) : nullptr;
	}
	FORCEINLINE const FOpenColorIOShaderType* GetOpenColorIOShaderType() const
	{
		return (ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::OCIO) ? reinterpret_cast<const FOpenColorIOShaderType*>(this) : nullptr;
	}
	FORCEINLINE FOpenColorIOShaderType* GetOpenColorIOShaderType()
	{
		return (ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::OCIO) ? reinterpret_cast<FOpenColorIOShaderType*>(this) : nullptr;
	}
	FORCEINLINE const FComputeKernelShaderType* GetComputeKernelShaderType() const
	{
		return (ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::ComputeKernel) ? reinterpret_cast<const FComputeKernelShaderType*>(this) : nullptr;
	}
	FORCEINLINE FComputeKernelShaderType* GetComputeKernelShaderType()
	{
		return (ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::ComputeKernel) ? reinterpret_cast<FComputeKernelShaderType*>(this) : nullptr;
	}

	FORCEINLINE const FGlobalShaderType* AsGlobalShaderType() const
	{
		checkf(ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::Global, TEXT("ShaderType %s is not Global"), GetName());
		return reinterpret_cast<const FGlobalShaderType*>(this);
	}

	FORCEINLINE const FMaterialShaderType* AsMaterialShaderType() const
	{
		checkf(ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::Material, TEXT("ShaderType %s is not Material"), GetName());
		return reinterpret_cast<const FMaterialShaderType*>(this);
	}

	FORCEINLINE const FMeshMaterialShaderType* AsMeshMaterialShaderType() const
	{
		checkf(ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::MeshMaterial, TEXT("ShaderType %s is not MeshMaterial"), GetName());
		return reinterpret_cast<const FMeshMaterialShaderType*>(this);
	}

	FORCEINLINE const FNiagaraShaderType* AsNiagaraShaderType() const
	{
		checkf(ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::Niagara, TEXT("ShaderType %s is not Niagara"), GetName());
		return reinterpret_cast<const FNiagaraShaderType*>(this);
	}

	FORCEINLINE const FOpenColorIOShaderType* AsOpenColorIOShaderType() const
	{
		checkf(ShaderTypeForDynamicCast == EShaderTypeForDynamicCast::OCIO, TEXT("ShaderType %s is not OCIO"), GetName());
		return reinterpret_cast<const FOpenColorIOShaderType*>(this);
	}

	inline EShaderTypeForDynamicCast GetTypeForDynamicCast() const
	{
		return ShaderTypeForDynamicCast;
	}

	// Accessors.
	inline const FTypeLayoutDesc& GetLayout() const
	{
		return *TypeLayout;
	}
	inline EShaderFrequency GetFrequency() const
	{ 
		return (EShaderFrequency)Frequency; 
	}
	inline const TCHAR* GetName() const
	{ 
		return Name; 
	}
	inline const FName& GetFName() const
	{
		return TypeName;
	}
	inline const FHashedName& GetHashedName() const
	{
		return HashedName;
	}
	inline const TCHAR* GetShaderFilename() const
	{ 
		return SourceFilename; 
	}
	inline const FHashedName& GetHashedShaderFilename() const
	{
		return HashedSourceFilename;
	}
	inline const TCHAR* GetFunctionName() const
	{
		return FunctionName;
	}
	inline uint32 GetTypeSize() const
	{
		return TypeSize;
	}

	inline int32 GetNumShaders() const
	{
		// TODO count this
		return 0;
	}

	inline int32 GetPermutationCount() const
	{
		return TotalPermutationCount;
	}

	/** Returns the meta data for the root shader parameter struct. */
	inline const FShaderParametersMetadata* GetRootParametersMetadata() const
	{
		return RootParametersMetadata;
	}

#if WITH_EDITOR
	UE_DEPRECATED(5.5, "GetReferencedUniformBufferNames is deprecated, use GetReferencedUniformBuffers instead")
	inline const TSet<const TCHAR*, TStringPointerSetKeyFuncs_DEPRECATED<const TCHAR*>>& GetReferencedUniformBufferNames() const
	{
		static TSet<const TCHAR*, TStringPointerSetKeyFuncs_DEPRECATED<const TCHAR*>> EmptySet;
		return EmptySet;
	}

	const TSet<const FShaderParametersMetadata*>& GetReferencedUniformBuffers() const
	{
		return ReferencedUniformBuffers;
	}

	/** Adds include statements for uniform buffers that this shader type references. */
	RENDERCORE_API void AddUniformBufferIncludesToEnvironment(FShaderCompilerEnvironment& OutEnvironment, EShaderPlatform Platform) const;

	RENDERCORE_API void UpdateReferencedUniformBufferNames(const TMap<FString, TArray<const TCHAR*>>& ShaderFileToUniformBufferVariables);

	RENDERCORE_API void GetShaderStableKeyParts(struct FStableShaderKeyAndValue& SaveKeyVal);
#endif // WITH_EDITOR

	RENDERCORE_API void DumpDebugInfo();

private:
	EShaderTypeForDynamicCast ShaderTypeForDynamicCast;
	const FTypeLayoutDesc* TypeLayout;
	const TCHAR* Name;
	FName TypeName;
	FHashedName HashedName;
	FHashedName HashedSourceFilename;
	const TCHAR* SourceFilename;
	const TCHAR* FunctionName;
	uint32 Frequency;
	uint32 TypeSize;
	int32 TotalPermutationCount;

	ConstructSerializedType ConstructSerializedRef;
	ConstructCompiledType ConstructCompiledRef;
	ShouldCompilePermutationType ShouldCompilePermutationRef;
	ShouldPrecachePermutationType ShouldPrecachePermutationRef;
	GetRayTracingPayloadTypeType GetRayTracingPayloadTypeRef;
	GetShaderBindingLayoutType GetShaderBindingLayoutTypeRef;
#if WITH_EDITOR
	ModifyCompilationEnvironmentType ModifyCompilationEnvironmentRef;
	ValidateCompiledResultType ValidateCompiledResultRef;
#endif
	const FShaderParametersMetadata* const RootParametersMetadata;

	TLinkedList<FShaderType*> GlobalListLink;

	friend void RENDERCORE_API DumpShaderStats( EShaderPlatform Platform, EShaderFrequency Frequency );

	/** Tracks whether serialization history for all shader types has been initialized. */
	static bool bInitializedSerializationHistory;

#if WITH_EDITOR
protected:
	/**
	* Cache of referenced uniform buffer structs.
	* These are derived from source files so they need to be flushed when editing and recompiling shaders on the fly.
	* FShaderType::Initialize will add the referenced uniform buffers, but this set may be updated by FlushShaderFileCache.
	*/
	TSet<const FShaderParametersMetadata*> ReferencedUniformBuffers;
#endif // WITH_EDITOR
};

/**
 * Registers a shader type in various systems. Should be created as a static field/global.
 * 
 * Each shader type is collected here, not as an instance but as an accessor, so the actual construction can be deferred.
 * The collection happens during static init, the actual construction happens later during launch.
 * The purpose of collecting the types is the CommitAll function, called in LaunchEngineLoop, to ensure all type instances are constructed and registered before other systems start iterating them.
 */
class FShaderTypeRegistration
{
public:
	FShaderTypeRegistration(TFunctionRef<FShaderType& ()> LazyShaderTypeAccessor)
		: LazyShaderTypeAccessor(LazyShaderTypeAccessor)
	{
		GetInstances().Add(this);
	}

	static RENDERCORE_API TArray<const FShaderTypeRegistration*>& GetInstances();

	// Actually register all the types and clear the array
	static RENDERCORE_API void CommitAll();

private:
	TFunctionRef<FShaderType& ()> LazyShaderTypeAccessor;
};

struct FShaderCompiledShaderInitializerType
{
	const FShaderType* Type;
	const FShaderType::FParameters* Parameters;
	FShaderTarget Target;
	TConstArrayView<uint8> Code;
	const FShaderParameterMap& ParameterMap;
	const FSHAHash& OutputHash;
	FSHAHash MaterialShaderMapHash;
	const FShaderPipelineType* ShaderPipeline;
	const FVertexFactoryType* VertexFactoryType;
	uint32 NumInstructions;
	uint32 NumTextureSamplers;
	uint32 CodeSize;
	int32 PermutationId;
	TArray<FGenericShaderStat> ShaderStatistics;

	RENDERCORE_API FShaderCompiledShaderInitializerType(
		const FShaderType* InType,
		const FShaderType::FParameters* InParameters,
		int32 InPermutationId,
		const FShaderCompilerOutput& CompilerOutput,
		const FSHAHash& InMaterialShaderMapHash,
		const FShaderPipelineType* InShaderPipeline,
		const FVertexFactoryType* InVertexFactoryType
	);
};

#if WITH_EDITOR
	#define SHADER_DECLARE_EDITOR_VTABLE(ShaderClass) \
		static void ModifyCompilationEnvironmentImpl(const FShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment) \
		{ \
			const typename ShaderClass::FPermutationDomain PermutationVector(Parameters.PermutationId); \
			PermutationVector.ModifyCompilationEnvironment(OutEnvironment); \
			ShaderClass::ModifyCompilationEnvironment(static_cast<const typename ShaderClass::FPermutationParameters&>(Parameters), OutEnvironment); \
		}
#else
	#define SHADER_DECLARE_EDITOR_VTABLE(ShaderClass)
#endif // WITH_EDITOR

#define SHADER_DECLARE_VTABLE(ShaderClass) \
	static FShader* ConstructSerializedInstance() { return new ShaderClass(); } \
	static FShader* ConstructCompiledInstance(const typename FShader::CompiledShaderInitializerType& Initializer) \
	{ return new ShaderClass(static_cast<const typename ShaderMetaType::CompiledShaderInitializerType&>(Initializer)); }\
	static bool ShouldCompilePermutationImpl(const FShaderPermutationParameters& Parameters) \
	{ return ShaderClass::ShouldCompilePermutation(static_cast<const typename ShaderClass::FPermutationParameters&>(Parameters)); } \
	static EShaderPermutationPrecacheRequest ShouldPrecachePermutationImpl(const FShaderPermutationParameters& Parameters) \
	{ return ShaderClass::ShouldPrecachePermutation(static_cast<const typename ShaderClass::FPermutationParameters&>(Parameters)); } \
	SHADER_DECLARE_EDITOR_VTABLE(ShaderClass)


#define INTERNAL_DECLARE_SHADER_TYPE_COMMON(ShaderClass,ShaderMetaTypeShortcut,RequiredAPI) \
	public: \
	using ShaderMetaType = F##ShaderMetaTypeShortcut##ShaderType; \
	using ShaderMapType = F##ShaderMetaTypeShortcut##ShaderMap; \
	\
	static RequiredAPI ShaderMetaType& GetStaticType(); \
	private: \
	static FShaderTypeRegistration ShaderTypeRegistration; \
	public: \
	\
	SHADER_DECLARE_VTABLE(ShaderClass)

/**
 * A macro to declare a new shader type.  This should be called in the class body of the new shader type.
 * @param ShaderClass - The name of the class representing an instance of the shader type.
 * @param ShaderMetaTypeShortcut - The shortcut for the shader meta type: simple, material, meshmaterial, etc.  The shader meta type
 *	controls 
 */
#define DECLARE_EXPORTED_SHADER_TYPE(ShaderClass,ShaderMetaTypeShortcut,RequiredAPI, ...) \
	INTERNAL_DECLARE_SHADER_TYPE_COMMON(ShaderClass, ShaderMetaTypeShortcut, RequiredAPI); \
	DECLARE_EXPORTED_TYPE_LAYOUT(ShaderClass, RequiredAPI, NonVirtual); \
	public:

#define DECLARE_SHADER_TYPE(ShaderClass,ShaderMetaTypeShortcut,...) \
	DECLARE_EXPORTED_SHADER_TYPE(ShaderClass,ShaderMetaTypeShortcut,, ##__VA_ARGS__)

#define DECLARE_SHADER_TYPE_EXPLICIT_BASES(ShaderClass,ShaderMetaTypeShortcut,...) \
	INTERNAL_DECLARE_SHADER_TYPE_COMMON(ShaderClass, ShaderMetaTypeShortcut,); \
	DECLARE_EXPORTED_TYPE_LAYOUT_EXPLICIT_BASES(ShaderClass,, NonVirtual, __VA_ARGS__); \
	public:

#if WITH_EDITOR
#define SHADER_TYPE_EDITOR_VTABLE(ShaderClass) \
	, ShaderClass::ModifyCompilationEnvironmentImpl \
	, ShaderClass::ValidateCompiledResult
#else
#define SHADER_TYPE_EDITOR_VTABLE(ShaderClass)
#endif

#define SHADER_TYPE_VTABLE(ShaderClass) \
	ShaderClass::ConstructSerializedInstance, \
	ShaderClass::ConstructCompiledInstance, \
	ShaderClass::ShouldCompilePermutationImpl, \
	ShaderClass::ShouldPrecachePermutationImpl, \
	ShaderClass::GetRayTracingPayloadType, \
	ShaderClass::GetShaderBindingLayout \
	SHADER_TYPE_EDITOR_VTABLE(ShaderClass)

#if !UE_BUILD_DOCS
/** A macro to implement a shader type. */
#define IMPLEMENT_SHADER_TYPE(TemplatePrefix,ShaderClass,SourceFilename,FunctionName,Frequency) \
	IMPLEMENT_UNREGISTERED_TEMPLATE_TYPE_LAYOUT(TemplatePrefix, ShaderClass); \
	TemplatePrefix \
	ShaderClass::ShaderMetaType& ShaderClass::GetStaticType() \
	{ \
		static ShaderClass::ShaderMetaType StaticType( \
			ShaderClass::StaticGetTypeLayout(), \
			TEXT(#ShaderClass), \
			SourceFilename, \
			FunctionName, \
			Frequency, \
			ShaderClass::FPermutationDomain::PermutationCount, \
			SHADER_TYPE_VTABLE(ShaderClass), \
			sizeof(ShaderClass), \
			ShaderClass::GetRootParametersMetadata() \
		); \
		return StaticType; \
	} \
	TemplatePrefix FShaderTypeRegistration ShaderClass::ShaderTypeRegistration{TFunctionRef<::FShaderType&()>{ShaderClass::GetStaticType}};

/** A macro to implement a shader type. Shader name is got from GetDebugName(), which is helpful for templated shaders. */
#define IMPLEMENT_SHADER_TYPE_WITH_DEBUG_NAME(TemplatePrefix,ShaderClass,SourceFilename,FunctionName,Frequency) \
	IMPLEMENT_UNREGISTERED_TEMPLATE_TYPE_LAYOUT(TemplatePrefix, ShaderClass); \
	TemplatePrefix \
	typename ShaderClass::ShaderMetaType& ShaderClass::GetStaticType() \
	{ \
		static typename ShaderClass::ShaderMetaType StaticType( \
			ShaderClass::StaticGetTypeLayout(), \
			ShaderClass::GetDebugName(), \
			SourceFilename, \
			FunctionName, \
			Frequency, \
			ShaderClass::FPermutationDomain::PermutationCount, \
			SHADER_TYPE_VTABLE(ShaderClass), \
			sizeof(ShaderClass), \
			ShaderClass::GetRootParametersMetadata() \
		); \
		return StaticType; \
	} \
	TemplatePrefix FShaderTypeRegistration ShaderClass::ShaderTypeRegistration{TFunctionRef<::FShaderType&()>{ShaderClass::GetStaticType}};

/** A macro to implement a templated shader type, the function name and the source filename comes from the class. */
#define IMPLEMENT_SHADER_TYPE2_WITH_TEMPLATE_PREFIX(TemplatePrefix,ShaderClass,Frequency) \
	IMPLEMENT_UNREGISTERED_TEMPLATE_TYPE_LAYOUT(TemplatePrefix, ShaderClass); \
	TemplatePrefix \
	ShaderClass::ShaderMetaType& ShaderClass::GetStaticType() \
	{ \
		static ShaderClass::ShaderMetaType StaticType( \
			ShaderClass::StaticGetTypeLayout(), \
			TEXT(#ShaderClass), \
			ShaderClass::GetSourceFilename(), \
			ShaderClass::GetFunctionName(), \
			Frequency, \
			ShaderClass::FPermutationDomain::PermutationCount, \
			SHADER_TYPE_VTABLE(ShaderClass), \
			sizeof(ShaderClass), \
			ShaderClass::GetRootParametersMetadata() \
		); \
		return StaticType; \
	} \
	TemplatePrefix FShaderTypeRegistration ShaderClass::ShaderTypeRegistration{TFunctionRef<::FShaderType&()>{ShaderClass::GetStaticType}};

#define IMPLEMENT_SHADER_TYPE2(ShaderClass,Frequency) \
	IMPLEMENT_SHADER_TYPE2_WITH_TEMPLATE_PREFIX(template<>, ShaderClass, Frequency)

/** todo: this should replace IMPLEMENT_SHADER_TYPE */
#define IMPLEMENT_SHADER_TYPE3(ShaderClass,Frequency) \
	IMPLEMENT_UNREGISTERED_TEMPLATE_TYPE_LAYOUT(,ShaderClass); \
	ShaderClass::ShaderMetaType& ShaderClass::GetStaticType() \
	{ \
		static ShaderClass::ShaderMetaType StaticType( \
			ShaderClass::StaticGetTypeLayout(), \
			TEXT(#ShaderClass), \
			ShaderClass::GetSourceFilename(), \
			ShaderClass::GetFunctionName(), \
			Frequency, \
			ShaderClass::FPermutationDomain::PermutationCount, \
			SHADER_TYPE_VTABLE(ShaderClass), \
			sizeof(ShaderClass), \
			ShaderClass::GetRootParametersMetadata() \
		); \
		return StaticType; \
	} \
	FShaderTypeRegistration ShaderClass::ShaderTypeRegistration{TFunctionRef<::FShaderType&()>{ShaderClass::GetStaticType}};
#endif // !UE_BUILD_DOCS

#define IMPLEMENT_SHADER_TYPE4_WITH_TEMPLATE_PREFIX(TemplatePrefix,RequiredAPI,ShaderClass,Frequency) \
	IMPLEMENT_UNREGISTERED_TEMPLATE_TYPE_LAYOUT(TemplatePrefix, ShaderClass); \
	TemplatePrefix RequiredAPI \
	ShaderClass::ShaderMetaType& ShaderClass::GetStaticType() \
	{ \
		static ShaderClass::ShaderMetaType StaticType( \
			ShaderClass::StaticGetTypeLayout(), \
			TEXT(#ShaderClass), \
			ShaderClass::GetSourceFilename(), \
			ShaderClass::GetFunctionName(), \
			Frequency, \
			ShaderClass::FPermutationDomain::PermutationCount, \
			SHADER_TYPE_VTABLE(ShaderClass), \
			sizeof(ShaderClass), \
			ShaderClass::GetRootParametersMetadata() \
		); \
		return StaticType; \
	} \
	TemplatePrefix FShaderTypeRegistration ShaderClass::ShaderTypeRegistration{TFunctionRef<::FShaderType&()>{ShaderClass::GetStaticType}};

// Binding of a set of shader stages in a single pipeline
class FShaderPipelineType
{
public:
	// Set bShouldOptimizeUnusedOutputs to true if we want unique FShaders for each shader pipeline
	// Set bShouldOptimizeUnusedOutputs to false if the FShaders will point to the individual shaders in the map
	RENDERCORE_API FShaderPipelineType(
		const TCHAR* InName,
		const FShaderType* InVertexOrMeshShader,
		const FShaderType* InGeometryOrAmplificationShader,
		const FShaderType* InPixelShader,
		bool bInIsMeshPipeline,
		bool bInShouldOptimizeUnusedOutputs);
	RENDERCORE_API ~FShaderPipelineType();

	FORCEINLINE bool HasMeshShader() const { return AllStages[SF_Mesh] != nullptr; }
	FORCEINLINE bool HasGeometry() const { return AllStages[SF_Geometry] != nullptr; }
	FORCEINLINE bool HasPixelShader() const { return AllStages[SF_Pixel] != nullptr; }

	FORCEINLINE const FShaderType* GetShader(EShaderFrequency Frequency) const
	{
		check(Frequency < SF_NumFrequencies);
		return AllStages[Frequency];
	}

	FORCEINLINE FName GetFName() const { return TypeName; }
	FORCEINLINE TCHAR const* GetName() const { return Name; }
	FORCEINLINE const FHashedName& GetHashedName() const { return HashedName; }
	FORCEINLINE const FHashedName& GetHashedPrimaryShaderFilename() const { return HashedPrimaryShaderFilename; }

	// Returns an array of valid stages, sorted from PS->GS->DS->HS->VS, no gaps if missing stages
	FORCEINLINE const TArray<const FShaderType*>& GetStages() const { return Stages; }

	static RENDERCORE_API TLinkedList<FShaderPipelineType*>*& GetTypeList();

	static RENDERCORE_API const TArray<FShaderPipelineType*>& GetSortedTypes(FShaderType::EShaderTypeForDynamicCast Type);

	/** @return The global shader pipeline name to type map */
	static RENDERCORE_API TMap<FHashedName, FShaderPipelineType*>& GetNameToTypeMap();
	static RENDERCORE_API const FShaderPipelineType* GetShaderPipelineTypeByName(const FHashedName& Name);

	/** Initialize static members, this must be called before any shader types are created. */
	static RENDERCORE_API void Initialize();

	static RENDERCORE_API TArray<const FShaderPipelineType*> GetShaderPipelineTypesByFilename(const TCHAR* Filename);

	/** Serializes a shader type reference by name. */
	RENDERCORE_API friend FArchive& operator<<(FArchive& Ar, const FShaderPipelineType*& Ref);

	/** Hashes a pointer to a shader type. */
	friend uint32 GetTypeHash(FShaderPipelineType* Ref) { return Ref ? Ref->HashIndex : 0; }
	friend uint32 GetTypeHash(const FShaderPipelineType* Ref) { return Ref ? Ref->HashIndex : 0; }

	// Check if this pipeline is built of specific types
	bool IsGlobalTypePipeline() const { return Stages[0]->GetGlobalShaderType() != nullptr; }
	bool IsMaterialTypePipeline() const { return Stages[0]->GetMaterialShaderType() != nullptr; }
	bool IsMeshMaterialTypePipeline() const { return Stages[0]->GetMeshMaterialShaderType() != nullptr; }

	RENDERCORE_API bool ShouldOptimizeUnusedOutputs(EShaderPlatform Platform) const;

	/** Calculates a Hash based on this shader pipeline type stages' source code and includes */
	RENDERCORE_API const FSHAHash& GetSourceHash(EShaderPlatform ShaderPlatform) const;

	RENDERCORE_API bool ShouldCompilePermutation(const FShaderPermutationParameters& Parameters) const;

	RENDERCORE_API EShaderPermutationPrecacheRequest ShouldPrecachePermutation(const FShaderPermutationParameters& Parameters) const;

protected:
	const TCHAR* const Name;
	FName TypeName;
	FHashedName HashedName;
	FHashedName HashedPrimaryShaderFilename;

	// Pipeline Stages, ordered from lowest (usually PS) to highest (VS). Guaranteed at least one stage (for VS).
	TArray<const FShaderType*> Stages;

	const FShaderType* AllStages[SF_NumFrequencies];

	TLinkedList<FShaderPipelineType*> GlobalListLink;

	uint32 HashIndex;
	bool bShouldOptimizeUnusedOutputs;

	static RENDERCORE_API bool bInitialized;
};

#if !UE_BUILD_DOCS
// Vertex+Pixel
#define IMPLEMENT_SHADERPIPELINE_TYPE_VSPS(PipelineName, VertexShaderType, PixelShaderType, bRemoveUnused)	\
	static FShaderPipelineType PipelineName(TEXT(PREPROCESSOR_TO_STRING(PipelineName)), &VertexShaderType::GetStaticType(), nullptr, &PixelShaderType::GetStaticType(), false, bRemoveUnused);
// Only VS
#define IMPLEMENT_SHADERPIPELINE_TYPE_VS(PipelineName, VertexShaderType, bRemoveUnused)	\
	static FShaderPipelineType PipelineName(TEXT(PREPROCESSOR_TO_STRING(PipelineName)), &VertexShaderType::GetStaticType(), nullptr, nullptr, false, bRemoveUnused);
// Vertex+Geometry+Pixel
#define IMPLEMENT_SHADERPIPELINE_TYPE_VSGSPS(PipelineName, VertexShaderType, GeometryShaderType, PixelShaderType, bRemoveUnused)	\
	static FShaderPipelineType PipelineName(TEXT(PREPROCESSOR_TO_STRING(PipelineName)), &VertexShaderType::GetStaticType(), &GeometryShaderType::GetStaticType(), &PixelShaderType::GetStaticType(), false, bRemoveUnused);
// Vertex+Geometry
#define IMPLEMENT_SHADERPIPELINE_TYPE_VSGS(PipelineName, VertexShaderType, GeometryShaderType, bRemoveUnused)	\
	static FShaderPipelineType PipelineName(TEXT(PREPROCESSOR_TO_STRING(PipelineName)), &VertexShaderType::GetStaticType(), &GeometryShaderType::GetStaticType(), nullptr, false, bRemoveUnused);

// Mesh+Pixel
#define IMPLEMENT_SHADERPIPELINE_TYPE_MSPS(PipelineName, MeshShaderType, PixelShaderType, bRemoveUnused)	\
	static FShaderPipelineType PipelineName(TEXT(PREPROCESSOR_TO_STRING(PipelineName)), &MeshShaderType::GetStaticType(), nullptr, &PixelShaderType::GetStaticType(), true, bRemoveUnused);
// Mesh+Amplification+Pixel
#define IMPLEMENT_SHADERPIPELINE_TYPE_MSASPS(PipelineName, MeshShaderType, AmplificationShaderType, PixelShaderType, bRemoveUnused)	\
	static FShaderPipelineType PipelineName(TEXT(PREPROCESSOR_TO_STRING(PipelineName)), &MeshShaderType::GetStaticType(), &AmplificationShaderType::GetStaticType(), &PixelShaderType::GetStaticType(), true, bRemoveUnused);
#endif

/** Encapsulates a dependency on a shader type and saved state from that shader type. */
class FShaderTypeDependency
{
	DECLARE_EXPORTED_TYPE_LAYOUT(FShaderTypeDependency, RENDERCORE_API, NonVirtual);
public:

	FShaderTypeDependency()
		: PermutationId(0)
	{}

	FShaderTypeDependency(FShaderType* InShaderType, EShaderPlatform ShaderPlatform)
		: ShaderTypeName(InShaderType->GetHashedName())
		, PermutationId(0)
	{
		if (InShaderType)
		{
			SourceHash = InShaderType->GetSourceHash(ShaderPlatform);
		}
	}

	friend FArchive& operator<<(FArchive& Ar,class FShaderTypeDependency& Ref)
	{
		Ar.UsingCustomVersion(FRenderingObjectVersion::GUID);

		Ar << Ref.ShaderTypeName;
		Ar << Ref.SourceHash;

		if (Ar.CustomVer(FRenderingObjectVersion::GUID) >= FRenderingObjectVersion::ShaderPermutationId)
		{
			Ar << Ref.PermutationId;
		}

		return Ar;
	}

	bool operator==(const FShaderTypeDependency& Reference) const
	{
		return ShaderTypeName == Reference.ShaderTypeName && PermutationId == Reference.PermutationId && SourceHash == Reference.SourceHash;
	}

	bool operator!=(const FShaderTypeDependency& Reference) const
	{
		return !(*this == Reference);
	}

	/** Call GetShaderFileHash to get the cached value for the filename's hash in the current process. */
	RENDERCORE_API void RefreshCachedSourceHash(EShaderPlatform ShaderPlatform);

	/** Shader type */
	LAYOUT_FIELD(FHashedName, ShaderTypeName);

	/** Unique permutation identifier of the global shader type. */
	LAYOUT_FIELD(int32, PermutationId);

	/** Used to detect changes to the shader source files. This is always present, as this type is sometimes frozen. */
	LAYOUT_FIELD(FSHAHash, SourceHash);

private:
#if WITH_EDITOR
	// Compact binary API with hidden friend operator<<
	RENDERCORE_API void Save(FCbWriter& Writer) const;
	bool TryLoad(FCbFieldView Field);
	friend inline FCbWriter& operator<<(FCbWriter& Writer, const FShaderTypeDependency& Value)
	{
		Value.Save(Writer);
		return Writer;
	}
	friend RENDERCORE_API bool LoadFromCompactBinary(FCbFieldView Field, FShaderTypeDependency& OutValue);
#endif
};


class FShaderPipelineTypeDependency
{
public:
	FShaderPipelineTypeDependency() {}
	FShaderPipelineTypeDependency(const FShaderPipelineType* InShaderPipelineType, EShaderPlatform ShaderPlatform) :
		ShaderPipelineTypeName(InShaderPipelineType->GetHashedName())
	{
		if (InShaderPipelineType)
		{
			StagesSourceHash = InShaderPipelineType->GetSourceHash(ShaderPlatform);
		}
	}

	/** Shader Pipeline type */
	FHashedName ShaderPipelineTypeName;

	/** Used to detect changes to the shader source files. */
	FSHAHash StagesSourceHash;

	friend FArchive& operator<<(FArchive& Ar, class FShaderPipelineTypeDependency& Ref)
	{
		Ar << Ref.ShaderPipelineTypeName;
		Ar << Ref.StagesSourceHash;
		return Ar;
	}

	bool operator==(const FShaderPipelineTypeDependency& Reference) const
	{
		return ShaderPipelineTypeName == Reference.ShaderPipelineTypeName && StagesSourceHash == Reference.StagesSourceHash;
	}

	bool operator!=(const FShaderPipelineTypeDependency& Reference) const
	{
		return !(*this == Reference);
	}

	/** Call GetShaderFileHash to get the cached value for the filename's hash in the current process. */
	RENDERCORE_API void RefreshCachedSourceHash(EShaderPlatform ShaderPlatform);

private:
#if WITH_EDITOR
	// Compact binary API with hidden friend operator<<
	RENDERCORE_API void Save(FCbWriter& Writer) const;
	bool TryLoad(FCbFieldView Field);
	friend inline FCbWriter& operator<<(FCbWriter& Writer, const FShaderPipelineTypeDependency& Value)
	{
		Value.Save(Writer);
		return Writer;
	}
	friend RENDERCORE_API bool LoadFromCompactBinary(FCbFieldView Field, FShaderPipelineTypeDependency& OutValue);
#endif
};

/** Used to compare two shader types by name. */
class FCompareShaderTypes
{																				
public:
	FORCEINLINE bool operator()(const FShaderType& A, const FShaderType& B ) const
	{
		int32 AL = FCString::Strlen(A.GetName());
		int32 BL = FCString::Strlen(B.GetName());
		if ( AL == BL )
		{
			return FCString::Strncmp(A.GetName(), B.GetName(), AL) > 0;
		}
		return AL > BL;
	}
};


// A Shader Pipeline instance with compiled stages
class FShaderPipeline
{
	DECLARE_EXPORTED_TYPE_LAYOUT(FShaderPipeline, RENDERCORE_API, NonVirtual);
public:
	explicit FShaderPipeline(const FShaderPipelineType* InType) : TypeName(InType->GetHashedName()) { FMemory::Memzero(&PermutationIds, sizeof(PermutationIds)); }
	RENDERCORE_API ~FShaderPipeline();

	RENDERCORE_API void AddShader(FShader* Shader, int32 PermutationId);
	RENDERCORE_API FShader* FindOrAddShader(FShader* Shader, int32 PermutationId);

	inline uint32 GetNumShaders() const
	{
		uint32 NumShaders = 0u;
		for (uint32 i = 0u; i < SF_NumGraphicsFrequencies; ++i)
		{
			if (Shaders[i].IsValid())
			{
				++NumShaders;
			}
		}
		return NumShaders;
	}

	// Find a shader inside the pipeline
	template<typename ShaderType>
	ShaderType* GetShader(const FShaderMapPointerTable& InPtrTable)
	{
		const FShaderType& Type = ShaderType::GetStaticType();
		const EShaderFrequency Frequency = Type.GetFrequency();
		if (Frequency < SF_NumGraphicsFrequencies && Shaders[Frequency].IsValid())
		{
			FShader* Shader = Shaders[Frequency].GetChecked();
			if (Shader->GetType(InPtrTable) == &Type)
			{
				return static_cast<ShaderType*>(Shader);
			}
		}
		return nullptr;
	}

	FShader* GetShader(EShaderFrequency Frequency)
	{
		check(Frequency < SF_NumGraphicsFrequencies);
		return Shaders[Frequency];
	}

	const FShader* GetShader(EShaderFrequency Frequency) const
	{
		check(Frequency < SF_NumGraphicsFrequencies);
		return Shaders[Frequency];
	}

	inline TArray<TShaderRef<FShader>> GetShaders(const FShaderMapBase& InShaderMap) const
	{
		TArray<TShaderRef<FShader>> Result;
		for (uint32 i = 0u; i < SF_NumGraphicsFrequencies; ++i)
		{
			if (Shaders[i].IsValid())
			{
				Result.Add(TShaderRef<FShader>(Shaders[i].GetChecked(), InShaderMap));
			}
		}
		return Result;
	}

	RENDERCORE_API void Validate(const FShaderPipelineType* InPipelineType) const;

	RENDERCORE_API void Finalize(const FShaderMapResourceCode* Code);

	enum EFilter
	{
		EAll,			// All pipelines
		EOnlyShared,	// Only pipelines with shared shaders
		EOnlyUnique,	// Only pipelines with unique shaders
	};

	/** Saves stable keys for the shaders in the pipeline */
#if WITH_EDITOR
	RENDERCORE_API void SaveShaderStableKeys(const FShaderMapPointerTable& InPtrTable, EShaderPlatform TargetShaderPlatform, const struct FStableShaderKeyAndValue& SaveKeyVal) const;
#endif // WITH_EDITOR

	LAYOUT_FIELD(FHashedName, TypeName);
	LAYOUT_ARRAY(TMemoryImagePtr<FShader>, Shaders, SF_NumGraphicsFrequencies);
	LAYOUT_ARRAY(int32, PermutationIds, SF_NumGraphicsFrequencies);
};

inline bool operator<(const FShaderPipeline& Lhs, const FShaderPipeline& Rhs)
{
	return Lhs.TypeName.GetHash() < Rhs.TypeName.GetHash();
}

class FShaderPipelineRef
{
public:
	FShaderPipelineRef() : ShaderPipeline(nullptr), ShaderMap(nullptr) {}
	FShaderPipelineRef(FShaderPipeline* InPipeline, const FShaderMapBase& InShaderMap) : ShaderPipeline(InPipeline), ShaderMap(&InShaderMap) { checkSlow(InPipeline); }

	inline bool IsValid() const { return ShaderPipeline != nullptr; }
	inline bool IsNull() const { return ShaderPipeline == nullptr; }

	template<typename ShaderType>
	TShaderRef<ShaderType> GetShader() const
	{
		return TShaderRef<ShaderType>(ShaderPipeline->GetShader<ShaderType>(GetPointerTable()), *ShaderMap);
	}

	TShaderRef<FShader> GetShader(EShaderFrequency Frequency) const
	{
		return TShaderRef<FShader>(ShaderPipeline->GetShader(Frequency), *ShaderMap);
	}

	inline TArray<TShaderRef<FShader>> GetShaders() const
	{
		return ShaderPipeline->GetShaders(*ShaderMap);
	}

	inline FShaderPipeline* GetPipeline() const { return ShaderPipeline; }
	FShaderMapResource* GetResource() const;
	const FShaderMapPointerTable& GetPointerTable() const;

	inline FShaderPipeline* operator->() const { check(ShaderPipeline); return ShaderPipeline; }

private:
	FShaderPipeline* ShaderPipeline;
	const FShaderMapBase* ShaderMap;
};

/** A collection of shaders of different types */
class FShaderMapContent
{
	DECLARE_EXPORTED_TYPE_LAYOUT(FShaderMapContent, RENDERCORE_API, NonVirtual);
public:
	struct FProjectShaderPipelineToKey
	{
		inline FHashedName operator()(const FShaderPipeline* InShaderPipeline) { return InShaderPipeline->TypeName; }
	};

	/** Default constructor. */
	RENDERCORE_API explicit FShaderMapContent(EShaderPlatform InPlatform);

	/** Destructor ensures pipelines cleared up. */
	RENDERCORE_API ~FShaderMapContent();

	RENDERCORE_API EShaderPlatform GetShaderPlatform() const;

	RENDERCORE_API void Validate(const FShaderMapBase& InShaderMap) const;

	/** Finds the shader with the given type.  Asserts on failure. */
	template<typename ShaderType>
	ShaderType* GetShader(int32 PermutationId = 0) const
	{
		FShader* Shader = GetShader(&ShaderType::GetStaticType(), PermutationId);
		checkf(Shader != nullptr, TEXT("Failed to find shader type %s in Platform %s"), ShaderType::GetStaticType().GetName(), *LegacyShaderPlatformToShaderFormat(GetShaderPlatform()).ToString());
		return static_cast<ShaderType*>(Shader);
	}

	/** Finds the shader with the given type.  Asserts on failure. */
	template<typename ShaderType>
	ShaderType* GetShader( const typename ShaderType::FPermutationDomain& PermutationVector ) const
	{
		return GetShader<ShaderType>( PermutationVector.ToDimensionValueId() );
	}

	/** Finds the shader with the given type.  May return NULL. */
	FShader* GetShader(const FShaderType* ShaderType, int32 PermutationId = 0) const
	{
		return GetShader(ShaderType->GetHashedName(), PermutationId);
	}

	/** Finds the shader with the given type name.  May return NULL. */
	RENDERCORE_API FShader* GetShader(const FHashedName& TypeName, int32 PermutationId = 0) const;

	/** Finds the shader with the given type. */
	bool HasShader(const FHashedName& TypeName, int32 PermutationId) const
	{
		const FShader* Shader = GetShader(TypeName, PermutationId);
		return Shader != nullptr;
	}

	bool HasShader(const FShaderType* Type, int32 PermutationId) const
	{
		return HasShader(Type->GetHashedName(), PermutationId);
	}

	inline TArrayView<const TMemoryImagePtr<FShader>> GetShaders() const
	{
		return Shaders;
	}

	inline TArrayView<const TMemoryImagePtr<FShaderPipeline>> GetShaderPipelines() const
	{
		return ShaderPipelines;
	}

	RENDERCORE_API void AddShader(const FHashedName& TypeName, int32 PermutationId, FShader* Shader);

	RENDERCORE_API FShader* FindOrAddShader(const FHashedName& TypeName, int32 PermutationId, FShader* Shader);

	RENDERCORE_API void AddShaderPipeline(FShaderPipeline* Pipeline);

	RENDERCORE_API FShaderPipeline* FindOrAddShaderPipeline(FShaderPipeline* Pipeline);

	/**
	 * Removes the shader of the given type from the shader map
	 * @param Type Shader type to remove the entry for 
	 */
	RENDERCORE_API void RemoveShaderTypePermutaion(const FHashedName& TypeName, int32 PermutationId);

	inline void RemoveShaderTypePermutaion(const FShaderType* Type, int32 PermutationId)
	{
		RemoveShaderTypePermutaion(Type->GetHashedName(), PermutationId);
	}

	RENDERCORE_API void RemoveShaderPipelineType(const FShaderPipelineType* ShaderPipelineType);

	/** Builds a list of the shaders in a shader map. */
	RENDERCORE_API void GetShaderList(const FShaderMapBase& InShaderMap, const FSHAHash& InMaterialShaderMapHash, TMap<FShaderId, TShaderRef<FShader>>& OutShaders) const;

	/** Builds a list of the shaders in a shader map. Key is FShaderType::TypeName */
	RENDERCORE_API void GetShaderList(const FShaderMapBase& InShaderMap, TMap<FHashedName, TShaderRef<FShader>>& OutShaders) const;

	/** Builds a list of the shader pipelines in a shader map. */
	RENDERCORE_API void GetShaderPipelineList(const FShaderMapBase& InShaderMap, TArray<FShaderPipelineRef>& OutShaderPipelines, FShaderPipeline::EFilter Filter) const;

#if WITH_EDITOR
	RENDERCORE_API uint32 GetMaxTextureSamplersShaderMap(const FShaderMapBase& InShaderMap) const;

	RENDERCORE_API void GetOutdatedTypes(const FShaderMapBase& InShaderMap, TArray<const FShaderType*>& OutdatedShaderTypes, TArray<const FShaderPipelineType*>& OutdatedShaderPipelineTypes, TArray<const FVertexFactoryType*>& OutdatedFactoryTypes) const;

	RENDERCORE_API void SaveShaderStableKeys(const FShaderMapBase& InShaderMap, EShaderPlatform TargetShaderPlatform, const struct FStableShaderKeyAndValue& SaveKeyVal);

	UE_DEPRECATED(5.5, "GetShaderStatistics which returns a reference to the stat map is deprecated. Please use the function that returns a non-ref.")
	RENDERCORE_API const FShader::FShaderStatisticMap GetShaderStatisticsMapForShader(const FShaderMapBase& InShaderMap, FShaderType* ShaderType) const
	{
		static FShader::FShaderStatisticMap DummyStatMap;
		return DummyStatMap;
	}
#endif // WITH_EDITOR

#if WITH_EDITORONLY_DATA
	RENDERCORE_API TArray<FGenericShaderStat> GetShaderStatistics(const FShaderMapBase& InShaderMap, FShaderType* ShaderType) const;
#endif // WITH_EDITORONLY_DATA

	/** @return true if the map is empty */
	inline bool IsEmpty() const
	{
		return Shaders.Num() == 0;
	}

	/** @return The number of shaders in the map. */
	RENDERCORE_API uint32 GetNumShaders() const;

	/** @return The number of shader pipelines in the map. */
	inline uint32 GetNumShaderPipelines() const
	{
		return ShaderPipelines.Num();
	}

	/** clears out all shaders and deletes shader pipelines held in the map */
	RENDERCORE_API void Empty();

	inline FShaderPipeline* GetShaderPipeline(const FHashedName& PipelineTypeName) const
	{
		const int32 Index = Algo::BinarySearchBy(ShaderPipelines, PipelineTypeName, FProjectShaderPipelineToKey());
		return (Index != INDEX_NONE) ? ShaderPipelines[Index].Get() : nullptr;
	}

	inline FShaderPipeline* GetShaderPipeline(const FShaderPipelineType* PipelineType) const
	{
		return GetShaderPipeline(PipelineType->GetHashedName());
	}

	inline bool HasShaderPipeline(const FHashedName& PipelineTypeName) const { return GetShaderPipeline(PipelineTypeName) != nullptr; }
	inline bool HasShaderPipeline(const FShaderPipelineType* PipelineType) const { return (GetShaderPipeline(PipelineType) != nullptr); }

	RENDERCORE_API uint32 GetMaxNumInstructionsForShader(const FShaderMapBase& InShaderMap, FShaderType* ShaderType) const;

	RENDERCORE_API void Finalize(const FShaderMapResourceCode* Code);

	RENDERCORE_API void UpdateHash(FSHA1& Hasher) const;

protected:
	RENDERCORE_API void EmptyShaderPipelines();

	using FMemoryImageHashTable = THashTable<FMemoryImageAllocator>;

	LAYOUT_FIELD(FMemoryImageHashTable, ShaderHash);
	LAYOUT_FIELD(TMemoryImageArray<FHashedName>, ShaderTypes);
	LAYOUT_FIELD(TMemoryImageArray<int32>, ShaderPermutations);
	LAYOUT_FIELD(TMemoryImageArray<TMemoryImagePtr<FShader>>, Shaders);
	LAYOUT_FIELD(TMemoryImageArray<TMemoryImagePtr<FShaderPipeline>>, ShaderPipelines);
	/** The ShaderPlatform Name this shader map was compiled with */
	LAYOUT_FIELD(FMemoryImageName, ShaderPlatformName);
};

class FShaderMapBase
{
public:
	RENDERCORE_API virtual ~FShaderMapBase();

	RENDERCORE_API FShaderMapResourceCode* GetResourceCode();

	inline FShaderMapResource* GetResource() const { return Resource; }
	inline FShaderMapResource* GetResourceChecked() const { check(Resource); return Resource; }
	inline const FShaderMapPointerTable& GetPointerTable() const { check(PointerTable); return *PointerTable; }
	inline const FShaderMapContent* GetContent() const { return Content.Object; }
	inline FShaderMapContent* GetMutableContent()
	{
		UnfreezeContent();
		return Content.Object;
	}
	/** Builds a list of the shaders in a shader map. Key is FShaderType::TypeName */
	RENDERCORE_API virtual void GetShaderList(TMap<FHashedName, TShaderRef<FShader>>& OutShaders) const = 0;
	RENDERCORE_API virtual void GetShaderPipelineList(TArray<FShaderPipelineRef>& OutShaderPipelines) const = 0;

	inline EShaderPlatform GetShaderPlatform() const { return Content.Object ? Content.Object->GetShaderPlatform() : SP_NumPlatforms; }
	inline uint32 GetFrozenContentSize() const { return Content.FrozenSize; }

	RENDERCORE_API void AssignContent(TMemoryImageObject<FShaderMapContent> InContent);

	RENDERCORE_API void FinalizeContent();
	RENDERCORE_API void UnfreezeContent();
	UE_DEPRECATED(5.5, "Please use overload accepting an FShaderSerializeContext. Note that inlining of shader code into runtime shadermaps is no longer supported. If you rely on this please reach out to the UE rendering team.")
	RENDERCORE_API bool Serialize(FArchive& Ar, bool bInlineShaderResources, bool bLoadingCooked, bool bInlineShaderCode = false, const FName& SerializingAsset = NAME_None)
	{
		FShaderSerializeContext Ctx(Ar);
		Ctx.bLoadingCooked = bLoadingCooked;
		Ctx.SerializingAsset = SerializingAsset;
		return Serialize(Ctx);
	}

	RENDERCORE_API bool Serialize(FShaderSerializeContext& Ctx);

	EShaderPermutationFlags GetPermutationFlags() const
	{
		return PermutationFlags;
	}

	RENDERCORE_API FString ToString() const;

#if WITH_EDITORONLY_DATA
	RENDERCORE_API TArray<FGenericShaderStat> GetShaderStatistics(FShaderType* ShaderType) const;
	RENDERCORE_API TArray<FGenericShaderStat> GetShaderStatistics(FShader& Shader) const;
#endif

#if WITH_EDITOR
	inline void GetOutdatedTypes(TArray<const FShaderType*>& OutdatedShaderTypes, TArray<const FShaderPipelineType*>& OutdatedShaderPipelineTypes, TArray<const FVertexFactoryType*>& OutdatedFactoryTypes) const
	{
		Content.Object->GetOutdatedTypes(*this, OutdatedShaderTypes, OutdatedShaderPipelineTypes, OutdatedFactoryTypes);
	}
	void SaveShaderStableKeys(EShaderPlatform TargetShaderPlatform, const struct FStableShaderKeyAndValue& SaveKeyVal)
	{
		Content.Object->SaveShaderStableKeys(*this, TargetShaderPlatform, SaveKeyVal);
	}

	/** Associates a shadermap with an asset (note: one shadermap can be used by several assets, e.g. MIs). 
	 * This helps cooker lay out the shadermaps (and shaders) in the file open order, if provided. Maps not associated with any assets
	 * may be placed after all maps associated with known assets. Global shadermaps need to be associated with a "Global" asset */
	void AssociateWithAsset(const FName& AssetPath)
	{
		AssociatedAssets.Add(AssetPath);
	}

	void AssociateWithAssets(const FShaderMapAssetPaths& AssetPaths)
	{
		AssociatedAssets.Append(AssetPaths);
	}

	const FShaderMapAssetPaths& GetAssociatedAssets() const
	{
		return AssociatedAssets;
	}
#endif // WITH_EDITOR

protected:
	RENDERCORE_API FShaderMapBase();

	RENDERCORE_API void AssignCopy(const FShaderMapBase& Source);

	RENDERCORE_API void InitResource();
	RENDERCORE_API void DestroyContent();

protected:
	virtual const FTypeLayoutDesc& GetContentTypeDesc() const = 0;
	virtual FShaderMapPointerTable* CreatePointerTable() const = 0;
	virtual void PostFinalizeContent() { }

private:
#if WITH_EDITOR
	/** List of the assets that are using this shadermap. This is only available in the editor (cooker) to influence ordering of shader libraries. */
	FShaderMapAssetPaths AssociatedAssets;
#endif
	TRefCountPtr<FShaderMapResource> Resource;
	TRefCountPtr<FShaderMapResourceCode> Code;
	FShaderMapPointerTable* PointerTable;
	TMemoryImageObject<FShaderMapContent> Content;
	uint32 NumFrozenShaders;
	EShaderPermutationFlags PermutationFlags;
};

template<typename ContentType, typename PointerTableType = FShaderMapPointerTable>
class TShaderMap : public FShaderMapBase
{
public:
	inline const PointerTableType& GetPointerTable() const { return static_cast<const PointerTableType&>(FShaderMapBase::GetPointerTable()); }
	inline const ContentType* GetContent() const { return static_cast<const ContentType*>(FShaderMapBase::GetContent()); }
	inline ContentType* GetMutableContent() { return static_cast<ContentType*>(FShaderMapBase::GetMutableContent()); }

	void FinalizeContent()
	{
		ContentType* LocalContent = this->GetMutableContent();
		check(LocalContent);
		LocalContent->Finalize(this->GetResourceCode());
		LocalContent->Validate(*this);
		FShaderMapBase::FinalizeContent();
	}

protected:
	virtual const FTypeLayoutDesc& GetContentTypeDesc() const final override { return StaticGetTypeLayoutDesc<ContentType>(); }
	virtual FShaderMapPointerTable* CreatePointerTable() const final override { return new PointerTableType(); }
};

template<typename ShaderType, typename PointerTableType>
inline const PointerTableType& TShaderRefBase<ShaderType, PointerTableType>::GetPointerTable() const
{
	checkSlow(ShaderMap);
	return static_cast<const PointerTableType&>(ShaderMap->GetPointerTable());
}

template<typename ShaderType, typename PointerTableType>
inline FShaderMapResource* TShaderRefBase<ShaderType, PointerTableType>::GetResource() const
{
	checkSlow(ShaderMap);
	return ShaderMap->GetResource();
}

inline const FShaderMapPointerTable& FShaderPipelineRef::GetPointerTable() const
{
	checkSlow(ShaderMap);
	return ShaderMap->GetPointerTable();
}

inline FShaderMapResource* FShaderPipelineRef::GetResource() const
{
	checkSlow(ShaderMap);
	return ShaderMap->GetResource();
}

/** A reference which is initialized with the requested shader type from a shader map. */
template<typename ShaderType>
class TShaderMapRef : public TShaderRef<ShaderType>
{
public:
	TShaderMapRef(const typename ShaderType::ShaderMapType* ShaderIndex)
		: TShaderRef<ShaderType>(ShaderIndex->template GetShader<ShaderType>(/* PermutationId = */ 0)) // gcc3 needs the template quantifier so it knows the < is not a less-than
	{
		static_assert(
			std::is_same_v<typename ShaderType::FPermutationDomain, FShaderPermutationNone>,
			"Missing permutation vector argument for shader that have a permutation domain.");
	}

	TShaderMapRef(
		const typename ShaderType::ShaderMapType* ShaderIndex,
		const typename ShaderType::FPermutationDomain& PermutationVector)
		: TShaderRef<ShaderType>(ShaderIndex->template GetShader<ShaderType>(PermutationVector.ToDimensionValueId())) // gcc3 needs the template quantifier so it knows the < is not a less-than
	{ }
};

/** A reference to an optional shader, initialized with a shader type from a shader map if it is available or nullptr if it is not. */
template<typename ShaderType>
class TOptionalShaderMapRef : public TShaderRef<ShaderType>
{
public:
	TOptionalShaderMapRef(const typename ShaderType::ShaderMapType* ShaderIndex):
		TShaderRef<ShaderType>(TShaderRef<ShaderType>::Cast(ShaderIndex->GetShader(&ShaderType::GetStaticType()))) // gcc3 needs the template quantifier so it knows the < is not a less-than
	{}
};

/** Tracks state when traversing a FSerializationHistory. */
class UE_DEPRECATED(5.4, "FSerializationHistoryTraversalState is no longer used and will be removed") FSerializationHistoryTraversalState
{
public:
	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	FSerializationHistoryTraversalState(const FSerializationHistory& InHistory)
	PRAGMA_ENABLE_DEPRECATION_WARNINGS
	{}

	/** Gets the length value from NextTokenIndex + Offset into history. */
	uint32 GetValue(int32 Offset)
	{
		return 0;
	}

	FORCEINLINE void StepForward()
	{
	}

	void StepBackward()
	{
	}
};

/** Archive used when saving shaders, which generates data used to detect serialization mismatches on load. */
class UE_DEPRECATED(5.4, "FShaderSaveArchive is no longer used and will be removed") FShaderSaveArchive final : public FArchiveProxy
{
public:

	PRAGMA_DISABLE_DEPRECATION_WARNINGS
	FShaderSaveArchive(FArchive& Archive, FSerializationHistory& InHistory) : 
		FArchiveProxy(Archive)
	PRAGMA_ENABLE_DEPRECATION_WARNINGS
	{
	}

	virtual ~FShaderSaveArchive()
	{
	}

	virtual void Serialize( void* V, int64 Length )
	{
	}
};

/**
 * Dumps shader stats to the log. Will also print some shader pipeline information.
 * @param Platform  - Platform to dump shader info for, use SP_NumPlatforms for all
 * @param Frequency - Whether to dump PS or VS info, use SF_NumFrequencies to dump both
 */
extern RENDERCORE_API void DumpShaderStats( EShaderPlatform Platform, EShaderFrequency Frequency );

/**
 * Dumps shader pipeline stats to the log. Does not include material (eg shader pipeline instance) information.
 * @param Platform  - Platform to dump shader info for, use SP_NumPlatforms for all
 */
extern RENDERCORE_API void DumpShaderPipelineStats(EShaderPlatform Platform);

/**
 * Finds the shader type with a given name.
 * @param ShaderTypeName - The name of the shader type to find.
 * @return The shader type, or NULL if none matched.
 */
extern RENDERCORE_API FShaderType* FindShaderTypeByName(const FHashedName& ShaderTypeName);

/** Helper function to dispatch a compute shader while checking that parameters have been set correctly. */
extern RENDERCORE_API void DispatchComputeShader(
	FRHIComputeCommandList& RHICmdList,
	FShader* Shader,
	uint32 ThreadGroupCountX,
	uint32 ThreadGroupCountY,
	uint32 ThreadGroupCountZ);

/** Helper function to dispatch a compute shader indirectly while checking that parameters have been set correctly. */
extern RENDERCORE_API void DispatchIndirectComputeShader(
	FRHIComputeCommandList& RHICmdList,
	FShader* Shader,
	FRHIBuffer* ArgumentBuffer,
	uint32 ArgumentOffset);

inline void DispatchComputeShader(
	FRHIComputeCommandList& RHICmdList,
	const TShaderRef<FShader>& Shader,
	uint32 ThreadGroupCountX,
	uint32 ThreadGroupCountY,
	uint32 ThreadGroupCountZ)
{
	DispatchComputeShader(RHICmdList, Shader.GetShader(), ThreadGroupCountX, ThreadGroupCountY, ThreadGroupCountZ);
}

/** Returns whether the platform is using emulated uniform buffers */
extern RENDERCORE_API bool IsUsingEmulatedUniformBuffers(EShaderPlatform Platform);

/** Returns whether DirectXShaderCompiler (DXC) is enabled for the specified shader platform. See console variables "r.OpenGL.ForceDXC", "r.D3D.ForceDXC". */
extern RENDERCORE_API bool IsDxcEnabledForPlatform(EShaderPlatform Platform, bool bHlslVersion2021 = false);

/** Appends to KeyString for all shaders. */
extern RENDERCORE_API void ShaderMapAppendKeyString(EShaderPlatform Platform, FString& KeyString);
extern RENDERCORE_API void ShaderMapAppendKey(EShaderPlatform Platform, FShaderKeyGenerator& KeyGen);
